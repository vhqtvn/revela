// Copyright (c) Aptos
// SPDX-License-Identifier: Apache-2.0

// This file was generated. Do not modify!
//
// To update this code, run: `cargo run --release -p framework`.

// Conversion library between a structured representation of a Move script call (`ScriptCall`) and the
// standard BCS-compatible representation used in Aptos transactions (`Script`).
//
// This code was generated by compiling known Script interfaces ("ABIs") with the tool `aptos-sdk-builder`.

#![allow(unused_imports)]
use aptos_types::{
    account_address::AccountAddress,
    transaction::{ScriptFunction, TransactionPayload},
};
use move_deps::move_core_types::{
    ident_str,
    language_storage::{ModuleId, TypeTag},
};

type Bytes = Vec<u8>;

/// Structured representation of a call into a known Move script function.
/// ```ignore
/// impl ScriptFunctionCall {
///     pub fn encode(self) -> TransactionPayload { .. }
///     pub fn decode(&TransactionPayload) -> Option<ScriptFunctionCall> { .. }
/// }
/// ```
#[derive(Clone, Debug, PartialEq)]
#[cfg_attr(feature = "fuzzing", derive(proptest_derive::Arbitrary))]
#[cfg_attr(feature = "fuzzing", proptest(no_params))]
pub enum ScriptFunctionCall {
    /// Basic account creation methods.
    AccountCreateAccount {
        auth_key: AccountAddress,
    },

    AccountRotateAuthenticationKey {
        new_auth_key: Bytes,
    },

    AccountTransfer {
        to: AccountAddress,
        amount: u64,
    },

    /// Claim the delegated mint capability and destroy the delegated token.
    AptosCoinClaimMintCapability {},

    /// Create delegated token for the address so the account could claim MintCapability later.
    AptosCoinDelegateMintCapability {
        to: AccountAddress,
    },

    /// Create new test coins and deposit them into dst_addr's account.
    AptosCoinMint {
        dst_addr: AccountAddress,
        amount: u64,
    },

    /// Create a proposal with the backing `stake_pool`.
    /// @param execution_hash Required. This is the hash of the resolution script. When the proposal is resolved,
    /// only the exact script with matching hash can be successfully executed.
    AptosGovernanceCreateProposal {
        stake_pool: AccountAddress,
        execution_hash: Bytes,
        metadata_location: Bytes,
        metadata_hash: Bytes,
    },

    /// Vote on proposal with `proposal_id` and voting power from `stake_pool`.
    AptosGovernanceVote {
        stake_pool: AccountAddress,
        proposal_id: u64,
        should_pass: bool,
    },

    /// Same as `publish_package` but as an entry function which can be called as a transaction. Because
    /// of current restrictions for txn parameters, the metadata needs to be passed in serialized form.
    CodePublishPackageTxn {
        pack_serialized: Bytes,
        code: Vec<Bytes>,
    },

    /// Transfers `amount` of coins `CoinType` from `from` to `to`.
    CoinTransfer {
        coin_type: TypeTag,
        to: AccountAddress,
        amount: u64,
    },

    /// Script function to register to receive a specific `CoinType`. An account that wants to hold a coin type
    /// has to explicitly registers to do so. The register creates a special `CoinStore`
    /// to hold the specified `CoinType`.
    CoinsRegister {
        coin_type: TypeTag,
    },

    /// Sets up the initial validator set for the network.
    /// The validator "owner" accounts, and their authentication
    /// Addresses (and keys) are encoded in the `owners`
    /// Each validator signs consensus messages with the private key corresponding to the Ed25519
    /// public key in `consensus_pubkeys`.
    /// Finally, each validator must specify the network address
    /// (see types/src/network_address/mod.rs) for itself and its full nodes.
    ///
    /// Network address fields are a vector per account, where each entry is a vector of addresses
    /// encoded in a single BCS byte array.
    GenesisCreateInitializeValidators {
        owners: Vec<AccountAddress>,
        consensus_pubkeys: Vec<Bytes>,
        proof_of_possession: Vec<Bytes>,
        validator_network_addresses: Vec<Bytes>,
        full_node_network_addresses: Vec<Bytes>,
        staking_distribution: Vec<u64>,
        initial_lockup_timestamp: u64,
    },

    /// Withdraw an `amount` of coin `CoinType` from `account` and burn it.
    ManagedCoinBurn {
        coin_type: TypeTag,
        amount: u64,
    },

    /// Initialize new coin `CoinType` in Aptos Blockchain.
    /// Mint and Burn Capabilities will be stored under `account` in `Capabilities` resource.
    ManagedCoinInitialize {
        coin_type: TypeTag,
        name: Bytes,
        symbol: Bytes,
        decimals: u64,
        monitor_supply: bool,
    },

    /// Create new coins `CoinType` and deposit them into dst_addr's account.
    ManagedCoinMint {
        coin_type: TypeTag,
        dst_addr: AccountAddress,
        amount: u64,
    },

    /// Creating a resource that stores balance of `CoinType` on user's account, withdraw and deposit event handlers.
    /// Required if user wants to start accepting deposits of `CoinType` in his account.
    ManagedCoinRegister {
        coin_type: TypeTag,
    },

    /// Force an epoch change.
    ReconfigurationForceReconfigure {},

    /// Creates a new resource account and rotates the authentication key to either
    /// the optional auth key if it is non-empty (though auth keys are 32-bytes)
    /// or the source accounts current auth key.
    ResourceAccountCreateResourceAccount {
        seed: Bytes,
        optional_auth_key: Bytes,
    },

    /// Add `amount` of coins from the `account` owning the StakePool.
    StakeAddStake {
        amount: u64,
    },

    /// Similar to increase_lockup_with_cap but will use ownership capability from the signing account.
    StakeIncreaseLockup {
        new_locked_until_secs: u64,
    },

    /// This can only called by the operator of the validator/staking pool.
    StakeJoinValidatorSet {
        pool_address: AccountAddress,
    },

    /// Request to have `pool_address` leave the validator set. The validator is only actually removed from the set when
    /// the next epoch starts.
    /// The last validator in the set cannot leave. This is an edge case that should never happen as long as the network
    /// is still operational.
    ///
    /// Can only be called by the operator of the validator/staking pool.
    StakeLeaveValidatorSet {
        pool_address: AccountAddress,
    },

    /// Initialize the validator account and give ownership to the signing account.
    StakeRegisterValidatorCandidate {
        consensus_pubkey: Bytes,
        proof_of_possession: Bytes,
        network_addresses: Bytes,
        fullnode_addresses: Bytes,
    },

    /// Rotate the consensus key of the validator, it'll take effect in next epoch.
    StakeRotateConsensusKey {
        pool_address: AccountAddress,
        new_consensus_pubkey: Bytes,
        proof_of_possession: Bytes,
    },

    /// Allows an owner to change the delegated voter of the stake pool.
    StakeSetDelegatedVoter {
        new_delegated_voter: AccountAddress,
    },

    /// Allows an owner to change the operator of the stake pool.
    StakeSetOperator {
        new_operator: AccountAddress,
    },

    /// Similar to unlock_with_cap but will use ownership capability from the signing account.
    StakeUnlock {
        amount: u64,
    },

    /// Update the network and full node addresses of the validator. This only takes effect in the next epoch.
    StakeUpdateNetworkAndFullnodeAddresses {
        pool_address: AccountAddress,
        new_network_addresses: Bytes,
        new_fullnode_addresses: Bytes,
    },

    /// Withdraw from `account`'s inactive stake.
    StakeWithdraw {
        withdraw_amount: u64,
    },

    TokenCreateLimitedCollectionScript {
        name: Bytes,
        description: Bytes,
        uri: Bytes,
        maximum: u64,
    },

    TokenCreateLimitedTokenScript {
        collection: Bytes,
        name: Bytes,
        description: Bytes,
        monitor_supply: bool,
        initial_balance: u64,
        maximum: u64,
        uri: Bytes,
        royalty_points_per_million: u64,
    },

    TokenCreateUnlimitedCollectionScript {
        name: Bytes,
        description: Bytes,
        uri: Bytes,
    },

    TokenCreateUnlimitedTokenScript {
        collection: Bytes,
        name: Bytes,
        description: Bytes,
        monitor_supply: bool,
        initial_balance: u64,
        uri: Bytes,
        royalty_points_per_million: u64,
    },

    TokenDirectTransferScript {
        creators_address: AccountAddress,
        collection: Bytes,
        name: Bytes,
        amount: u64,
    },

    TokenInitializeTokenForId {
        creators_address: AccountAddress,
        collection: Bytes,
        name: Bytes,
    },

    TokenInitializeTokenScript {},

    TokenTransfersCancelOfferScript {
        receiver: AccountAddress,
        creator: AccountAddress,
        collection: Bytes,
        name: Bytes,
    },

    TokenTransfersClaimScript {
        sender: AccountAddress,
        creator: AccountAddress,
        collection: Bytes,
        name: Bytes,
    },

    TokenTransfersOfferScript {
        receiver: AccountAddress,
        creator: AccountAddress,
        collection: Bytes,
        name: Bytes,
        amount: u64,
    },

    TransactionPublishingOptionSetModulePublishingAllowed {
        is_allowed: bool,
    },

    ValidatorSetScriptAddValidator {
        _validator_addr: AccountAddress,
    },

    ValidatorSetScriptCreateValidatorAccount {
        _new_account_address: AccountAddress,
        _human_name: Bytes,
    },

    ValidatorSetScriptCreateValidatorOperatorAccount {
        _new_account_address: AccountAddress,
        _human_name: Bytes,
    },

    ValidatorSetScriptRegisterValidatorConfig {
        _validator_address: AccountAddress,
        _consensus_pubkey: Bytes,
        _validator_network_addresses: Bytes,
        _fullnode_network_addresses: Bytes,
    },

    ValidatorSetScriptRemoveValidator {
        _validator_addr: AccountAddress,
    },

    ValidatorSetScriptSetValidatorConfigAndReconfigure {
        _validator_account: AccountAddress,
        _consensus_pubkey: Bytes,
        _validator_network_addresses: Bytes,
        _fullnode_network_addresses: Bytes,
    },

    ValidatorSetScriptSetValidatorOperator {
        _operator_name: Bytes,
        _operator_account: AccountAddress,
    },

    /// Updates the major version to a larger version.
    /// This is only used in test environments and outside of them, the core resources account shouldn't exist.
    VersionSetVersion {
        major: u64,
    },

    VmConfigSetGasConstants {
        global_memory_per_byte_cost: u64,
        global_memory_per_byte_write_cost: u64,
        min_transaction_gas_units: u64,
        large_transaction_cutoff: u64,
        intrinsic_gas_per_byte: u64,
        maximum_number_of_gas_units: u64,
        min_price_per_gas_unit: u64,
        max_price_per_gas_unit: u64,
        max_transaction_size_in_bytes: u64,
        gas_unit_scaling_factor: u64,
        default_account_size: u64,
    },
}

impl ScriptFunctionCall {
    /// Build an Aptos `TransactionPayload` from a structured object `ScriptFunctionCall`.
    pub fn encode(self) -> TransactionPayload {
        use ScriptFunctionCall::*;
        match self {
            AccountCreateAccount { auth_key } => account_create_account(auth_key),
            AccountRotateAuthenticationKey { new_auth_key } => {
                account_rotate_authentication_key(new_auth_key)
            }
            AccountTransfer { to, amount } => account_transfer(to, amount),
            AptosCoinClaimMintCapability {} => aptos_coin_claim_mint_capability(),
            AptosCoinDelegateMintCapability { to } => aptos_coin_delegate_mint_capability(to),
            AptosCoinMint { dst_addr, amount } => aptos_coin_mint(dst_addr, amount),
            AptosGovernanceCreateProposal {
                stake_pool,
                execution_hash,
                metadata_location,
                metadata_hash,
            } => aptos_governance_create_proposal(
                stake_pool,
                execution_hash,
                metadata_location,
                metadata_hash,
            ),
            AptosGovernanceVote {
                stake_pool,
                proposal_id,
                should_pass,
            } => aptos_governance_vote(stake_pool, proposal_id, should_pass),
            CodePublishPackageTxn {
                pack_serialized,
                code,
            } => code_publish_package_txn(pack_serialized, code),
            CoinTransfer {
                coin_type,
                to,
                amount,
            } => coin_transfer(coin_type, to, amount),
            CoinsRegister { coin_type } => coins_register(coin_type),
            GenesisCreateInitializeValidators {
                owners,
                consensus_pubkeys,
                proof_of_possession,
                validator_network_addresses,
                full_node_network_addresses,
                staking_distribution,
                initial_lockup_timestamp,
            } => genesis_create_initialize_validators(
                owners,
                consensus_pubkeys,
                proof_of_possession,
                validator_network_addresses,
                full_node_network_addresses,
                staking_distribution,
                initial_lockup_timestamp,
            ),
            ManagedCoinBurn { coin_type, amount } => managed_coin_burn(coin_type, amount),
            ManagedCoinInitialize {
                coin_type,
                name,
                symbol,
                decimals,
                monitor_supply,
            } => managed_coin_initialize(coin_type, name, symbol, decimals, monitor_supply),
            ManagedCoinMint {
                coin_type,
                dst_addr,
                amount,
            } => managed_coin_mint(coin_type, dst_addr, amount),
            ManagedCoinRegister { coin_type } => managed_coin_register(coin_type),
            ReconfigurationForceReconfigure {} => reconfiguration_force_reconfigure(),
            ResourceAccountCreateResourceAccount {
                seed,
                optional_auth_key,
            } => resource_account_create_resource_account(seed, optional_auth_key),
            StakeAddStake { amount } => stake_add_stake(amount),
            StakeIncreaseLockup {
                new_locked_until_secs,
            } => stake_increase_lockup(new_locked_until_secs),
            StakeJoinValidatorSet { pool_address } => stake_join_validator_set(pool_address),
            StakeLeaveValidatorSet { pool_address } => stake_leave_validator_set(pool_address),
            StakeRegisterValidatorCandidate {
                consensus_pubkey,
                proof_of_possession,
                network_addresses,
                fullnode_addresses,
            } => stake_register_validator_candidate(
                consensus_pubkey,
                proof_of_possession,
                network_addresses,
                fullnode_addresses,
            ),
            StakeRotateConsensusKey {
                pool_address,
                new_consensus_pubkey,
                proof_of_possession,
            } => {
                stake_rotate_consensus_key(pool_address, new_consensus_pubkey, proof_of_possession)
            }
            StakeSetDelegatedVoter {
                new_delegated_voter,
            } => stake_set_delegated_voter(new_delegated_voter),
            StakeSetOperator { new_operator } => stake_set_operator(new_operator),
            StakeUnlock { amount } => stake_unlock(amount),
            StakeUpdateNetworkAndFullnodeAddresses {
                pool_address,
                new_network_addresses,
                new_fullnode_addresses,
            } => stake_update_network_and_fullnode_addresses(
                pool_address,
                new_network_addresses,
                new_fullnode_addresses,
            ),
            StakeWithdraw { withdraw_amount } => stake_withdraw(withdraw_amount),
            TokenCreateLimitedCollectionScript {
                name,
                description,
                uri,
                maximum,
            } => token_create_limited_collection_script(name, description, uri, maximum),
            TokenCreateLimitedTokenScript {
                collection,
                name,
                description,
                monitor_supply,
                initial_balance,
                maximum,
                uri,
                royalty_points_per_million,
            } => token_create_limited_token_script(
                collection,
                name,
                description,
                monitor_supply,
                initial_balance,
                maximum,
                uri,
                royalty_points_per_million,
            ),
            TokenCreateUnlimitedCollectionScript {
                name,
                description,
                uri,
            } => token_create_unlimited_collection_script(name, description, uri),
            TokenCreateUnlimitedTokenScript {
                collection,
                name,
                description,
                monitor_supply,
                initial_balance,
                uri,
                royalty_points_per_million,
            } => token_create_unlimited_token_script(
                collection,
                name,
                description,
                monitor_supply,
                initial_balance,
                uri,
                royalty_points_per_million,
            ),
            TokenDirectTransferScript {
                creators_address,
                collection,
                name,
                amount,
            } => token_direct_transfer_script(creators_address, collection, name, amount),
            TokenInitializeTokenForId {
                creators_address,
                collection,
                name,
            } => token_initialize_token_for_id(creators_address, collection, name),
            TokenInitializeTokenScript {} => token_initialize_token_script(),
            TokenTransfersCancelOfferScript {
                receiver,
                creator,
                collection,
                name,
            } => token_transfers_cancel_offer_script(receiver, creator, collection, name),
            TokenTransfersClaimScript {
                sender,
                creator,
                collection,
                name,
            } => token_transfers_claim_script(sender, creator, collection, name),
            TokenTransfersOfferScript {
                receiver,
                creator,
                collection,
                name,
                amount,
            } => token_transfers_offer_script(receiver, creator, collection, name, amount),
            TransactionPublishingOptionSetModulePublishingAllowed { is_allowed } => {
                transaction_publishing_option_set_module_publishing_allowed(is_allowed)
            }
            ValidatorSetScriptAddValidator { _validator_addr } => {
                validator_set_script_add_validator(_validator_addr)
            }
            ValidatorSetScriptCreateValidatorAccount {
                _new_account_address,
                _human_name,
            } => validator_set_script_create_validator_account(_new_account_address, _human_name),
            ValidatorSetScriptCreateValidatorOperatorAccount {
                _new_account_address,
                _human_name,
            } => validator_set_script_create_validator_operator_account(
                _new_account_address,
                _human_name,
            ),
            ValidatorSetScriptRegisterValidatorConfig {
                _validator_address,
                _consensus_pubkey,
                _validator_network_addresses,
                _fullnode_network_addresses,
            } => validator_set_script_register_validator_config(
                _validator_address,
                _consensus_pubkey,
                _validator_network_addresses,
                _fullnode_network_addresses,
            ),
            ValidatorSetScriptRemoveValidator { _validator_addr } => {
                validator_set_script_remove_validator(_validator_addr)
            }
            ValidatorSetScriptSetValidatorConfigAndReconfigure {
                _validator_account,
                _consensus_pubkey,
                _validator_network_addresses,
                _fullnode_network_addresses,
            } => validator_set_script_set_validator_config_and_reconfigure(
                _validator_account,
                _consensus_pubkey,
                _validator_network_addresses,
                _fullnode_network_addresses,
            ),
            ValidatorSetScriptSetValidatorOperator {
                _operator_name,
                _operator_account,
            } => validator_set_script_set_validator_operator(_operator_name, _operator_account),
            VersionSetVersion { major } => version_set_version(major),
            VmConfigSetGasConstants {
                global_memory_per_byte_cost,
                global_memory_per_byte_write_cost,
                min_transaction_gas_units,
                large_transaction_cutoff,
                intrinsic_gas_per_byte,
                maximum_number_of_gas_units,
                min_price_per_gas_unit,
                max_price_per_gas_unit,
                max_transaction_size_in_bytes,
                gas_unit_scaling_factor,
                default_account_size,
            } => vm_config_set_gas_constants(
                global_memory_per_byte_cost,
                global_memory_per_byte_write_cost,
                min_transaction_gas_units,
                large_transaction_cutoff,
                intrinsic_gas_per_byte,
                maximum_number_of_gas_units,
                min_price_per_gas_unit,
                max_price_per_gas_unit,
                max_transaction_size_in_bytes,
                gas_unit_scaling_factor,
                default_account_size,
            ),
        }
    }

    /// Try to recognize an Aptos `TransactionPayload` and convert it into a structured object `ScriptFunctionCall`.
    pub fn decode(payload: &TransactionPayload) -> Option<ScriptFunctionCall> {
        if let TransactionPayload::ScriptFunction(script) = payload {
            match SCRIPT_FUNCTION_DECODER_MAP.get(&format!(
                "{}_{}",
                script.module().name(),
                script.function()
            )) {
                Some(decoder) => decoder(payload),
                None => None,
            }
        } else {
            None
        }
    }
}

/// Basic account creation methods.
pub fn account_create_account(auth_key: AccountAddress) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("account").to_owned(),
        ),
        ident_str!("create_account").to_owned(),
        vec![],
        vec![bcs::to_bytes(&auth_key).unwrap()],
    ))
}

pub fn account_rotate_authentication_key(new_auth_key: Vec<u8>) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("account").to_owned(),
        ),
        ident_str!("rotate_authentication_key").to_owned(),
        vec![],
        vec![bcs::to_bytes(&new_auth_key).unwrap()],
    ))
}

pub fn account_transfer(to: AccountAddress, amount: u64) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("account").to_owned(),
        ),
        ident_str!("transfer").to_owned(),
        vec![],
        vec![bcs::to_bytes(&to).unwrap(), bcs::to_bytes(&amount).unwrap()],
    ))
}

/// Claim the delegated mint capability and destroy the delegated token.
pub fn aptos_coin_claim_mint_capability() -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("aptos_coin").to_owned(),
        ),
        ident_str!("claim_mint_capability").to_owned(),
        vec![],
        vec![],
    ))
}

/// Create delegated token for the address so the account could claim MintCapability later.
pub fn aptos_coin_delegate_mint_capability(to: AccountAddress) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("aptos_coin").to_owned(),
        ),
        ident_str!("delegate_mint_capability").to_owned(),
        vec![],
        vec![bcs::to_bytes(&to).unwrap()],
    ))
}

/// Create new test coins and deposit them into dst_addr's account.
pub fn aptos_coin_mint(dst_addr: AccountAddress, amount: u64) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("aptos_coin").to_owned(),
        ),
        ident_str!("mint").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&dst_addr).unwrap(),
            bcs::to_bytes(&amount).unwrap(),
        ],
    ))
}

/// Create a proposal with the backing `stake_pool`.
/// @param execution_hash Required. This is the hash of the resolution script. When the proposal is resolved,
/// only the exact script with matching hash can be successfully executed.
pub fn aptos_governance_create_proposal(
    stake_pool: AccountAddress,
    execution_hash: Vec<u8>,
    metadata_location: Vec<u8>,
    metadata_hash: Vec<u8>,
) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("aptos_governance").to_owned(),
        ),
        ident_str!("create_proposal").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&stake_pool).unwrap(),
            bcs::to_bytes(&execution_hash).unwrap(),
            bcs::to_bytes(&metadata_location).unwrap(),
            bcs::to_bytes(&metadata_hash).unwrap(),
        ],
    ))
}

/// Vote on proposal with `proposal_id` and voting power from `stake_pool`.
pub fn aptos_governance_vote(
    stake_pool: AccountAddress,
    proposal_id: u64,
    should_pass: bool,
) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("aptos_governance").to_owned(),
        ),
        ident_str!("vote").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&stake_pool).unwrap(),
            bcs::to_bytes(&proposal_id).unwrap(),
            bcs::to_bytes(&should_pass).unwrap(),
        ],
    ))
}

/// Same as `publish_package` but as an entry function which can be called as a transaction. Because
/// of current restrictions for txn parameters, the metadata needs to be passed in serialized form.
pub fn code_publish_package_txn(
    pack_serialized: Vec<u8>,
    code: Vec<Vec<u8>>,
) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("code").to_owned(),
        ),
        ident_str!("publish_package_txn").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&pack_serialized).unwrap(),
            bcs::to_bytes(&code).unwrap(),
        ],
    ))
}

/// Transfers `amount` of coins `CoinType` from `from` to `to`.
pub fn coin_transfer(coin_type: TypeTag, to: AccountAddress, amount: u64) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("coin").to_owned(),
        ),
        ident_str!("transfer").to_owned(),
        vec![coin_type],
        vec![bcs::to_bytes(&to).unwrap(), bcs::to_bytes(&amount).unwrap()],
    ))
}

/// Script function to register to receive a specific `CoinType`. An account that wants to hold a coin type
/// has to explicitly registers to do so. The register creates a special `CoinStore`
/// to hold the specified `CoinType`.
pub fn coins_register(coin_type: TypeTag) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("coins").to_owned(),
        ),
        ident_str!("register").to_owned(),
        vec![coin_type],
        vec![],
    ))
}

/// Sets up the initial validator set for the network.
/// The validator "owner" accounts, and their authentication
/// Addresses (and keys) are encoded in the `owners`
/// Each validator signs consensus messages with the private key corresponding to the Ed25519
/// public key in `consensus_pubkeys`.
/// Finally, each validator must specify the network address
/// (see types/src/network_address/mod.rs) for itself and its full nodes.
///
/// Network address fields are a vector per account, where each entry is a vector of addresses
/// encoded in a single BCS byte array.
pub fn genesis_create_initialize_validators(
    owners: Vec<AccountAddress>,
    consensus_pubkeys: Vec<Vec<u8>>,
    proof_of_possession: Vec<Vec<u8>>,
    validator_network_addresses: Vec<Vec<u8>>,
    full_node_network_addresses: Vec<Vec<u8>>,
    staking_distribution: Vec<u64>,
    initial_lockup_timestamp: u64,
) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("genesis").to_owned(),
        ),
        ident_str!("create_initialize_validators").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&owners).unwrap(),
            bcs::to_bytes(&consensus_pubkeys).unwrap(),
            bcs::to_bytes(&proof_of_possession).unwrap(),
            bcs::to_bytes(&validator_network_addresses).unwrap(),
            bcs::to_bytes(&full_node_network_addresses).unwrap(),
            bcs::to_bytes(&staking_distribution).unwrap(),
            bcs::to_bytes(&initial_lockup_timestamp).unwrap(),
        ],
    ))
}

/// Withdraw an `amount` of coin `CoinType` from `account` and burn it.
pub fn managed_coin_burn(coin_type: TypeTag, amount: u64) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("managed_coin").to_owned(),
        ),
        ident_str!("burn").to_owned(),
        vec![coin_type],
        vec![bcs::to_bytes(&amount).unwrap()],
    ))
}

/// Initialize new coin `CoinType` in Aptos Blockchain.
/// Mint and Burn Capabilities will be stored under `account` in `Capabilities` resource.
pub fn managed_coin_initialize(
    coin_type: TypeTag,
    name: Vec<u8>,
    symbol: Vec<u8>,
    decimals: u64,
    monitor_supply: bool,
) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("managed_coin").to_owned(),
        ),
        ident_str!("initialize").to_owned(),
        vec![coin_type],
        vec![
            bcs::to_bytes(&name).unwrap(),
            bcs::to_bytes(&symbol).unwrap(),
            bcs::to_bytes(&decimals).unwrap(),
            bcs::to_bytes(&monitor_supply).unwrap(),
        ],
    ))
}

/// Create new coins `CoinType` and deposit them into dst_addr's account.
pub fn managed_coin_mint(
    coin_type: TypeTag,
    dst_addr: AccountAddress,
    amount: u64,
) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("managed_coin").to_owned(),
        ),
        ident_str!("mint").to_owned(),
        vec![coin_type],
        vec![
            bcs::to_bytes(&dst_addr).unwrap(),
            bcs::to_bytes(&amount).unwrap(),
        ],
    ))
}

/// Creating a resource that stores balance of `CoinType` on user's account, withdraw and deposit event handlers.
/// Required if user wants to start accepting deposits of `CoinType` in his account.
pub fn managed_coin_register(coin_type: TypeTag) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("managed_coin").to_owned(),
        ),
        ident_str!("register").to_owned(),
        vec![coin_type],
        vec![],
    ))
}

/// Force an epoch change.
pub fn reconfiguration_force_reconfigure() -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("reconfiguration").to_owned(),
        ),
        ident_str!("force_reconfigure").to_owned(),
        vec![],
        vec![],
    ))
}

/// Creates a new resource account and rotates the authentication key to either
/// the optional auth key if it is non-empty (though auth keys are 32-bytes)
/// or the source accounts current auth key.
pub fn resource_account_create_resource_account(
    seed: Vec<u8>,
    optional_auth_key: Vec<u8>,
) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("resource_account").to_owned(),
        ),
        ident_str!("create_resource_account").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&seed).unwrap(),
            bcs::to_bytes(&optional_auth_key).unwrap(),
        ],
    ))
}

/// Add `amount` of coins from the `account` owning the StakePool.
pub fn stake_add_stake(amount: u64) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("stake").to_owned(),
        ),
        ident_str!("add_stake").to_owned(),
        vec![],
        vec![bcs::to_bytes(&amount).unwrap()],
    ))
}

/// Similar to increase_lockup_with_cap but will use ownership capability from the signing account.
pub fn stake_increase_lockup(new_locked_until_secs: u64) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("stake").to_owned(),
        ),
        ident_str!("increase_lockup").to_owned(),
        vec![],
        vec![bcs::to_bytes(&new_locked_until_secs).unwrap()],
    ))
}

/// This can only called by the operator of the validator/staking pool.
pub fn stake_join_validator_set(pool_address: AccountAddress) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("stake").to_owned(),
        ),
        ident_str!("join_validator_set").to_owned(),
        vec![],
        vec![bcs::to_bytes(&pool_address).unwrap()],
    ))
}

/// Request to have `pool_address` leave the validator set. The validator is only actually removed from the set when
/// the next epoch starts.
/// The last validator in the set cannot leave. This is an edge case that should never happen as long as the network
/// is still operational.
///
/// Can only be called by the operator of the validator/staking pool.
pub fn stake_leave_validator_set(pool_address: AccountAddress) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("stake").to_owned(),
        ),
        ident_str!("leave_validator_set").to_owned(),
        vec![],
        vec![bcs::to_bytes(&pool_address).unwrap()],
    ))
}

/// Initialize the validator account and give ownership to the signing account.
pub fn stake_register_validator_candidate(
    consensus_pubkey: Vec<u8>,
    proof_of_possession: Vec<u8>,
    network_addresses: Vec<u8>,
    fullnode_addresses: Vec<u8>,
) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("stake").to_owned(),
        ),
        ident_str!("register_validator_candidate").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&consensus_pubkey).unwrap(),
            bcs::to_bytes(&proof_of_possession).unwrap(),
            bcs::to_bytes(&network_addresses).unwrap(),
            bcs::to_bytes(&fullnode_addresses).unwrap(),
        ],
    ))
}

/// Rotate the consensus key of the validator, it'll take effect in next epoch.
pub fn stake_rotate_consensus_key(
    pool_address: AccountAddress,
    new_consensus_pubkey: Vec<u8>,
    proof_of_possession: Vec<u8>,
) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("stake").to_owned(),
        ),
        ident_str!("rotate_consensus_key").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&pool_address).unwrap(),
            bcs::to_bytes(&new_consensus_pubkey).unwrap(),
            bcs::to_bytes(&proof_of_possession).unwrap(),
        ],
    ))
}

/// Allows an owner to change the delegated voter of the stake pool.
pub fn stake_set_delegated_voter(new_delegated_voter: AccountAddress) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("stake").to_owned(),
        ),
        ident_str!("set_delegated_voter").to_owned(),
        vec![],
        vec![bcs::to_bytes(&new_delegated_voter).unwrap()],
    ))
}

/// Allows an owner to change the operator of the stake pool.
pub fn stake_set_operator(new_operator: AccountAddress) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("stake").to_owned(),
        ),
        ident_str!("set_operator").to_owned(),
        vec![],
        vec![bcs::to_bytes(&new_operator).unwrap()],
    ))
}

/// Similar to unlock_with_cap but will use ownership capability from the signing account.
pub fn stake_unlock(amount: u64) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("stake").to_owned(),
        ),
        ident_str!("unlock").to_owned(),
        vec![],
        vec![bcs::to_bytes(&amount).unwrap()],
    ))
}

/// Update the network and full node addresses of the validator. This only takes effect in the next epoch.
pub fn stake_update_network_and_fullnode_addresses(
    pool_address: AccountAddress,
    new_network_addresses: Vec<u8>,
    new_fullnode_addresses: Vec<u8>,
) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("stake").to_owned(),
        ),
        ident_str!("update_network_and_fullnode_addresses").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&pool_address).unwrap(),
            bcs::to_bytes(&new_network_addresses).unwrap(),
            bcs::to_bytes(&new_fullnode_addresses).unwrap(),
        ],
    ))
}

/// Withdraw from `account`'s inactive stake.
pub fn stake_withdraw(withdraw_amount: u64) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("stake").to_owned(),
        ),
        ident_str!("withdraw").to_owned(),
        vec![],
        vec![bcs::to_bytes(&withdraw_amount).unwrap()],
    ))
}

pub fn token_create_limited_collection_script(
    name: Vec<u8>,
    description: Vec<u8>,
    uri: Vec<u8>,
    maximum: u64,
) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("token").to_owned(),
        ),
        ident_str!("create_limited_collection_script").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&name).unwrap(),
            bcs::to_bytes(&description).unwrap(),
            bcs::to_bytes(&uri).unwrap(),
            bcs::to_bytes(&maximum).unwrap(),
        ],
    ))
}

pub fn token_create_limited_token_script(
    collection: Vec<u8>,
    name: Vec<u8>,
    description: Vec<u8>,
    monitor_supply: bool,
    initial_balance: u64,
    maximum: u64,
    uri: Vec<u8>,
    royalty_points_per_million: u64,
) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("token").to_owned(),
        ),
        ident_str!("create_limited_token_script").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&collection).unwrap(),
            bcs::to_bytes(&name).unwrap(),
            bcs::to_bytes(&description).unwrap(),
            bcs::to_bytes(&monitor_supply).unwrap(),
            bcs::to_bytes(&initial_balance).unwrap(),
            bcs::to_bytes(&maximum).unwrap(),
            bcs::to_bytes(&uri).unwrap(),
            bcs::to_bytes(&royalty_points_per_million).unwrap(),
        ],
    ))
}

pub fn token_create_unlimited_collection_script(
    name: Vec<u8>,
    description: Vec<u8>,
    uri: Vec<u8>,
) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("token").to_owned(),
        ),
        ident_str!("create_unlimited_collection_script").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&name).unwrap(),
            bcs::to_bytes(&description).unwrap(),
            bcs::to_bytes(&uri).unwrap(),
        ],
    ))
}

pub fn token_create_unlimited_token_script(
    collection: Vec<u8>,
    name: Vec<u8>,
    description: Vec<u8>,
    monitor_supply: bool,
    initial_balance: u64,
    uri: Vec<u8>,
    royalty_points_per_million: u64,
) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("token").to_owned(),
        ),
        ident_str!("create_unlimited_token_script").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&collection).unwrap(),
            bcs::to_bytes(&name).unwrap(),
            bcs::to_bytes(&description).unwrap(),
            bcs::to_bytes(&monitor_supply).unwrap(),
            bcs::to_bytes(&initial_balance).unwrap(),
            bcs::to_bytes(&uri).unwrap(),
            bcs::to_bytes(&royalty_points_per_million).unwrap(),
        ],
    ))
}

pub fn token_direct_transfer_script(
    creators_address: AccountAddress,
    collection: Vec<u8>,
    name: Vec<u8>,
    amount: u64,
) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("token").to_owned(),
        ),
        ident_str!("direct_transfer_script").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&creators_address).unwrap(),
            bcs::to_bytes(&collection).unwrap(),
            bcs::to_bytes(&name).unwrap(),
            bcs::to_bytes(&amount).unwrap(),
        ],
    ))
}

pub fn token_initialize_token_for_id(
    creators_address: AccountAddress,
    collection: Vec<u8>,
    name: Vec<u8>,
) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("token").to_owned(),
        ),
        ident_str!("initialize_token_for_id").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&creators_address).unwrap(),
            bcs::to_bytes(&collection).unwrap(),
            bcs::to_bytes(&name).unwrap(),
        ],
    ))
}

pub fn token_initialize_token_script() -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("token").to_owned(),
        ),
        ident_str!("initialize_token_script").to_owned(),
        vec![],
        vec![],
    ))
}

pub fn token_transfers_cancel_offer_script(
    receiver: AccountAddress,
    creator: AccountAddress,
    collection: Vec<u8>,
    name: Vec<u8>,
) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("token_transfers").to_owned(),
        ),
        ident_str!("cancel_offer_script").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&receiver).unwrap(),
            bcs::to_bytes(&creator).unwrap(),
            bcs::to_bytes(&collection).unwrap(),
            bcs::to_bytes(&name).unwrap(),
        ],
    ))
}

pub fn token_transfers_claim_script(
    sender: AccountAddress,
    creator: AccountAddress,
    collection: Vec<u8>,
    name: Vec<u8>,
) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("token_transfers").to_owned(),
        ),
        ident_str!("claim_script").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&sender).unwrap(),
            bcs::to_bytes(&creator).unwrap(),
            bcs::to_bytes(&collection).unwrap(),
            bcs::to_bytes(&name).unwrap(),
        ],
    ))
}

pub fn token_transfers_offer_script(
    receiver: AccountAddress,
    creator: AccountAddress,
    collection: Vec<u8>,
    name: Vec<u8>,
    amount: u64,
) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("token_transfers").to_owned(),
        ),
        ident_str!("offer_script").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&receiver).unwrap(),
            bcs::to_bytes(&creator).unwrap(),
            bcs::to_bytes(&collection).unwrap(),
            bcs::to_bytes(&name).unwrap(),
            bcs::to_bytes(&amount).unwrap(),
        ],
    ))
}

pub fn transaction_publishing_option_set_module_publishing_allowed(
    is_allowed: bool,
) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("transaction_publishing_option").to_owned(),
        ),
        ident_str!("set_module_publishing_allowed").to_owned(),
        vec![],
        vec![bcs::to_bytes(&is_allowed).unwrap()],
    ))
}

pub fn validator_set_script_add_validator(_validator_addr: AccountAddress) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("validator_set_script").to_owned(),
        ),
        ident_str!("add_validator").to_owned(),
        vec![],
        vec![bcs::to_bytes(&_validator_addr).unwrap()],
    ))
}

pub fn validator_set_script_create_validator_account(
    _new_account_address: AccountAddress,
    _human_name: Vec<u8>,
) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("validator_set_script").to_owned(),
        ),
        ident_str!("create_validator_account").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&_new_account_address).unwrap(),
            bcs::to_bytes(&_human_name).unwrap(),
        ],
    ))
}

pub fn validator_set_script_create_validator_operator_account(
    _new_account_address: AccountAddress,
    _human_name: Vec<u8>,
) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("validator_set_script").to_owned(),
        ),
        ident_str!("create_validator_operator_account").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&_new_account_address).unwrap(),
            bcs::to_bytes(&_human_name).unwrap(),
        ],
    ))
}

pub fn validator_set_script_register_validator_config(
    _validator_address: AccountAddress,
    _consensus_pubkey: Vec<u8>,
    _validator_network_addresses: Vec<u8>,
    _fullnode_network_addresses: Vec<u8>,
) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("validator_set_script").to_owned(),
        ),
        ident_str!("register_validator_config").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&_validator_address).unwrap(),
            bcs::to_bytes(&_consensus_pubkey).unwrap(),
            bcs::to_bytes(&_validator_network_addresses).unwrap(),
            bcs::to_bytes(&_fullnode_network_addresses).unwrap(),
        ],
    ))
}

pub fn validator_set_script_remove_validator(
    _validator_addr: AccountAddress,
) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("validator_set_script").to_owned(),
        ),
        ident_str!("remove_validator").to_owned(),
        vec![],
        vec![bcs::to_bytes(&_validator_addr).unwrap()],
    ))
}

pub fn validator_set_script_set_validator_config_and_reconfigure(
    _validator_account: AccountAddress,
    _consensus_pubkey: Vec<u8>,
    _validator_network_addresses: Vec<u8>,
    _fullnode_network_addresses: Vec<u8>,
) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("validator_set_script").to_owned(),
        ),
        ident_str!("set_validator_config_and_reconfigure").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&_validator_account).unwrap(),
            bcs::to_bytes(&_consensus_pubkey).unwrap(),
            bcs::to_bytes(&_validator_network_addresses).unwrap(),
            bcs::to_bytes(&_fullnode_network_addresses).unwrap(),
        ],
    ))
}

pub fn validator_set_script_set_validator_operator(
    _operator_name: Vec<u8>,
    _operator_account: AccountAddress,
) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("validator_set_script").to_owned(),
        ),
        ident_str!("set_validator_operator").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&_operator_name).unwrap(),
            bcs::to_bytes(&_operator_account).unwrap(),
        ],
    ))
}

/// Updates the major version to a larger version.
/// This is only used in test environments and outside of them, the core resources account shouldn't exist.
pub fn version_set_version(major: u64) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("version").to_owned(),
        ),
        ident_str!("set_version").to_owned(),
        vec![],
        vec![bcs::to_bytes(&major).unwrap()],
    ))
}

pub fn vm_config_set_gas_constants(
    global_memory_per_byte_cost: u64,
    global_memory_per_byte_write_cost: u64,
    min_transaction_gas_units: u64,
    large_transaction_cutoff: u64,
    intrinsic_gas_per_byte: u64,
    maximum_number_of_gas_units: u64,
    min_price_per_gas_unit: u64,
    max_price_per_gas_unit: u64,
    max_transaction_size_in_bytes: u64,
    gas_unit_scaling_factor: u64,
    default_account_size: u64,
) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("vm_config").to_owned(),
        ),
        ident_str!("set_gas_constants").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&global_memory_per_byte_cost).unwrap(),
            bcs::to_bytes(&global_memory_per_byte_write_cost).unwrap(),
            bcs::to_bytes(&min_transaction_gas_units).unwrap(),
            bcs::to_bytes(&large_transaction_cutoff).unwrap(),
            bcs::to_bytes(&intrinsic_gas_per_byte).unwrap(),
            bcs::to_bytes(&maximum_number_of_gas_units).unwrap(),
            bcs::to_bytes(&min_price_per_gas_unit).unwrap(),
            bcs::to_bytes(&max_price_per_gas_unit).unwrap(),
            bcs::to_bytes(&max_transaction_size_in_bytes).unwrap(),
            bcs::to_bytes(&gas_unit_scaling_factor).unwrap(),
            bcs::to_bytes(&default_account_size).unwrap(),
        ],
    ))
}
mod decoder {
    use super::*;
    pub fn account_create_account(payload: &TransactionPayload) -> Option<ScriptFunctionCall> {
        if let TransactionPayload::ScriptFunction(script) = payload {
            Some(ScriptFunctionCall::AccountCreateAccount {
                auth_key: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn account_rotate_authentication_key(
        payload: &TransactionPayload,
    ) -> Option<ScriptFunctionCall> {
        if let TransactionPayload::ScriptFunction(script) = payload {
            Some(ScriptFunctionCall::AccountRotateAuthenticationKey {
                new_auth_key: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn account_transfer(payload: &TransactionPayload) -> Option<ScriptFunctionCall> {
        if let TransactionPayload::ScriptFunction(script) = payload {
            Some(ScriptFunctionCall::AccountTransfer {
                to: bcs::from_bytes(script.args().get(0)?).ok()?,
                amount: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn aptos_coin_claim_mint_capability(
        payload: &TransactionPayload,
    ) -> Option<ScriptFunctionCall> {
        if let TransactionPayload::ScriptFunction(_script) = payload {
            Some(ScriptFunctionCall::AptosCoinClaimMintCapability {})
        } else {
            None
        }
    }

    pub fn aptos_coin_delegate_mint_capability(
        payload: &TransactionPayload,
    ) -> Option<ScriptFunctionCall> {
        if let TransactionPayload::ScriptFunction(script) = payload {
            Some(ScriptFunctionCall::AptosCoinDelegateMintCapability {
                to: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn aptos_coin_mint(payload: &TransactionPayload) -> Option<ScriptFunctionCall> {
        if let TransactionPayload::ScriptFunction(script) = payload {
            Some(ScriptFunctionCall::AptosCoinMint {
                dst_addr: bcs::from_bytes(script.args().get(0)?).ok()?,
                amount: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn aptos_governance_create_proposal(
        payload: &TransactionPayload,
    ) -> Option<ScriptFunctionCall> {
        if let TransactionPayload::ScriptFunction(script) = payload {
            Some(ScriptFunctionCall::AptosGovernanceCreateProposal {
                stake_pool: bcs::from_bytes(script.args().get(0)?).ok()?,
                execution_hash: bcs::from_bytes(script.args().get(1)?).ok()?,
                metadata_location: bcs::from_bytes(script.args().get(2)?).ok()?,
                metadata_hash: bcs::from_bytes(script.args().get(3)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn aptos_governance_vote(payload: &TransactionPayload) -> Option<ScriptFunctionCall> {
        if let TransactionPayload::ScriptFunction(script) = payload {
            Some(ScriptFunctionCall::AptosGovernanceVote {
                stake_pool: bcs::from_bytes(script.args().get(0)?).ok()?,
                proposal_id: bcs::from_bytes(script.args().get(1)?).ok()?,
                should_pass: bcs::from_bytes(script.args().get(2)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn code_publish_package_txn(payload: &TransactionPayload) -> Option<ScriptFunctionCall> {
        if let TransactionPayload::ScriptFunction(script) = payload {
            Some(ScriptFunctionCall::CodePublishPackageTxn {
                pack_serialized: bcs::from_bytes(script.args().get(0)?).ok()?,
                code: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn coin_transfer(payload: &TransactionPayload) -> Option<ScriptFunctionCall> {
        if let TransactionPayload::ScriptFunction(script) = payload {
            Some(ScriptFunctionCall::CoinTransfer {
                coin_type: script.ty_args().get(0)?.clone(),
                to: bcs::from_bytes(script.args().get(0)?).ok()?,
                amount: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn coins_register(payload: &TransactionPayload) -> Option<ScriptFunctionCall> {
        if let TransactionPayload::ScriptFunction(script) = payload {
            Some(ScriptFunctionCall::CoinsRegister {
                coin_type: script.ty_args().get(0)?.clone(),
            })
        } else {
            None
        }
    }

    pub fn genesis_create_initialize_validators(
        payload: &TransactionPayload,
    ) -> Option<ScriptFunctionCall> {
        if let TransactionPayload::ScriptFunction(script) = payload {
            Some(ScriptFunctionCall::GenesisCreateInitializeValidators {
                owners: bcs::from_bytes(script.args().get(0)?).ok()?,
                consensus_pubkeys: bcs::from_bytes(script.args().get(1)?).ok()?,
                proof_of_possession: bcs::from_bytes(script.args().get(2)?).ok()?,
                validator_network_addresses: bcs::from_bytes(script.args().get(3)?).ok()?,
                full_node_network_addresses: bcs::from_bytes(script.args().get(4)?).ok()?,
                staking_distribution: bcs::from_bytes(script.args().get(5)?).ok()?,
                initial_lockup_timestamp: bcs::from_bytes(script.args().get(6)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn managed_coin_burn(payload: &TransactionPayload) -> Option<ScriptFunctionCall> {
        if let TransactionPayload::ScriptFunction(script) = payload {
            Some(ScriptFunctionCall::ManagedCoinBurn {
                coin_type: script.ty_args().get(0)?.clone(),
                amount: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn managed_coin_initialize(payload: &TransactionPayload) -> Option<ScriptFunctionCall> {
        if let TransactionPayload::ScriptFunction(script) = payload {
            Some(ScriptFunctionCall::ManagedCoinInitialize {
                coin_type: script.ty_args().get(0)?.clone(),
                name: bcs::from_bytes(script.args().get(0)?).ok()?,
                symbol: bcs::from_bytes(script.args().get(1)?).ok()?,
                decimals: bcs::from_bytes(script.args().get(2)?).ok()?,
                monitor_supply: bcs::from_bytes(script.args().get(3)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn managed_coin_mint(payload: &TransactionPayload) -> Option<ScriptFunctionCall> {
        if let TransactionPayload::ScriptFunction(script) = payload {
            Some(ScriptFunctionCall::ManagedCoinMint {
                coin_type: script.ty_args().get(0)?.clone(),
                dst_addr: bcs::from_bytes(script.args().get(0)?).ok()?,
                amount: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn managed_coin_register(payload: &TransactionPayload) -> Option<ScriptFunctionCall> {
        if let TransactionPayload::ScriptFunction(script) = payload {
            Some(ScriptFunctionCall::ManagedCoinRegister {
                coin_type: script.ty_args().get(0)?.clone(),
            })
        } else {
            None
        }
    }

    pub fn reconfiguration_force_reconfigure(
        payload: &TransactionPayload,
    ) -> Option<ScriptFunctionCall> {
        if let TransactionPayload::ScriptFunction(_script) = payload {
            Some(ScriptFunctionCall::ReconfigurationForceReconfigure {})
        } else {
            None
        }
    }

    pub fn resource_account_create_resource_account(
        payload: &TransactionPayload,
    ) -> Option<ScriptFunctionCall> {
        if let TransactionPayload::ScriptFunction(script) = payload {
            Some(ScriptFunctionCall::ResourceAccountCreateResourceAccount {
                seed: bcs::from_bytes(script.args().get(0)?).ok()?,
                optional_auth_key: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn stake_add_stake(payload: &TransactionPayload) -> Option<ScriptFunctionCall> {
        if let TransactionPayload::ScriptFunction(script) = payload {
            Some(ScriptFunctionCall::StakeAddStake {
                amount: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn stake_increase_lockup(payload: &TransactionPayload) -> Option<ScriptFunctionCall> {
        if let TransactionPayload::ScriptFunction(script) = payload {
            Some(ScriptFunctionCall::StakeIncreaseLockup {
                new_locked_until_secs: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn stake_join_validator_set(payload: &TransactionPayload) -> Option<ScriptFunctionCall> {
        if let TransactionPayload::ScriptFunction(script) = payload {
            Some(ScriptFunctionCall::StakeJoinValidatorSet {
                pool_address: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn stake_leave_validator_set(payload: &TransactionPayload) -> Option<ScriptFunctionCall> {
        if let TransactionPayload::ScriptFunction(script) = payload {
            Some(ScriptFunctionCall::StakeLeaveValidatorSet {
                pool_address: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn stake_register_validator_candidate(
        payload: &TransactionPayload,
    ) -> Option<ScriptFunctionCall> {
        if let TransactionPayload::ScriptFunction(script) = payload {
            Some(ScriptFunctionCall::StakeRegisterValidatorCandidate {
                consensus_pubkey: bcs::from_bytes(script.args().get(0)?).ok()?,
                proof_of_possession: bcs::from_bytes(script.args().get(1)?).ok()?,
                network_addresses: bcs::from_bytes(script.args().get(2)?).ok()?,
                fullnode_addresses: bcs::from_bytes(script.args().get(3)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn stake_rotate_consensus_key(payload: &TransactionPayload) -> Option<ScriptFunctionCall> {
        if let TransactionPayload::ScriptFunction(script) = payload {
            Some(ScriptFunctionCall::StakeRotateConsensusKey {
                pool_address: bcs::from_bytes(script.args().get(0)?).ok()?,
                new_consensus_pubkey: bcs::from_bytes(script.args().get(1)?).ok()?,
                proof_of_possession: bcs::from_bytes(script.args().get(2)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn stake_set_delegated_voter(payload: &TransactionPayload) -> Option<ScriptFunctionCall> {
        if let TransactionPayload::ScriptFunction(script) = payload {
            Some(ScriptFunctionCall::StakeSetDelegatedVoter {
                new_delegated_voter: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn stake_set_operator(payload: &TransactionPayload) -> Option<ScriptFunctionCall> {
        if let TransactionPayload::ScriptFunction(script) = payload {
            Some(ScriptFunctionCall::StakeSetOperator {
                new_operator: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn stake_unlock(payload: &TransactionPayload) -> Option<ScriptFunctionCall> {
        if let TransactionPayload::ScriptFunction(script) = payload {
            Some(ScriptFunctionCall::StakeUnlock {
                amount: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn stake_update_network_and_fullnode_addresses(
        payload: &TransactionPayload,
    ) -> Option<ScriptFunctionCall> {
        if let TransactionPayload::ScriptFunction(script) = payload {
            Some(ScriptFunctionCall::StakeUpdateNetworkAndFullnodeAddresses {
                pool_address: bcs::from_bytes(script.args().get(0)?).ok()?,
                new_network_addresses: bcs::from_bytes(script.args().get(1)?).ok()?,
                new_fullnode_addresses: bcs::from_bytes(script.args().get(2)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn stake_withdraw(payload: &TransactionPayload) -> Option<ScriptFunctionCall> {
        if let TransactionPayload::ScriptFunction(script) = payload {
            Some(ScriptFunctionCall::StakeWithdraw {
                withdraw_amount: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn token_create_limited_collection_script(
        payload: &TransactionPayload,
    ) -> Option<ScriptFunctionCall> {
        if let TransactionPayload::ScriptFunction(script) = payload {
            Some(ScriptFunctionCall::TokenCreateLimitedCollectionScript {
                name: bcs::from_bytes(script.args().get(0)?).ok()?,
                description: bcs::from_bytes(script.args().get(1)?).ok()?,
                uri: bcs::from_bytes(script.args().get(2)?).ok()?,
                maximum: bcs::from_bytes(script.args().get(3)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn token_create_limited_token_script(
        payload: &TransactionPayload,
    ) -> Option<ScriptFunctionCall> {
        if let TransactionPayload::ScriptFunction(script) = payload {
            Some(ScriptFunctionCall::TokenCreateLimitedTokenScript {
                collection: bcs::from_bytes(script.args().get(0)?).ok()?,
                name: bcs::from_bytes(script.args().get(1)?).ok()?,
                description: bcs::from_bytes(script.args().get(2)?).ok()?,
                monitor_supply: bcs::from_bytes(script.args().get(3)?).ok()?,
                initial_balance: bcs::from_bytes(script.args().get(4)?).ok()?,
                maximum: bcs::from_bytes(script.args().get(5)?).ok()?,
                uri: bcs::from_bytes(script.args().get(6)?).ok()?,
                royalty_points_per_million: bcs::from_bytes(script.args().get(7)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn token_create_unlimited_collection_script(
        payload: &TransactionPayload,
    ) -> Option<ScriptFunctionCall> {
        if let TransactionPayload::ScriptFunction(script) = payload {
            Some(ScriptFunctionCall::TokenCreateUnlimitedCollectionScript {
                name: bcs::from_bytes(script.args().get(0)?).ok()?,
                description: bcs::from_bytes(script.args().get(1)?).ok()?,
                uri: bcs::from_bytes(script.args().get(2)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn token_create_unlimited_token_script(
        payload: &TransactionPayload,
    ) -> Option<ScriptFunctionCall> {
        if let TransactionPayload::ScriptFunction(script) = payload {
            Some(ScriptFunctionCall::TokenCreateUnlimitedTokenScript {
                collection: bcs::from_bytes(script.args().get(0)?).ok()?,
                name: bcs::from_bytes(script.args().get(1)?).ok()?,
                description: bcs::from_bytes(script.args().get(2)?).ok()?,
                monitor_supply: bcs::from_bytes(script.args().get(3)?).ok()?,
                initial_balance: bcs::from_bytes(script.args().get(4)?).ok()?,
                uri: bcs::from_bytes(script.args().get(5)?).ok()?,
                royalty_points_per_million: bcs::from_bytes(script.args().get(6)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn token_direct_transfer_script(
        payload: &TransactionPayload,
    ) -> Option<ScriptFunctionCall> {
        if let TransactionPayload::ScriptFunction(script) = payload {
            Some(ScriptFunctionCall::TokenDirectTransferScript {
                creators_address: bcs::from_bytes(script.args().get(0)?).ok()?,
                collection: bcs::from_bytes(script.args().get(1)?).ok()?,
                name: bcs::from_bytes(script.args().get(2)?).ok()?,
                amount: bcs::from_bytes(script.args().get(3)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn token_initialize_token_for_id(
        payload: &TransactionPayload,
    ) -> Option<ScriptFunctionCall> {
        if let TransactionPayload::ScriptFunction(script) = payload {
            Some(ScriptFunctionCall::TokenInitializeTokenForId {
                creators_address: bcs::from_bytes(script.args().get(0)?).ok()?,
                collection: bcs::from_bytes(script.args().get(1)?).ok()?,
                name: bcs::from_bytes(script.args().get(2)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn token_initialize_token_script(
        payload: &TransactionPayload,
    ) -> Option<ScriptFunctionCall> {
        if let TransactionPayload::ScriptFunction(_script) = payload {
            Some(ScriptFunctionCall::TokenInitializeTokenScript {})
        } else {
            None
        }
    }

    pub fn token_transfers_cancel_offer_script(
        payload: &TransactionPayload,
    ) -> Option<ScriptFunctionCall> {
        if let TransactionPayload::ScriptFunction(script) = payload {
            Some(ScriptFunctionCall::TokenTransfersCancelOfferScript {
                receiver: bcs::from_bytes(script.args().get(0)?).ok()?,
                creator: bcs::from_bytes(script.args().get(1)?).ok()?,
                collection: bcs::from_bytes(script.args().get(2)?).ok()?,
                name: bcs::from_bytes(script.args().get(3)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn token_transfers_claim_script(
        payload: &TransactionPayload,
    ) -> Option<ScriptFunctionCall> {
        if let TransactionPayload::ScriptFunction(script) = payload {
            Some(ScriptFunctionCall::TokenTransfersClaimScript {
                sender: bcs::from_bytes(script.args().get(0)?).ok()?,
                creator: bcs::from_bytes(script.args().get(1)?).ok()?,
                collection: bcs::from_bytes(script.args().get(2)?).ok()?,
                name: bcs::from_bytes(script.args().get(3)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn token_transfers_offer_script(
        payload: &TransactionPayload,
    ) -> Option<ScriptFunctionCall> {
        if let TransactionPayload::ScriptFunction(script) = payload {
            Some(ScriptFunctionCall::TokenTransfersOfferScript {
                receiver: bcs::from_bytes(script.args().get(0)?).ok()?,
                creator: bcs::from_bytes(script.args().get(1)?).ok()?,
                collection: bcs::from_bytes(script.args().get(2)?).ok()?,
                name: bcs::from_bytes(script.args().get(3)?).ok()?,
                amount: bcs::from_bytes(script.args().get(4)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn transaction_publishing_option_set_module_publishing_allowed(
        payload: &TransactionPayload,
    ) -> Option<ScriptFunctionCall> {
        if let TransactionPayload::ScriptFunction(script) = payload {
            Some(
                ScriptFunctionCall::TransactionPublishingOptionSetModulePublishingAllowed {
                    is_allowed: bcs::from_bytes(script.args().get(0)?).ok()?,
                },
            )
        } else {
            None
        }
    }

    pub fn validator_set_script_add_validator(
        payload: &TransactionPayload,
    ) -> Option<ScriptFunctionCall> {
        if let TransactionPayload::ScriptFunction(script) = payload {
            Some(ScriptFunctionCall::ValidatorSetScriptAddValidator {
                _validator_addr: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn validator_set_script_create_validator_account(
        payload: &TransactionPayload,
    ) -> Option<ScriptFunctionCall> {
        if let TransactionPayload::ScriptFunction(script) = payload {
            Some(
                ScriptFunctionCall::ValidatorSetScriptCreateValidatorAccount {
                    _new_account_address: bcs::from_bytes(script.args().get(0)?).ok()?,
                    _human_name: bcs::from_bytes(script.args().get(1)?).ok()?,
                },
            )
        } else {
            None
        }
    }

    pub fn validator_set_script_create_validator_operator_account(
        payload: &TransactionPayload,
    ) -> Option<ScriptFunctionCall> {
        if let TransactionPayload::ScriptFunction(script) = payload {
            Some(
                ScriptFunctionCall::ValidatorSetScriptCreateValidatorOperatorAccount {
                    _new_account_address: bcs::from_bytes(script.args().get(0)?).ok()?,
                    _human_name: bcs::from_bytes(script.args().get(1)?).ok()?,
                },
            )
        } else {
            None
        }
    }

    pub fn validator_set_script_register_validator_config(
        payload: &TransactionPayload,
    ) -> Option<ScriptFunctionCall> {
        if let TransactionPayload::ScriptFunction(script) = payload {
            Some(
                ScriptFunctionCall::ValidatorSetScriptRegisterValidatorConfig {
                    _validator_address: bcs::from_bytes(script.args().get(0)?).ok()?,
                    _consensus_pubkey: bcs::from_bytes(script.args().get(1)?).ok()?,
                    _validator_network_addresses: bcs::from_bytes(script.args().get(2)?).ok()?,
                    _fullnode_network_addresses: bcs::from_bytes(script.args().get(3)?).ok()?,
                },
            )
        } else {
            None
        }
    }

    pub fn validator_set_script_remove_validator(
        payload: &TransactionPayload,
    ) -> Option<ScriptFunctionCall> {
        if let TransactionPayload::ScriptFunction(script) = payload {
            Some(ScriptFunctionCall::ValidatorSetScriptRemoveValidator {
                _validator_addr: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn validator_set_script_set_validator_config_and_reconfigure(
        payload: &TransactionPayload,
    ) -> Option<ScriptFunctionCall> {
        if let TransactionPayload::ScriptFunction(script) = payload {
            Some(
                ScriptFunctionCall::ValidatorSetScriptSetValidatorConfigAndReconfigure {
                    _validator_account: bcs::from_bytes(script.args().get(0)?).ok()?,
                    _consensus_pubkey: bcs::from_bytes(script.args().get(1)?).ok()?,
                    _validator_network_addresses: bcs::from_bytes(script.args().get(2)?).ok()?,
                    _fullnode_network_addresses: bcs::from_bytes(script.args().get(3)?).ok()?,
                },
            )
        } else {
            None
        }
    }

    pub fn validator_set_script_set_validator_operator(
        payload: &TransactionPayload,
    ) -> Option<ScriptFunctionCall> {
        if let TransactionPayload::ScriptFunction(script) = payload {
            Some(ScriptFunctionCall::ValidatorSetScriptSetValidatorOperator {
                _operator_name: bcs::from_bytes(script.args().get(0)?).ok()?,
                _operator_account: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn version_set_version(payload: &TransactionPayload) -> Option<ScriptFunctionCall> {
        if let TransactionPayload::ScriptFunction(script) = payload {
            Some(ScriptFunctionCall::VersionSetVersion {
                major: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn vm_config_set_gas_constants(payload: &TransactionPayload) -> Option<ScriptFunctionCall> {
        if let TransactionPayload::ScriptFunction(script) = payload {
            Some(ScriptFunctionCall::VmConfigSetGasConstants {
                global_memory_per_byte_cost: bcs::from_bytes(script.args().get(0)?).ok()?,
                global_memory_per_byte_write_cost: bcs::from_bytes(script.args().get(1)?).ok()?,
                min_transaction_gas_units: bcs::from_bytes(script.args().get(2)?).ok()?,
                large_transaction_cutoff: bcs::from_bytes(script.args().get(3)?).ok()?,
                intrinsic_gas_per_byte: bcs::from_bytes(script.args().get(4)?).ok()?,
                maximum_number_of_gas_units: bcs::from_bytes(script.args().get(5)?).ok()?,
                min_price_per_gas_unit: bcs::from_bytes(script.args().get(6)?).ok()?,
                max_price_per_gas_unit: bcs::from_bytes(script.args().get(7)?).ok()?,
                max_transaction_size_in_bytes: bcs::from_bytes(script.args().get(8)?).ok()?,
                gas_unit_scaling_factor: bcs::from_bytes(script.args().get(9)?).ok()?,
                default_account_size: bcs::from_bytes(script.args().get(10)?).ok()?,
            })
        } else {
            None
        }
    }
}

type ScriptFunctionDecoderMap = std::collections::HashMap<
    String,
    Box<
        dyn Fn(&TransactionPayload) -> Option<ScriptFunctionCall>
            + std::marker::Sync
            + std::marker::Send,
    >,
>;

static SCRIPT_FUNCTION_DECODER_MAP: once_cell::sync::Lazy<ScriptFunctionDecoderMap> =
    once_cell::sync::Lazy::new(|| {
        let mut map: ScriptFunctionDecoderMap = std::collections::HashMap::new();
        map.insert(
            "account_create_account".to_string(),
            Box::new(decoder::account_create_account),
        );
        map.insert(
            "account_rotate_authentication_key".to_string(),
            Box::new(decoder::account_rotate_authentication_key),
        );
        map.insert(
            "account_transfer".to_string(),
            Box::new(decoder::account_transfer),
        );
        map.insert(
            "aptos_coin_claim_mint_capability".to_string(),
            Box::new(decoder::aptos_coin_claim_mint_capability),
        );
        map.insert(
            "aptos_coin_delegate_mint_capability".to_string(),
            Box::new(decoder::aptos_coin_delegate_mint_capability),
        );
        map.insert(
            "aptos_coin_mint".to_string(),
            Box::new(decoder::aptos_coin_mint),
        );
        map.insert(
            "aptos_governance_create_proposal".to_string(),
            Box::new(decoder::aptos_governance_create_proposal),
        );
        map.insert(
            "aptos_governance_vote".to_string(),
            Box::new(decoder::aptos_governance_vote),
        );
        map.insert(
            "code_publish_package_txn".to_string(),
            Box::new(decoder::code_publish_package_txn),
        );
        map.insert(
            "coin_transfer".to_string(),
            Box::new(decoder::coin_transfer),
        );
        map.insert(
            "coins_register".to_string(),
            Box::new(decoder::coins_register),
        );
        map.insert(
            "genesis_create_initialize_validators".to_string(),
            Box::new(decoder::genesis_create_initialize_validators),
        );
        map.insert(
            "managed_coin_burn".to_string(),
            Box::new(decoder::managed_coin_burn),
        );
        map.insert(
            "managed_coin_initialize".to_string(),
            Box::new(decoder::managed_coin_initialize),
        );
        map.insert(
            "managed_coin_mint".to_string(),
            Box::new(decoder::managed_coin_mint),
        );
        map.insert(
            "managed_coin_register".to_string(),
            Box::new(decoder::managed_coin_register),
        );
        map.insert(
            "reconfiguration_force_reconfigure".to_string(),
            Box::new(decoder::reconfiguration_force_reconfigure),
        );
        map.insert(
            "resource_account_create_resource_account".to_string(),
            Box::new(decoder::resource_account_create_resource_account),
        );
        map.insert(
            "stake_add_stake".to_string(),
            Box::new(decoder::stake_add_stake),
        );
        map.insert(
            "stake_increase_lockup".to_string(),
            Box::new(decoder::stake_increase_lockup),
        );
        map.insert(
            "stake_join_validator_set".to_string(),
            Box::new(decoder::stake_join_validator_set),
        );
        map.insert(
            "stake_leave_validator_set".to_string(),
            Box::new(decoder::stake_leave_validator_set),
        );
        map.insert(
            "stake_register_validator_candidate".to_string(),
            Box::new(decoder::stake_register_validator_candidate),
        );
        map.insert(
            "stake_rotate_consensus_key".to_string(),
            Box::new(decoder::stake_rotate_consensus_key),
        );
        map.insert(
            "stake_set_delegated_voter".to_string(),
            Box::new(decoder::stake_set_delegated_voter),
        );
        map.insert(
            "stake_set_operator".to_string(),
            Box::new(decoder::stake_set_operator),
        );
        map.insert("stake_unlock".to_string(), Box::new(decoder::stake_unlock));
        map.insert(
            "stake_update_network_and_fullnode_addresses".to_string(),
            Box::new(decoder::stake_update_network_and_fullnode_addresses),
        );
        map.insert(
            "stake_withdraw".to_string(),
            Box::new(decoder::stake_withdraw),
        );
        map.insert(
            "token_create_limited_collection_script".to_string(),
            Box::new(decoder::token_create_limited_collection_script),
        );
        map.insert(
            "token_create_limited_token_script".to_string(),
            Box::new(decoder::token_create_limited_token_script),
        );
        map.insert(
            "token_create_unlimited_collection_script".to_string(),
            Box::new(decoder::token_create_unlimited_collection_script),
        );
        map.insert(
            "token_create_unlimited_token_script".to_string(),
            Box::new(decoder::token_create_unlimited_token_script),
        );
        map.insert(
            "token_direct_transfer_script".to_string(),
            Box::new(decoder::token_direct_transfer_script),
        );
        map.insert(
            "token_initialize_token_for_id".to_string(),
            Box::new(decoder::token_initialize_token_for_id),
        );
        map.insert(
            "token_initialize_token_script".to_string(),
            Box::new(decoder::token_initialize_token_script),
        );
        map.insert(
            "token_transfers_cancel_offer_script".to_string(),
            Box::new(decoder::token_transfers_cancel_offer_script),
        );
        map.insert(
            "token_transfers_claim_script".to_string(),
            Box::new(decoder::token_transfers_claim_script),
        );
        map.insert(
            "token_transfers_offer_script".to_string(),
            Box::new(decoder::token_transfers_offer_script),
        );
        map.insert(
            "transaction_publishing_option_set_module_publishing_allowed".to_string(),
            Box::new(decoder::transaction_publishing_option_set_module_publishing_allowed),
        );
        map.insert(
            "validator_set_script_add_validator".to_string(),
            Box::new(decoder::validator_set_script_add_validator),
        );
        map.insert(
            "validator_set_script_create_validator_account".to_string(),
            Box::new(decoder::validator_set_script_create_validator_account),
        );
        map.insert(
            "validator_set_script_create_validator_operator_account".to_string(),
            Box::new(decoder::validator_set_script_create_validator_operator_account),
        );
        map.insert(
            "validator_set_script_register_validator_config".to_string(),
            Box::new(decoder::validator_set_script_register_validator_config),
        );
        map.insert(
            "validator_set_script_remove_validator".to_string(),
            Box::new(decoder::validator_set_script_remove_validator),
        );
        map.insert(
            "validator_set_script_set_validator_config_and_reconfigure".to_string(),
            Box::new(decoder::validator_set_script_set_validator_config_and_reconfigure),
        );
        map.insert(
            "validator_set_script_set_validator_operator".to_string(),
            Box::new(decoder::validator_set_script_set_validator_operator),
        );
        map.insert(
            "version_set_version".to_string(),
            Box::new(decoder::version_set_version),
        );
        map.insert(
            "vm_config_set_gas_constants".to_string(),
            Box::new(decoder::vm_config_set_gas_constants),
        );
        map
    });
