
// Copyright Â© Aptos Foundation
// SPDX-License-Identifier: Apache-2.0

// This file was generated. Do not modify!
//
// To update this code, run: `cargo run --release -p framework`.

// Conversion library between a structured representation of a Move script call (`ScriptCall`) and the
// standard BCS-compatible representation used in Aptos transactions (`Script`).
//
// This code was generated by compiling known Script interfaces ("ABIs") with the tool `aptos-sdk-builder`.

#![allow(dead_code)]
#![allow(unused_imports)]
use aptos_types::account_address::{AccountAddress};
use aptos_types::transaction::{TransactionPayload, EntryFunction};
use move_core_types::{ident_str};
use move_core_types::language_storage::{ModuleId, TypeTag};

type Bytes = Vec<u8>;


/// Structured representation of a call into a known Move entry function.
/// ```ignore
/// impl EntryFunctionCall {
///     pub fn encode(self) -> TransactionPayload { .. }
///     pub fn decode(&TransactionPayload) -> Option<EntryFunctionCall> { .. }
/// }
/// ```
#[derive(Clone, Debug, PartialEq, Eq)]
#[cfg_attr(feature = "fuzzing", derive(proptest_derive::Arbitrary))]
#[cfg_attr(feature = "fuzzing", proptest(no_params))]
pub enum EntryFunctionCall {


    AptosTokenAddPropertyCall {
        collection: Vec<u8>,
        name: Vec<u8>,
        key: Vec<u8>,
        type: Vec<u8>,
        value: Vec<u8>,
    },


    AptosTokenBurnCall {
        collection: Vec<u8>,
        name: Vec<u8>,
    },

    /// Create a new collection
    AptosTokenCreateCollection {
        description: Vec<u8>,
        max_supply: u64,
        name: Vec<u8>,
        uri: Vec<u8>,
        mutable_description: bool,
        mutable_royalty: bool,
        mutable_uri: bool,
        mutable_token_description: bool,
        mutable_token_name: bool,
        mutable_token_properties: bool,
        mutable_token_uri: bool,
        tokens_burnable_by_creator: bool,
        tokens_freezable_by_creator: bool,
        royalty_numerator: u64,
        royalty_denominator: u64,
    },


    AptosTokenFreezeTransferCall {
        collection: Vec<u8>,
        name: Vec<u8>,
    },

    /// With an existing collection, directly mint a viable token into the creators account.
    AptosTokenMint {
        collection: Vec<u8>,
        description: Vec<u8>,
        name: Vec<u8>,
        uri: Vec<u8>,
        property_keys: Vec<Vec<u8>>,
        property_types: Vec<Vec<u8>>,
        property_values: Vec<Vec<u8>>,
    },

    /// With an existing collection, directly mint a soul bound token into the recipient's account.
    AptosTokenMintSoulBound {
        collection: Vec<u8>,
        description: Vec<u8>,
        name: Vec<u8>,
        uri: Vec<u8>,
        property_keys: Vec<Vec<u8>>,
        property_types: Vec<Vec<u8>>,
        property_values: Vec<Vec<u8>>,
        soul_bound_to: AccountAddress,
    },


    AptosTokenRemovePropertyCall {
        collection: Vec<u8>,
        name: Vec<u8>,
        key: Vec<u8>,
    },


    AptosTokenSetCollectionDescriptionCall {
        collection: Vec<u8>,
        description: Vec<u8>,
    },


    AptosTokenSetCollectionRoyaltiesCall {
        collection: Vec<u8>,
        royalty_numerator: u64,
        royalty_denominator: u64,
        payee_address: AccountAddress,
    },


    AptosTokenSetCollectionUriCall {
        collection: Vec<u8>,
        uri: Vec<u8>,
    },


    AptosTokenSetDescriptionCall {
        collection: Vec<u8>,
        name: Vec<u8>,
        description: Vec<u8>,
    },


    AptosTokenSetNameCall {
        collection: Vec<u8>,
        original_name: Vec<u8>,
        new_name: Vec<u8>,
    },


    AptosTokenSetUriCall {
        collection: Vec<u8>,
        name: Vec<u8>,
        uri: Vec<u8>,
    },


    AptosTokenUnfreezeTransferCall {
        collection: Vec<u8>,
        name: Vec<u8>,
    },


    AptosTokenUpdatePropertyCall {
        collection: Vec<u8>,
        name: Vec<u8>,
        key: Vec<u8>,
        type: Vec<u8>,
        value: Vec<u8>,
    },

    /// Entry function for creating a collection
    CollectionCreateCollection {
        description: Vec<u8>,
        name: Vec<u8>,
        uri: Vec<u8>,
        max_supply: u64,
        enable_royalty: bool,
        royalty_numerator: u64,
        royalty_denominator: u64,
        royalty_payee_address: AccountAddress,
    },
}


impl EntryFunctionCall {

    /// Build an Aptos `TransactionPayload` from a structured object `EntryFunctionCall`.
    pub fn encode(self) -> TransactionPayload {
        use EntryFunctionCall::*;
        match self {
            AptosTokenAddPropertyCall{collection, name, key, type, value} => aptos_token_add_property_call(collection, name, key, type, value),
            AptosTokenBurnCall{collection, name} => aptos_token_burn_call(collection, name),
            AptosTokenCreateCollection{description, max_supply, name, uri, mutable_description, mutable_royalty, mutable_uri, mutable_token_description, mutable_token_name, mutable_token_properties, mutable_token_uri, tokens_burnable_by_creator, tokens_freezable_by_creator, royalty_numerator, royalty_denominator} => aptos_token_create_collection(description, max_supply, name, uri, mutable_description, mutable_royalty, mutable_uri, mutable_token_description, mutable_token_name, mutable_token_properties, mutable_token_uri, tokens_burnable_by_creator, tokens_freezable_by_creator, royalty_numerator, royalty_denominator),
            AptosTokenFreezeTransferCall{collection, name} => aptos_token_freeze_transfer_call(collection, name),
            AptosTokenMint{collection, description, name, uri, property_keys, property_types, property_values} => aptos_token_mint(collection, description, name, uri, property_keys, property_types, property_values),
            AptosTokenMintSoulBound{collection, description, name, uri, property_keys, property_types, property_values, soul_bound_to} => aptos_token_mint_soul_bound(collection, description, name, uri, property_keys, property_types, property_values, soul_bound_to),
            AptosTokenRemovePropertyCall{collection, name, key} => aptos_token_remove_property_call(collection, name, key),
            AptosTokenSetCollectionDescriptionCall{collection, description} => aptos_token_set_collection_description_call(collection, description),
            AptosTokenSetCollectionRoyaltiesCall{collection, royalty_numerator, royalty_denominator, payee_address} => aptos_token_set_collection_royalties_call(collection, royalty_numerator, royalty_denominator, payee_address),
            AptosTokenSetCollectionUriCall{collection, uri} => aptos_token_set_collection_uri_call(collection, uri),
            AptosTokenSetDescriptionCall{collection, name, description} => aptos_token_set_description_call(collection, name, description),
            AptosTokenSetNameCall{collection, original_name, new_name} => aptos_token_set_name_call(collection, original_name, new_name),
            AptosTokenSetUriCall{collection, name, uri} => aptos_token_set_uri_call(collection, name, uri),
            AptosTokenUnfreezeTransferCall{collection, name} => aptos_token_unfreeze_transfer_call(collection, name),
            AptosTokenUpdatePropertyCall{collection, name, key, type, value} => aptos_token_update_property_call(collection, name, key, type, value),
            CollectionCreateCollection{description, name, uri, max_supply, enable_royalty, royalty_numerator, royalty_denominator, royalty_payee_address} => collection_create_collection(description, name, uri, max_supply, enable_royalty, royalty_numerator, royalty_denominator, royalty_payee_address),
        }
    }


    /// Try to recognize an Aptos `TransactionPayload` and convert it into a structured object `EntryFunctionCall`.
    pub fn decode(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            match SCRIPT_FUNCTION_DECODER_MAP.get(&format!("{}_{}", script.module().name(), script.function())) {
                Some(decoder) => decoder(payload),
                None => None,
            }
        } else {
            None
        }
    }

}


pub fn aptos_token_add_property_call(collection: Vec<u8>, name: Vec<u8>, key: Vec<u8>, type: Vec<u8>, value: Vec<u8>) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
                    AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4]),
                    ident_str!("aptos_token").to_owned(),
                ),
        ident_str!("add_property_call").to_owned(),
        vec![],
        vec![bcs::to_bytes(&collection).unwrap(), bcs::to_bytes(&name).unwrap(), bcs::to_bytes(&key).unwrap(), bcs::to_bytes(&type).unwrap(), bcs::to_bytes(&value).unwrap()],
    ))
}


pub fn aptos_token_burn_call(collection: Vec<u8>, name: Vec<u8>) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
                    AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4]),
                    ident_str!("aptos_token").to_owned(),
                ),
        ident_str!("burn_call").to_owned(),
        vec![],
        vec![bcs::to_bytes(&collection).unwrap(), bcs::to_bytes(&name).unwrap()],
    ))
}

/// Create a new collection
pub fn aptos_token_create_collection(description: Vec<u8>, max_supply: u64, name: Vec<u8>, uri: Vec<u8>, mutable_description: bool, mutable_royalty: bool, mutable_uri: bool, mutable_token_description: bool, mutable_token_name: bool, mutable_token_properties: bool, mutable_token_uri: bool, tokens_burnable_by_creator: bool, tokens_freezable_by_creator: bool, royalty_numerator: u64, royalty_denominator: u64) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
                    AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4]),
                    ident_str!("aptos_token").to_owned(),
                ),
        ident_str!("create_collection").to_owned(),
        vec![],
        vec![bcs::to_bytes(&description).unwrap(), bcs::to_bytes(&max_supply).unwrap(), bcs::to_bytes(&name).unwrap(), bcs::to_bytes(&uri).unwrap(), bcs::to_bytes(&mutable_description).unwrap(), bcs::to_bytes(&mutable_royalty).unwrap(), bcs::to_bytes(&mutable_uri).unwrap(), bcs::to_bytes(&mutable_token_description).unwrap(), bcs::to_bytes(&mutable_token_name).unwrap(), bcs::to_bytes(&mutable_token_properties).unwrap(), bcs::to_bytes(&mutable_token_uri).unwrap(), bcs::to_bytes(&tokens_burnable_by_creator).unwrap(), bcs::to_bytes(&tokens_freezable_by_creator).unwrap(), bcs::to_bytes(&royalty_numerator).unwrap(), bcs::to_bytes(&royalty_denominator).unwrap()],
    ))
}


pub fn aptos_token_freeze_transfer_call(collection: Vec<u8>, name: Vec<u8>) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
                    AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4]),
                    ident_str!("aptos_token").to_owned(),
                ),
        ident_str!("freeze_transfer_call").to_owned(),
        vec![],
        vec![bcs::to_bytes(&collection).unwrap(), bcs::to_bytes(&name).unwrap()],
    ))
}

/// With an existing collection, directly mint a viable token into the creators account.
pub fn aptos_token_mint(collection: Vec<u8>, description: Vec<u8>, name: Vec<u8>, uri: Vec<u8>, property_keys: Vec<Vec<u8>>, property_types: Vec<Vec<u8>>, property_values: Vec<Vec<u8>>) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
                    AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4]),
                    ident_str!("aptos_token").to_owned(),
                ),
        ident_str!("mint").to_owned(),
        vec![],
        vec![bcs::to_bytes(&collection).unwrap(), bcs::to_bytes(&description).unwrap(), bcs::to_bytes(&name).unwrap(), bcs::to_bytes(&uri).unwrap(), bcs::to_bytes(&property_keys).unwrap(), bcs::to_bytes(&property_types).unwrap(), bcs::to_bytes(&property_values).unwrap()],
    ))
}

/// With an existing collection, directly mint a soul bound token into the recipient's account.
pub fn aptos_token_mint_soul_bound(collection: Vec<u8>, description: Vec<u8>, name: Vec<u8>, uri: Vec<u8>, property_keys: Vec<Vec<u8>>, property_types: Vec<Vec<u8>>, property_values: Vec<Vec<u8>>, soul_bound_to: AccountAddress) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
                    AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4]),
                    ident_str!("aptos_token").to_owned(),
                ),
        ident_str!("mint_soul_bound").to_owned(),
        vec![],
        vec![bcs::to_bytes(&collection).unwrap(), bcs::to_bytes(&description).unwrap(), bcs::to_bytes(&name).unwrap(), bcs::to_bytes(&uri).unwrap(), bcs::to_bytes(&property_keys).unwrap(), bcs::to_bytes(&property_types).unwrap(), bcs::to_bytes(&property_values).unwrap(), bcs::to_bytes(&soul_bound_to).unwrap()],
    ))
}


pub fn aptos_token_remove_property_call(collection: Vec<u8>, name: Vec<u8>, key: Vec<u8>) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
                    AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4]),
                    ident_str!("aptos_token").to_owned(),
                ),
        ident_str!("remove_property_call").to_owned(),
        vec![],
        vec![bcs::to_bytes(&collection).unwrap(), bcs::to_bytes(&name).unwrap(), bcs::to_bytes(&key).unwrap()],
    ))
}


pub fn aptos_token_set_collection_description_call(collection: Vec<u8>, description: Vec<u8>) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
                    AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4]),
                    ident_str!("aptos_token").to_owned(),
                ),
        ident_str!("set_collection_description_call").to_owned(),
        vec![],
        vec![bcs::to_bytes(&collection).unwrap(), bcs::to_bytes(&description).unwrap()],
    ))
}


pub fn aptos_token_set_collection_royalties_call(collection: Vec<u8>, royalty_numerator: u64, royalty_denominator: u64, payee_address: AccountAddress) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
                    AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4]),
                    ident_str!("aptos_token").to_owned(),
                ),
        ident_str!("set_collection_royalties_call").to_owned(),
        vec![],
        vec![bcs::to_bytes(&collection).unwrap(), bcs::to_bytes(&royalty_numerator).unwrap(), bcs::to_bytes(&royalty_denominator).unwrap(), bcs::to_bytes(&payee_address).unwrap()],
    ))
}


pub fn aptos_token_set_collection_uri_call(collection: Vec<u8>, uri: Vec<u8>) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
                    AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4]),
                    ident_str!("aptos_token").to_owned(),
                ),
        ident_str!("set_collection_uri_call").to_owned(),
        vec![],
        vec![bcs::to_bytes(&collection).unwrap(), bcs::to_bytes(&uri).unwrap()],
    ))
}


pub fn aptos_token_set_description_call(collection: Vec<u8>, name: Vec<u8>, description: Vec<u8>) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
                    AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4]),
                    ident_str!("aptos_token").to_owned(),
                ),
        ident_str!("set_description_call").to_owned(),
        vec![],
        vec![bcs::to_bytes(&collection).unwrap(), bcs::to_bytes(&name).unwrap(), bcs::to_bytes(&description).unwrap()],
    ))
}


pub fn aptos_token_set_name_call(collection: Vec<u8>, original_name: Vec<u8>, new_name: Vec<u8>) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
                    AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4]),
                    ident_str!("aptos_token").to_owned(),
                ),
        ident_str!("set_name_call").to_owned(),
        vec![],
        vec![bcs::to_bytes(&collection).unwrap(), bcs::to_bytes(&original_name).unwrap(), bcs::to_bytes(&new_name).unwrap()],
    ))
}


pub fn aptos_token_set_uri_call(collection: Vec<u8>, name: Vec<u8>, uri: Vec<u8>) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
                    AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4]),
                    ident_str!("aptos_token").to_owned(),
                ),
        ident_str!("set_uri_call").to_owned(),
        vec![],
        vec![bcs::to_bytes(&collection).unwrap(), bcs::to_bytes(&name).unwrap(), bcs::to_bytes(&uri).unwrap()],
    ))
}


pub fn aptos_token_unfreeze_transfer_call(collection: Vec<u8>, name: Vec<u8>) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
                    AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4]),
                    ident_str!("aptos_token").to_owned(),
                ),
        ident_str!("unfreeze_transfer_call").to_owned(),
        vec![],
        vec![bcs::to_bytes(&collection).unwrap(), bcs::to_bytes(&name).unwrap()],
    ))
}


pub fn aptos_token_update_property_call(collection: Vec<u8>, name: Vec<u8>, key: Vec<u8>, type: Vec<u8>, value: Vec<u8>) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
                    AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4]),
                    ident_str!("aptos_token").to_owned(),
                ),
        ident_str!("update_property_call").to_owned(),
        vec![],
        vec![bcs::to_bytes(&collection).unwrap(), bcs::to_bytes(&name).unwrap(), bcs::to_bytes(&key).unwrap(), bcs::to_bytes(&type).unwrap(), bcs::to_bytes(&value).unwrap()],
    ))
}

/// Entry function for creating a collection
pub fn collection_create_collection(description: Vec<u8>, name: Vec<u8>, uri: Vec<u8>, max_supply: u64, enable_royalty: bool, royalty_numerator: u64, royalty_denominator: u64, royalty_payee_address: AccountAddress) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
                    AccountAddress::new([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4]),
                    ident_str!("collection").to_owned(),
                ),
        ident_str!("create_collection").to_owned(),
        vec![],
        vec![bcs::to_bytes(&description).unwrap(), bcs::to_bytes(&name).unwrap(), bcs::to_bytes(&uri).unwrap(), bcs::to_bytes(&max_supply).unwrap(), bcs::to_bytes(&enable_royalty).unwrap(), bcs::to_bytes(&royalty_numerator).unwrap(), bcs::to_bytes(&royalty_denominator).unwrap(), bcs::to_bytes(&royalty_payee_address).unwrap()],
    ))
}
mod decoder {    use super::*;
pub fn aptos_token_add_property_call(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
    if let TransactionPayload::EntryFunction(script) = payload {
        Some(EntryFunctionCall::AptosTokenAddPropertyCall {
            collection : bcs::from_bytes(script.args().get(0)?).ok()?,
            name : bcs::from_bytes(script.args().get(1)?).ok()?,
            key : bcs::from_bytes(script.args().get(2)?).ok()?,
            type : bcs::from_bytes(script.args().get(3)?).ok()?,
            value : bcs::from_bytes(script.args().get(4)?).ok()?,
        })
    } else {
        None
    }
}

pub fn aptos_token_burn_call(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
    if let TransactionPayload::EntryFunction(script) = payload {
        Some(EntryFunctionCall::AptosTokenBurnCall {
            collection : bcs::from_bytes(script.args().get(0)?).ok()?,
            name : bcs::from_bytes(script.args().get(1)?).ok()?,
        })
    } else {
        None
    }
}

pub fn aptos_token_create_collection(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
    if let TransactionPayload::EntryFunction(script) = payload {
        Some(EntryFunctionCall::AptosTokenCreateCollection {
            description : bcs::from_bytes(script.args().get(0)?).ok()?,
            max_supply : bcs::from_bytes(script.args().get(1)?).ok()?,
            name : bcs::from_bytes(script.args().get(2)?).ok()?,
            uri : bcs::from_bytes(script.args().get(3)?).ok()?,
            mutable_description : bcs::from_bytes(script.args().get(4)?).ok()?,
            mutable_royalty : bcs::from_bytes(script.args().get(5)?).ok()?,
            mutable_uri : bcs::from_bytes(script.args().get(6)?).ok()?,
            mutable_token_description : bcs::from_bytes(script.args().get(7)?).ok()?,
            mutable_token_name : bcs::from_bytes(script.args().get(8)?).ok()?,
            mutable_token_properties : bcs::from_bytes(script.args().get(9)?).ok()?,
            mutable_token_uri : bcs::from_bytes(script.args().get(10)?).ok()?,
            tokens_burnable_by_creator : bcs::from_bytes(script.args().get(11)?).ok()?,
            tokens_freezable_by_creator : bcs::from_bytes(script.args().get(12)?).ok()?,
            royalty_numerator : bcs::from_bytes(script.args().get(13)?).ok()?,
            royalty_denominator : bcs::from_bytes(script.args().get(14)?).ok()?,
        })
    } else {
        None
    }
}

pub fn aptos_token_freeze_transfer_call(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
    if let TransactionPayload::EntryFunction(script) = payload {
        Some(EntryFunctionCall::AptosTokenFreezeTransferCall {
            collection : bcs::from_bytes(script.args().get(0)?).ok()?,
            name : bcs::from_bytes(script.args().get(1)?).ok()?,
        })
    } else {
        None
    }
}

pub fn aptos_token_mint(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
    if let TransactionPayload::EntryFunction(script) = payload {
        Some(EntryFunctionCall::AptosTokenMint {
            collection : bcs::from_bytes(script.args().get(0)?).ok()?,
            description : bcs::from_bytes(script.args().get(1)?).ok()?,
            name : bcs::from_bytes(script.args().get(2)?).ok()?,
            uri : bcs::from_bytes(script.args().get(3)?).ok()?,
            property_keys : bcs::from_bytes(script.args().get(4)?).ok()?,
            property_types : bcs::from_bytes(script.args().get(5)?).ok()?,
            property_values : bcs::from_bytes(script.args().get(6)?).ok()?,
        })
    } else {
        None
    }
}

pub fn aptos_token_mint_soul_bound(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
    if let TransactionPayload::EntryFunction(script) = payload {
        Some(EntryFunctionCall::AptosTokenMintSoulBound {
            collection : bcs::from_bytes(script.args().get(0)?).ok()?,
            description : bcs::from_bytes(script.args().get(1)?).ok()?,
            name : bcs::from_bytes(script.args().get(2)?).ok()?,
            uri : bcs::from_bytes(script.args().get(3)?).ok()?,
            property_keys : bcs::from_bytes(script.args().get(4)?).ok()?,
            property_types : bcs::from_bytes(script.args().get(5)?).ok()?,
            property_values : bcs::from_bytes(script.args().get(6)?).ok()?,
            soul_bound_to : bcs::from_bytes(script.args().get(7)?).ok()?,
        })
    } else {
        None
    }
}

pub fn aptos_token_remove_property_call(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
    if let TransactionPayload::EntryFunction(script) = payload {
        Some(EntryFunctionCall::AptosTokenRemovePropertyCall {
            collection : bcs::from_bytes(script.args().get(0)?).ok()?,
            name : bcs::from_bytes(script.args().get(1)?).ok()?,
            key : bcs::from_bytes(script.args().get(2)?).ok()?,
        })
    } else {
        None
    }
}

pub fn aptos_token_set_collection_description_call(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
    if let TransactionPayload::EntryFunction(script) = payload {
        Some(EntryFunctionCall::AptosTokenSetCollectionDescriptionCall {
            collection : bcs::from_bytes(script.args().get(0)?).ok()?,
            description : bcs::from_bytes(script.args().get(1)?).ok()?,
        })
    } else {
        None
    }
}

pub fn aptos_token_set_collection_royalties_call(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
    if let TransactionPayload::EntryFunction(script) = payload {
        Some(EntryFunctionCall::AptosTokenSetCollectionRoyaltiesCall {
            collection : bcs::from_bytes(script.args().get(0)?).ok()?,
            royalty_numerator : bcs::from_bytes(script.args().get(1)?).ok()?,
            royalty_denominator : bcs::from_bytes(script.args().get(2)?).ok()?,
            payee_address : bcs::from_bytes(script.args().get(3)?).ok()?,
        })
    } else {
        None
    }
}

pub fn aptos_token_set_collection_uri_call(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
    if let TransactionPayload::EntryFunction(script) = payload {
        Some(EntryFunctionCall::AptosTokenSetCollectionUriCall {
            collection : bcs::from_bytes(script.args().get(0)?).ok()?,
            uri : bcs::from_bytes(script.args().get(1)?).ok()?,
        })
    } else {
        None
    }
}

pub fn aptos_token_set_description_call(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
    if let TransactionPayload::EntryFunction(script) = payload {
        Some(EntryFunctionCall::AptosTokenSetDescriptionCall {
            collection : bcs::from_bytes(script.args().get(0)?).ok()?,
            name : bcs::from_bytes(script.args().get(1)?).ok()?,
            description : bcs::from_bytes(script.args().get(2)?).ok()?,
        })
    } else {
        None
    }
}

pub fn aptos_token_set_name_call(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
    if let TransactionPayload::EntryFunction(script) = payload {
        Some(EntryFunctionCall::AptosTokenSetNameCall {
            collection : bcs::from_bytes(script.args().get(0)?).ok()?,
            original_name : bcs::from_bytes(script.args().get(1)?).ok()?,
            new_name : bcs::from_bytes(script.args().get(2)?).ok()?,
        })
    } else {
        None
    }
}

pub fn aptos_token_set_uri_call(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
    if let TransactionPayload::EntryFunction(script) = payload {
        Some(EntryFunctionCall::AptosTokenSetUriCall {
            collection : bcs::from_bytes(script.args().get(0)?).ok()?,
            name : bcs::from_bytes(script.args().get(1)?).ok()?,
            uri : bcs::from_bytes(script.args().get(2)?).ok()?,
        })
    } else {
        None
    }
}

pub fn aptos_token_unfreeze_transfer_call(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
    if let TransactionPayload::EntryFunction(script) = payload {
        Some(EntryFunctionCall::AptosTokenUnfreezeTransferCall {
            collection : bcs::from_bytes(script.args().get(0)?).ok()?,
            name : bcs::from_bytes(script.args().get(1)?).ok()?,
        })
    } else {
        None
    }
}

pub fn aptos_token_update_property_call(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
    if let TransactionPayload::EntryFunction(script) = payload {
        Some(EntryFunctionCall::AptosTokenUpdatePropertyCall {
            collection : bcs::from_bytes(script.args().get(0)?).ok()?,
            name : bcs::from_bytes(script.args().get(1)?).ok()?,
            key : bcs::from_bytes(script.args().get(2)?).ok()?,
            type : bcs::from_bytes(script.args().get(3)?).ok()?,
            value : bcs::from_bytes(script.args().get(4)?).ok()?,
        })
    } else {
        None
    }
}

pub fn collection_create_collection(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
    if let TransactionPayload::EntryFunction(script) = payload {
        Some(EntryFunctionCall::CollectionCreateCollection {
            description : bcs::from_bytes(script.args().get(0)?).ok()?,
            name : bcs::from_bytes(script.args().get(1)?).ok()?,
            uri : bcs::from_bytes(script.args().get(2)?).ok()?,
            max_supply : bcs::from_bytes(script.args().get(3)?).ok()?,
            enable_royalty : bcs::from_bytes(script.args().get(4)?).ok()?,
            royalty_numerator : bcs::from_bytes(script.args().get(5)?).ok()?,
            royalty_denominator : bcs::from_bytes(script.args().get(6)?).ok()?,
            royalty_payee_address : bcs::from_bytes(script.args().get(7)?).ok()?,
        })
    } else {
        None
    }
}
}

type EntryFunctionDecoderMap = std::collections::HashMap<String, Box<dyn Fn(&TransactionPayload) -> Option<EntryFunctionCall> + std::marker::Sync + std::marker::Send>>;

static SCRIPT_FUNCTION_DECODER_MAP: once_cell::sync::Lazy<EntryFunctionDecoderMap> = once_cell::sync::Lazy::new(|| {
    let mut map : EntryFunctionDecoderMap = std::collections::HashMap::new();
    map.insert("aptos_token_add_property_call".to_string(), Box::new(decoder::aptos_token_add_property_call));
    map.insert("aptos_token_burn_call".to_string(), Box::new(decoder::aptos_token_burn_call));
    map.insert("aptos_token_create_collection".to_string(), Box::new(decoder::aptos_token_create_collection));
    map.insert("aptos_token_freeze_transfer_call".to_string(), Box::new(decoder::aptos_token_freeze_transfer_call));
    map.insert("aptos_token_mint".to_string(), Box::new(decoder::aptos_token_mint));
    map.insert("aptos_token_mint_soul_bound".to_string(), Box::new(decoder::aptos_token_mint_soul_bound));
    map.insert("aptos_token_remove_property_call".to_string(), Box::new(decoder::aptos_token_remove_property_call));
    map.insert("aptos_token_set_collection_description_call".to_string(), Box::new(decoder::aptos_token_set_collection_description_call));
    map.insert("aptos_token_set_collection_royalties_call".to_string(), Box::new(decoder::aptos_token_set_collection_royalties_call));
    map.insert("aptos_token_set_collection_uri_call".to_string(), Box::new(decoder::aptos_token_set_collection_uri_call));
    map.insert("aptos_token_set_description_call".to_string(), Box::new(decoder::aptos_token_set_description_call));
    map.insert("aptos_token_set_name_call".to_string(), Box::new(decoder::aptos_token_set_name_call));
    map.insert("aptos_token_set_uri_call".to_string(), Box::new(decoder::aptos_token_set_uri_call));
    map.insert("aptos_token_unfreeze_transfer_call".to_string(), Box::new(decoder::aptos_token_unfreeze_transfer_call));
    map.insert("aptos_token_update_property_call".to_string(), Box::new(decoder::aptos_token_update_property_call));
    map.insert("collection_create_collection".to_string(), Box::new(decoder::collection_create_collection));
    map
});
