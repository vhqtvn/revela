// Copyright (c) Aptos
// SPDX-License-Identifier: Apache-2.0

// This file was generated. Do not modify!
//
// To update this code, run: `cargo run --release -p framework`.

// Conversion library between a structured representation of a Move script call (`ScriptCall`) and the
// standard BCS-compatible representation used in Aptos transactions (`Script`).
//
// This code was generated by compiling known Script interfaces ("ABIs") with the tool `transaction-builder-generator`.

#![allow(unused_imports)]

use aptos_types::{
    account_address::AccountAddress,
    transaction::{Script, ScriptFunction, TransactionArgument, TransactionPayload, VecBytes},
};
use move_deps::move_core_types::{ident_str, language_storage::ModuleId};

type Bytes = Vec<u8>;

/// Structured representation of a call into a known Move script function.
/// ```ignore
/// impl ScriptFunctionCall {
///     pub fn encode(self) -> TransactionPayload { .. }
///     pub fn decode(&TransactionPayload) -> Option<ScriptFunctionCall> { .. }
/// }
/// ```
#[derive(Clone, Debug, PartialEq)]
#[cfg_attr(feature = "fuzzing", derive(proptest_derive::Arbitrary))]
#[cfg_attr(feature = "fuzzing", proptest(no_params))]
pub enum ScriptFunctionCall {
    /// Basic account creation methods.
    AccountCreateAccount {
        auth_key: AccountAddress,
    },

    AccountRotateAuthenticationKey {
        new_auth_key: Bytes,
    },

    AccountUtilsCreateAndFundAccount {
        account: AccountAddress,
        amount: u64,
    },

    /// Create a proposal with the backing `stake_pool`.
    /// @param execution_hash Required. This is the hash of the resolution script. When the proposal is resolved,
    /// only the exact script with matching hash can be successfully executed.
    AptosGovernanceCreateProposal {
        stake_pool: AccountAddress,
        execution_hash: Bytes,
    },

    /// Vote on proposal with `proposal_id` and voting power from `stake_pool`.
    AptosGovernanceVote {
        stake_pool: AccountAddress,
        proposal_id: u64,
        should_pass: bool,
    },

    /// Force an epoch change.
    ReconfigurationForceReconfigure {},

    /// Creates a new resource account and rotates the authentication key to either
    /// the optional auth key if it is non-empty (though auth keys are 32-bytes)
    /// or the source accounts current auth key.
    ResourceAccountCreateResourceAccount {
        seed: Bytes,
        optional_auth_key: Bytes,
    },

    /// Add `amount` of coins from the `account` owning the StakePool.
    StakeAddStake {
        amount: u64,
    },

    /// Similar to increase_lockup_with_cap but will use ownership capability from the signing account.
    StakeIncreaseLockup {
        new_locked_until_secs: u64,
    },

    /// This can only called by the operator of the validator/staking pool.
    StakeJoinValidatorSet {
        pool_address: AccountAddress,
    },

    /// Request to have `pool_address` leave the validator set. The validator is only actually removed from the set when
    /// the next epoch starts.
    /// The last validator in the set cannot leave. This is an edge case that should never happen as long as the network
    /// is still operational.
    ///
    /// Can only be called by the operator of the validator/staking pool.
    StakeLeaveValidatorSet {
        pool_address: AccountAddress,
    },

    /// Initialize the validator account and give ownership to the signing account.
    StakeRegisterValidatorCandidate {
        consensus_pubkey: Bytes,
        proof_of_possession: Bytes,
        network_addresses: Bytes,
        fullnode_addresses: Bytes,
    },

    /// Rotate the consensus key of the validator, it'll take effect in next epoch.
    StakeRotateConsensusKey {
        pool_address: AccountAddress,
        new_consensus_pubkey: Bytes,
        proof_of_possession: Bytes,
    },

    /// Allows an owner to change the delegated voter of the stake pool.
    StakeSetDelegatedVoter {
        new_delegated_voter: AccountAddress,
    },

    /// Allows an owner to change the operator of the stake pool.
    StakeSetOperator {
        new_operator: AccountAddress,
    },

    /// Similar to unlock_with_cap but will use ownership capability from the signing account.
    StakeUnlock {
        amount: u64,
    },

    /// Update the network and full node addresses of the validator. This only takes effect in the next epoch.
    StakeUpdateNetworkAndFullnodeAddresses {
        pool_address: AccountAddress,
        new_network_addresses: Bytes,
        new_fullnode_addresses: Bytes,
    },

    /// Withdraw from `account`'s inactive stake.
    StakeWithdraw {},

    /// Claim the delegated mint capability and destroy the delegated token.
    TestCoinClaimMintCapability {},

    /// Create delegated token for the address so the account could claim MintCapability later.
    TestCoinDelegateMintCapability {
        to: AccountAddress,
    },

    /// Create new test coins and deposit them into dst_addr's account.
    TestCoinMint {
        dst_addr: AccountAddress,
        amount: u64,
    },

    TokenCreateLimitedCollectionScript {
        name: Bytes,
        description: Bytes,
        uri: Bytes,
        maximum: u64,
    },

    TokenCreateLimitedTokenScript {
        collection: Bytes,
        name: Bytes,
        description: Bytes,
        monitor_supply: bool,
        initial_balance: u64,
        maximum: u64,
        uri: Bytes,
        royalty_points_per_million: u64,
    },

    TokenCreateUnlimitedCollectionScript {
        name: Bytes,
        description: Bytes,
        uri: Bytes,
    },

    TokenCreateUnlimitedTokenScript {
        collection: Bytes,
        name: Bytes,
        description: Bytes,
        monitor_supply: bool,
        initial_balance: u64,
        uri: Bytes,
        royalty_points_per_million: u64,
    },

    TokenDirectTransferScript {
        creators_address: AccountAddress,
        collection: Bytes,
        name: Bytes,
        amount: u64,
    },

    TokenInitializeTokenForId {
        creators_address: AccountAddress,
        collection: Bytes,
        name: Bytes,
    },

    TokenInitializeTokenScript {},

    TokenTransfersCancelOfferScript {
        receiver: AccountAddress,
        creator: AccountAddress,
        collection: Bytes,
        name: Bytes,
    },

    TokenTransfersClaimScript {
        sender: AccountAddress,
        creator: AccountAddress,
        collection: Bytes,
        name: Bytes,
    },

    TokenTransfersOfferScript {
        receiver: AccountAddress,
        creator: AccountAddress,
        collection: Bytes,
        name: Bytes,
        amount: u64,
    },

    TransactionPublishingOptionSetModulePublishingAllowed {
        is_allowed: bool,
    },

    VMConfigSetGasConstants {
        global_memory_per_byte_cost: u64,
        global_memory_per_byte_write_cost: u64,
        min_transaction_gas_units: u64,
        large_transaction_cutoff: u64,
        intrinsic_gas_per_byte: u64,
        maximum_number_of_gas_units: u64,
        min_price_per_gas_unit: u64,
        max_price_per_gas_unit: u64,
        max_transaction_size_in_bytes: u64,
        gas_unit_scaling_factor: u64,
        default_account_size: u64,
    },

    ValidatorSetScriptAddValidator {
        _validator_addr: AccountAddress,
    },

    ValidatorSetScriptCreateValidatorAccount {
        _new_account_address: AccountAddress,
        _human_name: Bytes,
    },

    ValidatorSetScriptCreateValidatorOperatorAccount {
        _new_account_address: AccountAddress,
        _human_name: Bytes,
    },

    ValidatorSetScriptRegisterValidatorConfig {
        _validator_address: AccountAddress,
        _consensus_pubkey: Bytes,
        _validator_network_addresses: Bytes,
        _fullnode_network_addresses: Bytes,
    },

    ValidatorSetScriptRemoveValidator {
        _validator_addr: AccountAddress,
    },

    ValidatorSetScriptSetValidatorConfigAndReconfigure {
        _validator_account: AccountAddress,
        _consensus_pubkey: Bytes,
        _validator_network_addresses: Bytes,
        _fullnode_network_addresses: Bytes,
    },

    ValidatorSetScriptSetValidatorOperator {
        _operator_name: Bytes,
        _operator_account: AccountAddress,
    },

    /// Updates the major version to a larger version.
    VersionSetVersion {
        major: u64,
    },
}

impl ScriptFunctionCall {
    /// Build an Aptos `TransactionPayload` from a structured object `ScriptFunctionCall`.
    pub fn encode(self) -> TransactionPayload {
        use ScriptFunctionCall::*;
        match self {
            AccountCreateAccount { auth_key } => encode_account_create_account(auth_key),
            AccountRotateAuthenticationKey { new_auth_key } => {
                encode_account_rotate_authentication_key(new_auth_key)
            }
            AccountUtilsCreateAndFundAccount { account, amount } => {
                encode_account_utils_create_and_fund_account(account, amount)
            }
            AptosGovernanceCreateProposal {
                stake_pool,
                execution_hash,
            } => encode_aptos_governance_create_proposal(stake_pool, execution_hash),
            AptosGovernanceVote {
                stake_pool,
                proposal_id,
                should_pass,
            } => encode_aptos_governance_vote(stake_pool, proposal_id, should_pass),
            ReconfigurationForceReconfigure {} => encode_reconfiguration_force_reconfigure(),
            ResourceAccountCreateResourceAccount {
                seed,
                optional_auth_key,
            } => encode_resource_account_create_resource_account(seed, optional_auth_key),
            StakeAddStake { amount } => encode_stake_add_stake(amount),
            StakeIncreaseLockup {
                new_locked_until_secs,
            } => encode_stake_increase_lockup(new_locked_until_secs),
            StakeJoinValidatorSet { pool_address } => encode_stake_join_validator_set(pool_address),
            StakeLeaveValidatorSet { pool_address } => {
                encode_stake_leave_validator_set(pool_address)
            }
            StakeRegisterValidatorCandidate {
                consensus_pubkey,
                proof_of_possession,
                network_addresses,
                fullnode_addresses,
            } => encode_stake_register_validator_candidate(
                consensus_pubkey,
                proof_of_possession,
                network_addresses,
                fullnode_addresses,
            ),
            StakeRotateConsensusKey {
                pool_address,
                new_consensus_pubkey,
                proof_of_possession,
            } => encode_stake_rotate_consensus_key(
                pool_address,
                new_consensus_pubkey,
                proof_of_possession,
            ),
            StakeSetDelegatedVoter {
                new_delegated_voter,
            } => encode_stake_set_delegated_voter(new_delegated_voter),
            StakeSetOperator { new_operator } => encode_stake_set_operator(new_operator),
            StakeUnlock { amount } => encode_stake_unlock(amount),
            StakeUpdateNetworkAndFullnodeAddresses {
                pool_address,
                new_network_addresses,
                new_fullnode_addresses,
            } => encode_stake_update_network_and_fullnode_addresses(
                pool_address,
                new_network_addresses,
                new_fullnode_addresses,
            ),
            StakeWithdraw {} => encode_stake_withdraw(),
            TestCoinClaimMintCapability {} => encode_test_coin_claim_mint_capability(),
            TestCoinDelegateMintCapability { to } => encode_test_coin_delegate_mint_capability(to),
            TestCoinMint { dst_addr, amount } => encode_test_coin_mint(dst_addr, amount),
            TokenCreateLimitedCollectionScript {
                name,
                description,
                uri,
                maximum,
            } => encode_token_create_limited_collection_script(name, description, uri, maximum),
            TokenCreateLimitedTokenScript {
                collection,
                name,
                description,
                monitor_supply,
                initial_balance,
                maximum,
                uri,
                royalty_points_per_million,
            } => encode_token_create_limited_token_script(
                collection,
                name,
                description,
                monitor_supply,
                initial_balance,
                maximum,
                uri,
                royalty_points_per_million,
            ),
            TokenCreateUnlimitedCollectionScript {
                name,
                description,
                uri,
            } => encode_token_create_unlimited_collection_script(name, description, uri),
            TokenCreateUnlimitedTokenScript {
                collection,
                name,
                description,
                monitor_supply,
                initial_balance,
                uri,
                royalty_points_per_million,
            } => encode_token_create_unlimited_token_script(
                collection,
                name,
                description,
                monitor_supply,
                initial_balance,
                uri,
                royalty_points_per_million,
            ),
            TokenDirectTransferScript {
                creators_address,
                collection,
                name,
                amount,
            } => encode_token_direct_transfer_script(creators_address, collection, name, amount),
            TokenInitializeTokenForId {
                creators_address,
                collection,
                name,
            } => encode_token_initialize_token_for_id(creators_address, collection, name),
            TokenInitializeTokenScript {} => encode_token_initialize_token_script(),
            TokenTransfersCancelOfferScript {
                receiver,
                creator,
                collection,
                name,
            } => encode_token_transfers_cancel_offer_script(receiver, creator, collection, name),
            TokenTransfersClaimScript {
                sender,
                creator,
                collection,
                name,
            } => encode_token_transfers_claim_script(sender, creator, collection, name),
            TokenTransfersOfferScript {
                receiver,
                creator,
                collection,
                name,
                amount,
            } => encode_token_transfers_offer_script(receiver, creator, collection, name, amount),
            TransactionPublishingOptionSetModulePublishingAllowed { is_allowed } => {
                encode_transaction_publishing_option_set_module_publishing_allowed(is_allowed)
            }
            VMConfigSetGasConstants {
                global_memory_per_byte_cost,
                global_memory_per_byte_write_cost,
                min_transaction_gas_units,
                large_transaction_cutoff,
                intrinsic_gas_per_byte,
                maximum_number_of_gas_units,
                min_price_per_gas_unit,
                max_price_per_gas_unit,
                max_transaction_size_in_bytes,
                gas_unit_scaling_factor,
                default_account_size,
            } => encode_vm_config_set_gas_constants(
                global_memory_per_byte_cost,
                global_memory_per_byte_write_cost,
                min_transaction_gas_units,
                large_transaction_cutoff,
                intrinsic_gas_per_byte,
                maximum_number_of_gas_units,
                min_price_per_gas_unit,
                max_price_per_gas_unit,
                max_transaction_size_in_bytes,
                gas_unit_scaling_factor,
                default_account_size,
            ),
            ValidatorSetScriptAddValidator { _validator_addr } => {
                encode_validator_set_script_add_validator(_validator_addr)
            }
            ValidatorSetScriptCreateValidatorAccount {
                _new_account_address,
                _human_name,
            } => encode_validator_set_script_create_validator_account(
                _new_account_address,
                _human_name,
            ),
            ValidatorSetScriptCreateValidatorOperatorAccount {
                _new_account_address,
                _human_name,
            } => encode_validator_set_script_create_validator_operator_account(
                _new_account_address,
                _human_name,
            ),
            ValidatorSetScriptRegisterValidatorConfig {
                _validator_address,
                _consensus_pubkey,
                _validator_network_addresses,
                _fullnode_network_addresses,
            } => encode_validator_set_script_register_validator_config(
                _validator_address,
                _consensus_pubkey,
                _validator_network_addresses,
                _fullnode_network_addresses,
            ),
            ValidatorSetScriptRemoveValidator { _validator_addr } => {
                encode_validator_set_script_remove_validator(_validator_addr)
            }
            ValidatorSetScriptSetValidatorConfigAndReconfigure {
                _validator_account,
                _consensus_pubkey,
                _validator_network_addresses,
                _fullnode_network_addresses,
            } => encode_validator_set_script_set_validator_config_and_reconfigure(
                _validator_account,
                _consensus_pubkey,
                _validator_network_addresses,
                _fullnode_network_addresses,
            ),
            ValidatorSetScriptSetValidatorOperator {
                _operator_name,
                _operator_account,
            } => encode_validator_set_script_set_validator_operator(
                _operator_name,
                _operator_account,
            ),
            VersionSetVersion { major } => encode_version_set_version(major),
        }
    }

    /// Try to recognize an Aptos `TransactionPayload` and convert it into a structured object `ScriptFunctionCall`.
    pub fn decode(payload: &TransactionPayload) -> Option<ScriptFunctionCall> {
        if let TransactionPayload::ScriptFunction(script) = payload {
            match SCRIPT_FUNCTION_DECODER_MAP.get(&format!(
                "{}{}",
                script.module().name(),
                script.function()
            )) {
                Some(decoder) => decoder(payload),
                None => None,
            }
        } else {
            None
        }
    }
}

/// Basic account creation methods.
pub fn encode_account_create_account(auth_key: AccountAddress) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("account").to_owned(),
        ),
        ident_str!("create_account").to_owned(),
        vec![],
        vec![bcs::to_bytes(&auth_key).unwrap()],
    ))
}

pub fn encode_account_rotate_authentication_key(new_auth_key: Vec<u8>) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("account").to_owned(),
        ),
        ident_str!("rotate_authentication_key").to_owned(),
        vec![],
        vec![bcs::to_bytes(&new_auth_key).unwrap()],
    ))
}

pub fn encode_account_utils_create_and_fund_account(
    account: AccountAddress,
    amount: u64,
) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("account_utils").to_owned(),
        ),
        ident_str!("create_and_fund_account").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&account).unwrap(),
            bcs::to_bytes(&amount).unwrap(),
        ],
    ))
}

/// Create a proposal with the backing `stake_pool`.
/// @param execution_hash Required. This is the hash of the resolution script. When the proposal is resolved,
/// only the exact script with matching hash can be successfully executed.
pub fn encode_aptos_governance_create_proposal(
    stake_pool: AccountAddress,
    execution_hash: Vec<u8>,
) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("aptos_governance").to_owned(),
        ),
        ident_str!("create_proposal").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&stake_pool).unwrap(),
            bcs::to_bytes(&execution_hash).unwrap(),
        ],
    ))
}

/// Vote on proposal with `proposal_id` and voting power from `stake_pool`.
pub fn encode_aptos_governance_vote(
    stake_pool: AccountAddress,
    proposal_id: u64,
    should_pass: bool,
) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("aptos_governance").to_owned(),
        ),
        ident_str!("vote").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&stake_pool).unwrap(),
            bcs::to_bytes(&proposal_id).unwrap(),
            bcs::to_bytes(&should_pass).unwrap(),
        ],
    ))
}

/// Force an epoch change.
pub fn encode_reconfiguration_force_reconfigure() -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("reconfiguration").to_owned(),
        ),
        ident_str!("force_reconfigure").to_owned(),
        vec![],
        vec![],
    ))
}

/// Creates a new resource account and rotates the authentication key to either
/// the optional auth key if it is non-empty (though auth keys are 32-bytes)
/// or the source accounts current auth key.
pub fn encode_resource_account_create_resource_account(
    seed: Vec<u8>,
    optional_auth_key: Vec<u8>,
) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("resource_account").to_owned(),
        ),
        ident_str!("create_resource_account").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&seed).unwrap(),
            bcs::to_bytes(&optional_auth_key).unwrap(),
        ],
    ))
}

/// Add `amount` of coins from the `account` owning the StakePool.
pub fn encode_stake_add_stake(amount: u64) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("stake").to_owned(),
        ),
        ident_str!("add_stake").to_owned(),
        vec![],
        vec![bcs::to_bytes(&amount).unwrap()],
    ))
}

/// Similar to increase_lockup_with_cap but will use ownership capability from the signing account.
pub fn encode_stake_increase_lockup(new_locked_until_secs: u64) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("stake").to_owned(),
        ),
        ident_str!("increase_lockup").to_owned(),
        vec![],
        vec![bcs::to_bytes(&new_locked_until_secs).unwrap()],
    ))
}

/// This can only called by the operator of the validator/staking pool.
pub fn encode_stake_join_validator_set(pool_address: AccountAddress) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("stake").to_owned(),
        ),
        ident_str!("join_validator_set").to_owned(),
        vec![],
        vec![bcs::to_bytes(&pool_address).unwrap()],
    ))
}

/// Request to have `pool_address` leave the validator set. The validator is only actually removed from the set when
/// the next epoch starts.
/// The last validator in the set cannot leave. This is an edge case that should never happen as long as the network
/// is still operational.
///
/// Can only be called by the operator of the validator/staking pool.
pub fn encode_stake_leave_validator_set(pool_address: AccountAddress) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("stake").to_owned(),
        ),
        ident_str!("leave_validator_set").to_owned(),
        vec![],
        vec![bcs::to_bytes(&pool_address).unwrap()],
    ))
}

/// Initialize the validator account and give ownership to the signing account.
pub fn encode_stake_register_validator_candidate(
    consensus_pubkey: Vec<u8>,
    proof_of_possession: Vec<u8>,
    network_addresses: Vec<u8>,
    fullnode_addresses: Vec<u8>,
) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("stake").to_owned(),
        ),
        ident_str!("register_validator_candidate").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&consensus_pubkey).unwrap(),
            bcs::to_bytes(&proof_of_possession).unwrap(),
            bcs::to_bytes(&network_addresses).unwrap(),
            bcs::to_bytes(&fullnode_addresses).unwrap(),
        ],
    ))
}

/// Rotate the consensus key of the validator, it'll take effect in next epoch.
pub fn encode_stake_rotate_consensus_key(
    pool_address: AccountAddress,
    new_consensus_pubkey: Vec<u8>,
    proof_of_possession: Vec<u8>,
) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("stake").to_owned(),
        ),
        ident_str!("rotate_consensus_key").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&pool_address).unwrap(),
            bcs::to_bytes(&new_consensus_pubkey).unwrap(),
            bcs::to_bytes(&proof_of_possession).unwrap(),
        ],
    ))
}

/// Allows an owner to change the delegated voter of the stake pool.
pub fn encode_stake_set_delegated_voter(new_delegated_voter: AccountAddress) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("stake").to_owned(),
        ),
        ident_str!("set_delegated_voter").to_owned(),
        vec![],
        vec![bcs::to_bytes(&new_delegated_voter).unwrap()],
    ))
}

/// Allows an owner to change the operator of the stake pool.
pub fn encode_stake_set_operator(new_operator: AccountAddress) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("stake").to_owned(),
        ),
        ident_str!("set_operator").to_owned(),
        vec![],
        vec![bcs::to_bytes(&new_operator).unwrap()],
    ))
}

/// Similar to unlock_with_cap but will use ownership capability from the signing account.
pub fn encode_stake_unlock(amount: u64) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("stake").to_owned(),
        ),
        ident_str!("unlock").to_owned(),
        vec![],
        vec![bcs::to_bytes(&amount).unwrap()],
    ))
}

/// Update the network and full node addresses of the validator. This only takes effect in the next epoch.
pub fn encode_stake_update_network_and_fullnode_addresses(
    pool_address: AccountAddress,
    new_network_addresses: Vec<u8>,
    new_fullnode_addresses: Vec<u8>,
) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("stake").to_owned(),
        ),
        ident_str!("update_network_and_fullnode_addresses").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&pool_address).unwrap(),
            bcs::to_bytes(&new_network_addresses).unwrap(),
            bcs::to_bytes(&new_fullnode_addresses).unwrap(),
        ],
    ))
}

/// Withdraw from `account`'s inactive stake.
pub fn encode_stake_withdraw() -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("stake").to_owned(),
        ),
        ident_str!("withdraw").to_owned(),
        vec![],
        vec![],
    ))
}

/// Claim the delegated mint capability and destroy the delegated token.
pub fn encode_test_coin_claim_mint_capability() -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("test_coin").to_owned(),
        ),
        ident_str!("claim_mint_capability").to_owned(),
        vec![],
        vec![],
    ))
}

/// Create delegated token for the address so the account could claim MintCapability later.
pub fn encode_test_coin_delegate_mint_capability(to: AccountAddress) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("test_coin").to_owned(),
        ),
        ident_str!("delegate_mint_capability").to_owned(),
        vec![],
        vec![bcs::to_bytes(&to).unwrap()],
    ))
}

/// Create new test coins and deposit them into dst_addr's account.
pub fn encode_test_coin_mint(dst_addr: AccountAddress, amount: u64) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("test_coin").to_owned(),
        ),
        ident_str!("mint").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&dst_addr).unwrap(),
            bcs::to_bytes(&amount).unwrap(),
        ],
    ))
}

pub fn encode_token_create_limited_collection_script(
    name: Vec<u8>,
    description: Vec<u8>,
    uri: Vec<u8>,
    maximum: u64,
) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("token").to_owned(),
        ),
        ident_str!("create_limited_collection_script").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&name).unwrap(),
            bcs::to_bytes(&description).unwrap(),
            bcs::to_bytes(&uri).unwrap(),
            bcs::to_bytes(&maximum).unwrap(),
        ],
    ))
}

pub fn encode_token_create_limited_token_script(
    collection: Vec<u8>,
    name: Vec<u8>,
    description: Vec<u8>,
    monitor_supply: bool,
    initial_balance: u64,
    maximum: u64,
    uri: Vec<u8>,
    royalty_points_per_million: u64,
) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("token").to_owned(),
        ),
        ident_str!("create_limited_token_script").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&collection).unwrap(),
            bcs::to_bytes(&name).unwrap(),
            bcs::to_bytes(&description).unwrap(),
            bcs::to_bytes(&monitor_supply).unwrap(),
            bcs::to_bytes(&initial_balance).unwrap(),
            bcs::to_bytes(&maximum).unwrap(),
            bcs::to_bytes(&uri).unwrap(),
            bcs::to_bytes(&royalty_points_per_million).unwrap(),
        ],
    ))
}

pub fn encode_token_create_unlimited_collection_script(
    name: Vec<u8>,
    description: Vec<u8>,
    uri: Vec<u8>,
) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("token").to_owned(),
        ),
        ident_str!("create_unlimited_collection_script").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&name).unwrap(),
            bcs::to_bytes(&description).unwrap(),
            bcs::to_bytes(&uri).unwrap(),
        ],
    ))
}

pub fn encode_token_create_unlimited_token_script(
    collection: Vec<u8>,
    name: Vec<u8>,
    description: Vec<u8>,
    monitor_supply: bool,
    initial_balance: u64,
    uri: Vec<u8>,
    royalty_points_per_million: u64,
) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("token").to_owned(),
        ),
        ident_str!("create_unlimited_token_script").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&collection).unwrap(),
            bcs::to_bytes(&name).unwrap(),
            bcs::to_bytes(&description).unwrap(),
            bcs::to_bytes(&monitor_supply).unwrap(),
            bcs::to_bytes(&initial_balance).unwrap(),
            bcs::to_bytes(&uri).unwrap(),
            bcs::to_bytes(&royalty_points_per_million).unwrap(),
        ],
    ))
}

pub fn encode_token_direct_transfer_script(
    creators_address: AccountAddress,
    collection: Vec<u8>,
    name: Vec<u8>,
    amount: u64,
) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("token").to_owned(),
        ),
        ident_str!("direct_transfer_script").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&creators_address).unwrap(),
            bcs::to_bytes(&collection).unwrap(),
            bcs::to_bytes(&name).unwrap(),
            bcs::to_bytes(&amount).unwrap(),
        ],
    ))
}

pub fn encode_token_initialize_token_for_id(
    creators_address: AccountAddress,
    collection: Vec<u8>,
    name: Vec<u8>,
) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("token").to_owned(),
        ),
        ident_str!("initialize_token_for_id").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&creators_address).unwrap(),
            bcs::to_bytes(&collection).unwrap(),
            bcs::to_bytes(&name).unwrap(),
        ],
    ))
}

pub fn encode_token_initialize_token_script() -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("token").to_owned(),
        ),
        ident_str!("initialize_token_script").to_owned(),
        vec![],
        vec![],
    ))
}

pub fn encode_token_transfers_cancel_offer_script(
    receiver: AccountAddress,
    creator: AccountAddress,
    collection: Vec<u8>,
    name: Vec<u8>,
) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("token_transfers").to_owned(),
        ),
        ident_str!("cancel_offer_script").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&receiver).unwrap(),
            bcs::to_bytes(&creator).unwrap(),
            bcs::to_bytes(&collection).unwrap(),
            bcs::to_bytes(&name).unwrap(),
        ],
    ))
}

pub fn encode_token_transfers_claim_script(
    sender: AccountAddress,
    creator: AccountAddress,
    collection: Vec<u8>,
    name: Vec<u8>,
) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("token_transfers").to_owned(),
        ),
        ident_str!("claim_script").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&sender).unwrap(),
            bcs::to_bytes(&creator).unwrap(),
            bcs::to_bytes(&collection).unwrap(),
            bcs::to_bytes(&name).unwrap(),
        ],
    ))
}

pub fn encode_token_transfers_offer_script(
    receiver: AccountAddress,
    creator: AccountAddress,
    collection: Vec<u8>,
    name: Vec<u8>,
    amount: u64,
) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("token_transfers").to_owned(),
        ),
        ident_str!("offer_script").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&receiver).unwrap(),
            bcs::to_bytes(&creator).unwrap(),
            bcs::to_bytes(&collection).unwrap(),
            bcs::to_bytes(&name).unwrap(),
            bcs::to_bytes(&amount).unwrap(),
        ],
    ))
}

pub fn encode_transaction_publishing_option_set_module_publishing_allowed(
    is_allowed: bool,
) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("transaction_publishing_option").to_owned(),
        ),
        ident_str!("set_module_publishing_allowed").to_owned(),
        vec![],
        vec![bcs::to_bytes(&is_allowed).unwrap()],
    ))
}

pub fn encode_vm_config_set_gas_constants(
    global_memory_per_byte_cost: u64,
    global_memory_per_byte_write_cost: u64,
    min_transaction_gas_units: u64,
    large_transaction_cutoff: u64,
    intrinsic_gas_per_byte: u64,
    maximum_number_of_gas_units: u64,
    min_price_per_gas_unit: u64,
    max_price_per_gas_unit: u64,
    max_transaction_size_in_bytes: u64,
    gas_unit_scaling_factor: u64,
    default_account_size: u64,
) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("vm_config").to_owned(),
        ),
        ident_str!("set_gas_constants").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&global_memory_per_byte_cost).unwrap(),
            bcs::to_bytes(&global_memory_per_byte_write_cost).unwrap(),
            bcs::to_bytes(&min_transaction_gas_units).unwrap(),
            bcs::to_bytes(&large_transaction_cutoff).unwrap(),
            bcs::to_bytes(&intrinsic_gas_per_byte).unwrap(),
            bcs::to_bytes(&maximum_number_of_gas_units).unwrap(),
            bcs::to_bytes(&min_price_per_gas_unit).unwrap(),
            bcs::to_bytes(&max_price_per_gas_unit).unwrap(),
            bcs::to_bytes(&max_transaction_size_in_bytes).unwrap(),
            bcs::to_bytes(&gas_unit_scaling_factor).unwrap(),
            bcs::to_bytes(&default_account_size).unwrap(),
        ],
    ))
}

pub fn encode_validator_set_script_add_validator(
    _validator_addr: AccountAddress,
) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("validator_set_script").to_owned(),
        ),
        ident_str!("add_validator").to_owned(),
        vec![],
        vec![bcs::to_bytes(&_validator_addr).unwrap()],
    ))
}

pub fn encode_validator_set_script_create_validator_account(
    _new_account_address: AccountAddress,
    _human_name: Vec<u8>,
) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("validator_set_script").to_owned(),
        ),
        ident_str!("create_validator_account").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&_new_account_address).unwrap(),
            bcs::to_bytes(&_human_name).unwrap(),
        ],
    ))
}

pub fn encode_validator_set_script_create_validator_operator_account(
    _new_account_address: AccountAddress,
    _human_name: Vec<u8>,
) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("validator_set_script").to_owned(),
        ),
        ident_str!("create_validator_operator_account").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&_new_account_address).unwrap(),
            bcs::to_bytes(&_human_name).unwrap(),
        ],
    ))
}

pub fn encode_validator_set_script_register_validator_config(
    _validator_address: AccountAddress,
    _consensus_pubkey: Vec<u8>,
    _validator_network_addresses: Vec<u8>,
    _fullnode_network_addresses: Vec<u8>,
) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("validator_set_script").to_owned(),
        ),
        ident_str!("register_validator_config").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&_validator_address).unwrap(),
            bcs::to_bytes(&_consensus_pubkey).unwrap(),
            bcs::to_bytes(&_validator_network_addresses).unwrap(),
            bcs::to_bytes(&_fullnode_network_addresses).unwrap(),
        ],
    ))
}

pub fn encode_validator_set_script_remove_validator(
    _validator_addr: AccountAddress,
) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("validator_set_script").to_owned(),
        ),
        ident_str!("remove_validator").to_owned(),
        vec![],
        vec![bcs::to_bytes(&_validator_addr).unwrap()],
    ))
}

pub fn encode_validator_set_script_set_validator_config_and_reconfigure(
    _validator_account: AccountAddress,
    _consensus_pubkey: Vec<u8>,
    _validator_network_addresses: Vec<u8>,
    _fullnode_network_addresses: Vec<u8>,
) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("validator_set_script").to_owned(),
        ),
        ident_str!("set_validator_config_and_reconfigure").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&_validator_account).unwrap(),
            bcs::to_bytes(&_consensus_pubkey).unwrap(),
            bcs::to_bytes(&_validator_network_addresses).unwrap(),
            bcs::to_bytes(&_fullnode_network_addresses).unwrap(),
        ],
    ))
}

pub fn encode_validator_set_script_set_validator_operator(
    _operator_name: Vec<u8>,
    _operator_account: AccountAddress,
) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("validator_set_script").to_owned(),
        ),
        ident_str!("set_validator_operator").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&_operator_name).unwrap(),
            bcs::to_bytes(&_operator_account).unwrap(),
        ],
    ))
}

/// Updates the major version to a larger version.
pub fn encode_version_set_version(major: u64) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("version").to_owned(),
        ),
        ident_str!("set_version").to_owned(),
        vec![],
        vec![bcs::to_bytes(&major).unwrap()],
    ))
}

fn decode_account_create_account(payload: &TransactionPayload) -> Option<ScriptFunctionCall> {
    if let TransactionPayload::ScriptFunction(script) = payload {
        Some(ScriptFunctionCall::AccountCreateAccount {
            auth_key: bcs::from_bytes(script.args().get(0)?).ok()?,
        })
    } else {
        None
    }
}

fn decode_account_rotate_authentication_key(
    payload: &TransactionPayload,
) -> Option<ScriptFunctionCall> {
    if let TransactionPayload::ScriptFunction(script) = payload {
        Some(ScriptFunctionCall::AccountRotateAuthenticationKey {
            new_auth_key: bcs::from_bytes(script.args().get(0)?).ok()?,
        })
    } else {
        None
    }
}

fn decode_account_utils_create_and_fund_account(
    payload: &TransactionPayload,
) -> Option<ScriptFunctionCall> {
    if let TransactionPayload::ScriptFunction(script) = payload {
        Some(ScriptFunctionCall::AccountUtilsCreateAndFundAccount {
            account: bcs::from_bytes(script.args().get(0)?).ok()?,
            amount: bcs::from_bytes(script.args().get(1)?).ok()?,
        })
    } else {
        None
    }
}

fn decode_aptos_governance_create_proposal(
    payload: &TransactionPayload,
) -> Option<ScriptFunctionCall> {
    if let TransactionPayload::ScriptFunction(script) = payload {
        Some(ScriptFunctionCall::AptosGovernanceCreateProposal {
            stake_pool: bcs::from_bytes(script.args().get(0)?).ok()?,
            execution_hash: bcs::from_bytes(script.args().get(1)?).ok()?,
        })
    } else {
        None
    }
}

fn decode_aptos_governance_vote(payload: &TransactionPayload) -> Option<ScriptFunctionCall> {
    if let TransactionPayload::ScriptFunction(script) = payload {
        Some(ScriptFunctionCall::AptosGovernanceVote {
            stake_pool: bcs::from_bytes(script.args().get(0)?).ok()?,
            proposal_id: bcs::from_bytes(script.args().get(1)?).ok()?,
            should_pass: bcs::from_bytes(script.args().get(2)?).ok()?,
        })
    } else {
        None
    }
}

fn decode_reconfiguration_force_reconfigure(
    payload: &TransactionPayload,
) -> Option<ScriptFunctionCall> {
    if let TransactionPayload::ScriptFunction(_script) = payload {
        Some(ScriptFunctionCall::ReconfigurationForceReconfigure {})
    } else {
        None
    }
}

fn decode_resource_account_create_resource_account(
    payload: &TransactionPayload,
) -> Option<ScriptFunctionCall> {
    if let TransactionPayload::ScriptFunction(script) = payload {
        Some(ScriptFunctionCall::ResourceAccountCreateResourceAccount {
            seed: bcs::from_bytes(script.args().get(0)?).ok()?,
            optional_auth_key: bcs::from_bytes(script.args().get(1)?).ok()?,
        })
    } else {
        None
    }
}

fn decode_stake_add_stake(payload: &TransactionPayload) -> Option<ScriptFunctionCall> {
    if let TransactionPayload::ScriptFunction(script) = payload {
        Some(ScriptFunctionCall::StakeAddStake {
            amount: bcs::from_bytes(script.args().get(0)?).ok()?,
        })
    } else {
        None
    }
}

fn decode_stake_increase_lockup(payload: &TransactionPayload) -> Option<ScriptFunctionCall> {
    if let TransactionPayload::ScriptFunction(script) = payload {
        Some(ScriptFunctionCall::StakeIncreaseLockup {
            new_locked_until_secs: bcs::from_bytes(script.args().get(0)?).ok()?,
        })
    } else {
        None
    }
}

fn decode_stake_join_validator_set(payload: &TransactionPayload) -> Option<ScriptFunctionCall> {
    if let TransactionPayload::ScriptFunction(script) = payload {
        Some(ScriptFunctionCall::StakeJoinValidatorSet {
            pool_address: bcs::from_bytes(script.args().get(0)?).ok()?,
        })
    } else {
        None
    }
}

fn decode_stake_leave_validator_set(payload: &TransactionPayload) -> Option<ScriptFunctionCall> {
    if let TransactionPayload::ScriptFunction(script) = payload {
        Some(ScriptFunctionCall::StakeLeaveValidatorSet {
            pool_address: bcs::from_bytes(script.args().get(0)?).ok()?,
        })
    } else {
        None
    }
}

fn decode_stake_register_validator_candidate(
    payload: &TransactionPayload,
) -> Option<ScriptFunctionCall> {
    if let TransactionPayload::ScriptFunction(script) = payload {
        Some(ScriptFunctionCall::StakeRegisterValidatorCandidate {
            consensus_pubkey: bcs::from_bytes(script.args().get(0)?).ok()?,
            proof_of_possession: bcs::from_bytes(script.args().get(1)?).ok()?,
            network_addresses: bcs::from_bytes(script.args().get(2)?).ok()?,
            fullnode_addresses: bcs::from_bytes(script.args().get(3)?).ok()?,
        })
    } else {
        None
    }
}

fn decode_stake_rotate_consensus_key(payload: &TransactionPayload) -> Option<ScriptFunctionCall> {
    if let TransactionPayload::ScriptFunction(script) = payload {
        Some(ScriptFunctionCall::StakeRotateConsensusKey {
            pool_address: bcs::from_bytes(script.args().get(0)?).ok()?,
            new_consensus_pubkey: bcs::from_bytes(script.args().get(1)?).ok()?,
            proof_of_possession: bcs::from_bytes(script.args().get(2)?).ok()?,
        })
    } else {
        None
    }
}

fn decode_stake_set_delegated_voter(payload: &TransactionPayload) -> Option<ScriptFunctionCall> {
    if let TransactionPayload::ScriptFunction(script) = payload {
        Some(ScriptFunctionCall::StakeSetDelegatedVoter {
            new_delegated_voter: bcs::from_bytes(script.args().get(0)?).ok()?,
        })
    } else {
        None
    }
}

fn decode_stake_set_operator(payload: &TransactionPayload) -> Option<ScriptFunctionCall> {
    if let TransactionPayload::ScriptFunction(script) = payload {
        Some(ScriptFunctionCall::StakeSetOperator {
            new_operator: bcs::from_bytes(script.args().get(0)?).ok()?,
        })
    } else {
        None
    }
}

fn decode_stake_unlock(payload: &TransactionPayload) -> Option<ScriptFunctionCall> {
    if let TransactionPayload::ScriptFunction(script) = payload {
        Some(ScriptFunctionCall::StakeUnlock {
            amount: bcs::from_bytes(script.args().get(0)?).ok()?,
        })
    } else {
        None
    }
}

fn decode_stake_update_network_and_fullnode_addresses(
    payload: &TransactionPayload,
) -> Option<ScriptFunctionCall> {
    if let TransactionPayload::ScriptFunction(script) = payload {
        Some(ScriptFunctionCall::StakeUpdateNetworkAndFullnodeAddresses {
            pool_address: bcs::from_bytes(script.args().get(0)?).ok()?,
            new_network_addresses: bcs::from_bytes(script.args().get(1)?).ok()?,
            new_fullnode_addresses: bcs::from_bytes(script.args().get(2)?).ok()?,
        })
    } else {
        None
    }
}

fn decode_stake_withdraw(payload: &TransactionPayload) -> Option<ScriptFunctionCall> {
    if let TransactionPayload::ScriptFunction(_script) = payload {
        Some(ScriptFunctionCall::StakeWithdraw {})
    } else {
        None
    }
}

fn decode_test_coin_claim_mint_capability(
    payload: &TransactionPayload,
) -> Option<ScriptFunctionCall> {
    if let TransactionPayload::ScriptFunction(_script) = payload {
        Some(ScriptFunctionCall::TestCoinClaimMintCapability {})
    } else {
        None
    }
}

fn decode_test_coin_delegate_mint_capability(
    payload: &TransactionPayload,
) -> Option<ScriptFunctionCall> {
    if let TransactionPayload::ScriptFunction(script) = payload {
        Some(ScriptFunctionCall::TestCoinDelegateMintCapability {
            to: bcs::from_bytes(script.args().get(0)?).ok()?,
        })
    } else {
        None
    }
}

fn decode_test_coin_mint(payload: &TransactionPayload) -> Option<ScriptFunctionCall> {
    if let TransactionPayload::ScriptFunction(script) = payload {
        Some(ScriptFunctionCall::TestCoinMint {
            dst_addr: bcs::from_bytes(script.args().get(0)?).ok()?,
            amount: bcs::from_bytes(script.args().get(1)?).ok()?,
        })
    } else {
        None
    }
}

fn decode_token_create_limited_collection_script(
    payload: &TransactionPayload,
) -> Option<ScriptFunctionCall> {
    if let TransactionPayload::ScriptFunction(script) = payload {
        Some(ScriptFunctionCall::TokenCreateLimitedCollectionScript {
            name: bcs::from_bytes(script.args().get(0)?).ok()?,
            description: bcs::from_bytes(script.args().get(1)?).ok()?,
            uri: bcs::from_bytes(script.args().get(2)?).ok()?,
            maximum: bcs::from_bytes(script.args().get(3)?).ok()?,
        })
    } else {
        None
    }
}

fn decode_token_create_limited_token_script(
    payload: &TransactionPayload,
) -> Option<ScriptFunctionCall> {
    if let TransactionPayload::ScriptFunction(script) = payload {
        Some(ScriptFunctionCall::TokenCreateLimitedTokenScript {
            collection: bcs::from_bytes(script.args().get(0)?).ok()?,
            name: bcs::from_bytes(script.args().get(1)?).ok()?,
            description: bcs::from_bytes(script.args().get(2)?).ok()?,
            monitor_supply: bcs::from_bytes(script.args().get(3)?).ok()?,
            initial_balance: bcs::from_bytes(script.args().get(4)?).ok()?,
            maximum: bcs::from_bytes(script.args().get(5)?).ok()?,
            uri: bcs::from_bytes(script.args().get(6)?).ok()?,
            royalty_points_per_million: bcs::from_bytes(script.args().get(7)?).ok()?,
        })
    } else {
        None
    }
}

fn decode_token_create_unlimited_collection_script(
    payload: &TransactionPayload,
) -> Option<ScriptFunctionCall> {
    if let TransactionPayload::ScriptFunction(script) = payload {
        Some(ScriptFunctionCall::TokenCreateUnlimitedCollectionScript {
            name: bcs::from_bytes(script.args().get(0)?).ok()?,
            description: bcs::from_bytes(script.args().get(1)?).ok()?,
            uri: bcs::from_bytes(script.args().get(2)?).ok()?,
        })
    } else {
        None
    }
}

fn decode_token_create_unlimited_token_script(
    payload: &TransactionPayload,
) -> Option<ScriptFunctionCall> {
    if let TransactionPayload::ScriptFunction(script) = payload {
        Some(ScriptFunctionCall::TokenCreateUnlimitedTokenScript {
            collection: bcs::from_bytes(script.args().get(0)?).ok()?,
            name: bcs::from_bytes(script.args().get(1)?).ok()?,
            description: bcs::from_bytes(script.args().get(2)?).ok()?,
            monitor_supply: bcs::from_bytes(script.args().get(3)?).ok()?,
            initial_balance: bcs::from_bytes(script.args().get(4)?).ok()?,
            uri: bcs::from_bytes(script.args().get(5)?).ok()?,
            royalty_points_per_million: bcs::from_bytes(script.args().get(6)?).ok()?,
        })
    } else {
        None
    }
}

fn decode_token_direct_transfer_script(payload: &TransactionPayload) -> Option<ScriptFunctionCall> {
    if let TransactionPayload::ScriptFunction(script) = payload {
        Some(ScriptFunctionCall::TokenDirectTransferScript {
            creators_address: bcs::from_bytes(script.args().get(0)?).ok()?,
            collection: bcs::from_bytes(script.args().get(1)?).ok()?,
            name: bcs::from_bytes(script.args().get(2)?).ok()?,
            amount: bcs::from_bytes(script.args().get(3)?).ok()?,
        })
    } else {
        None
    }
}

fn decode_token_initialize_token_for_id(
    payload: &TransactionPayload,
) -> Option<ScriptFunctionCall> {
    if let TransactionPayload::ScriptFunction(script) = payload {
        Some(ScriptFunctionCall::TokenInitializeTokenForId {
            creators_address: bcs::from_bytes(script.args().get(0)?).ok()?,
            collection: bcs::from_bytes(script.args().get(1)?).ok()?,
            name: bcs::from_bytes(script.args().get(2)?).ok()?,
        })
    } else {
        None
    }
}

fn decode_token_initialize_token_script(
    payload: &TransactionPayload,
) -> Option<ScriptFunctionCall> {
    if let TransactionPayload::ScriptFunction(_script) = payload {
        Some(ScriptFunctionCall::TokenInitializeTokenScript {})
    } else {
        None
    }
}

fn decode_token_transfers_cancel_offer_script(
    payload: &TransactionPayload,
) -> Option<ScriptFunctionCall> {
    if let TransactionPayload::ScriptFunction(script) = payload {
        Some(ScriptFunctionCall::TokenTransfersCancelOfferScript {
            receiver: bcs::from_bytes(script.args().get(0)?).ok()?,
            creator: bcs::from_bytes(script.args().get(1)?).ok()?,
            collection: bcs::from_bytes(script.args().get(2)?).ok()?,
            name: bcs::from_bytes(script.args().get(3)?).ok()?,
        })
    } else {
        None
    }
}

fn decode_token_transfers_claim_script(payload: &TransactionPayload) -> Option<ScriptFunctionCall> {
    if let TransactionPayload::ScriptFunction(script) = payload {
        Some(ScriptFunctionCall::TokenTransfersClaimScript {
            sender: bcs::from_bytes(script.args().get(0)?).ok()?,
            creator: bcs::from_bytes(script.args().get(1)?).ok()?,
            collection: bcs::from_bytes(script.args().get(2)?).ok()?,
            name: bcs::from_bytes(script.args().get(3)?).ok()?,
        })
    } else {
        None
    }
}

fn decode_token_transfers_offer_script(payload: &TransactionPayload) -> Option<ScriptFunctionCall> {
    if let TransactionPayload::ScriptFunction(script) = payload {
        Some(ScriptFunctionCall::TokenTransfersOfferScript {
            receiver: bcs::from_bytes(script.args().get(0)?).ok()?,
            creator: bcs::from_bytes(script.args().get(1)?).ok()?,
            collection: bcs::from_bytes(script.args().get(2)?).ok()?,
            name: bcs::from_bytes(script.args().get(3)?).ok()?,
            amount: bcs::from_bytes(script.args().get(4)?).ok()?,
        })
    } else {
        None
    }
}

fn decode_transaction_publishing_option_set_module_publishing_allowed(
    payload: &TransactionPayload,
) -> Option<ScriptFunctionCall> {
    if let TransactionPayload::ScriptFunction(script) = payload {
        Some(
            ScriptFunctionCall::TransactionPublishingOptionSetModulePublishingAllowed {
                is_allowed: bcs::from_bytes(script.args().get(0)?).ok()?,
            },
        )
    } else {
        None
    }
}

fn decode_vm_config_set_gas_constants(payload: &TransactionPayload) -> Option<ScriptFunctionCall> {
    if let TransactionPayload::ScriptFunction(script) = payload {
        Some(ScriptFunctionCall::VMConfigSetGasConstants {
            global_memory_per_byte_cost: bcs::from_bytes(script.args().get(0)?).ok()?,
            global_memory_per_byte_write_cost: bcs::from_bytes(script.args().get(1)?).ok()?,
            min_transaction_gas_units: bcs::from_bytes(script.args().get(2)?).ok()?,
            large_transaction_cutoff: bcs::from_bytes(script.args().get(3)?).ok()?,
            intrinsic_gas_per_byte: bcs::from_bytes(script.args().get(4)?).ok()?,
            maximum_number_of_gas_units: bcs::from_bytes(script.args().get(5)?).ok()?,
            min_price_per_gas_unit: bcs::from_bytes(script.args().get(6)?).ok()?,
            max_price_per_gas_unit: bcs::from_bytes(script.args().get(7)?).ok()?,
            max_transaction_size_in_bytes: bcs::from_bytes(script.args().get(8)?).ok()?,
            gas_unit_scaling_factor: bcs::from_bytes(script.args().get(9)?).ok()?,
            default_account_size: bcs::from_bytes(script.args().get(10)?).ok()?,
        })
    } else {
        None
    }
}

fn decode_validator_set_script_add_validator(
    payload: &TransactionPayload,
) -> Option<ScriptFunctionCall> {
    if let TransactionPayload::ScriptFunction(script) = payload {
        Some(ScriptFunctionCall::ValidatorSetScriptAddValidator {
            _validator_addr: bcs::from_bytes(script.args().get(0)?).ok()?,
        })
    } else {
        None
    }
}

fn decode_validator_set_script_create_validator_account(
    payload: &TransactionPayload,
) -> Option<ScriptFunctionCall> {
    if let TransactionPayload::ScriptFunction(script) = payload {
        Some(
            ScriptFunctionCall::ValidatorSetScriptCreateValidatorAccount {
                _new_account_address: bcs::from_bytes(script.args().get(0)?).ok()?,
                _human_name: bcs::from_bytes(script.args().get(1)?).ok()?,
            },
        )
    } else {
        None
    }
}

fn decode_validator_set_script_create_validator_operator_account(
    payload: &TransactionPayload,
) -> Option<ScriptFunctionCall> {
    if let TransactionPayload::ScriptFunction(script) = payload {
        Some(
            ScriptFunctionCall::ValidatorSetScriptCreateValidatorOperatorAccount {
                _new_account_address: bcs::from_bytes(script.args().get(0)?).ok()?,
                _human_name: bcs::from_bytes(script.args().get(1)?).ok()?,
            },
        )
    } else {
        None
    }
}

fn decode_validator_set_script_register_validator_config(
    payload: &TransactionPayload,
) -> Option<ScriptFunctionCall> {
    if let TransactionPayload::ScriptFunction(script) = payload {
        Some(
            ScriptFunctionCall::ValidatorSetScriptRegisterValidatorConfig {
                _validator_address: bcs::from_bytes(script.args().get(0)?).ok()?,
                _consensus_pubkey: bcs::from_bytes(script.args().get(1)?).ok()?,
                _validator_network_addresses: bcs::from_bytes(script.args().get(2)?).ok()?,
                _fullnode_network_addresses: bcs::from_bytes(script.args().get(3)?).ok()?,
            },
        )
    } else {
        None
    }
}

fn decode_validator_set_script_remove_validator(
    payload: &TransactionPayload,
) -> Option<ScriptFunctionCall> {
    if let TransactionPayload::ScriptFunction(script) = payload {
        Some(ScriptFunctionCall::ValidatorSetScriptRemoveValidator {
            _validator_addr: bcs::from_bytes(script.args().get(0)?).ok()?,
        })
    } else {
        None
    }
}

fn decode_validator_set_script_set_validator_config_and_reconfigure(
    payload: &TransactionPayload,
) -> Option<ScriptFunctionCall> {
    if let TransactionPayload::ScriptFunction(script) = payload {
        Some(
            ScriptFunctionCall::ValidatorSetScriptSetValidatorConfigAndReconfigure {
                _validator_account: bcs::from_bytes(script.args().get(0)?).ok()?,
                _consensus_pubkey: bcs::from_bytes(script.args().get(1)?).ok()?,
                _validator_network_addresses: bcs::from_bytes(script.args().get(2)?).ok()?,
                _fullnode_network_addresses: bcs::from_bytes(script.args().get(3)?).ok()?,
            },
        )
    } else {
        None
    }
}

fn decode_validator_set_script_set_validator_operator(
    payload: &TransactionPayload,
) -> Option<ScriptFunctionCall> {
    if let TransactionPayload::ScriptFunction(script) = payload {
        Some(ScriptFunctionCall::ValidatorSetScriptSetValidatorOperator {
            _operator_name: bcs::from_bytes(script.args().get(0)?).ok()?,
            _operator_account: bcs::from_bytes(script.args().get(1)?).ok()?,
        })
    } else {
        None
    }
}

fn decode_version_set_version(payload: &TransactionPayload) -> Option<ScriptFunctionCall> {
    if let TransactionPayload::ScriptFunction(script) = payload {
        Some(ScriptFunctionCall::VersionSetVersion {
            major: bcs::from_bytes(script.args().get(0)?).ok()?,
        })
    } else {
        None
    }
}

type ScriptFunctionDecoderMap = std::collections::HashMap<
    String,
    Box<
        dyn Fn(&TransactionPayload) -> Option<ScriptFunctionCall>
            + std::marker::Sync
            + std::marker::Send,
    >,
>;

static SCRIPT_FUNCTION_DECODER_MAP: once_cell::sync::Lazy<ScriptFunctionDecoderMap> =
    once_cell::sync::Lazy::new(|| {
        let mut map: ScriptFunctionDecoderMap = std::collections::HashMap::new();
        map.insert(
            "accountcreate_account".to_string(),
            Box::new(decode_account_create_account),
        );
        map.insert(
            "accountrotate_authentication_key".to_string(),
            Box::new(decode_account_rotate_authentication_key),
        );
        map.insert(
            "account_utilscreate_and_fund_account".to_string(),
            Box::new(decode_account_utils_create_and_fund_account),
        );
        map.insert(
            "aptos_governancecreate_proposal".to_string(),
            Box::new(decode_aptos_governance_create_proposal),
        );
        map.insert(
            "aptos_governancevote".to_string(),
            Box::new(decode_aptos_governance_vote),
        );
        map.insert(
            "reconfigurationforce_reconfigure".to_string(),
            Box::new(decode_reconfiguration_force_reconfigure),
        );
        map.insert(
            "resource_accountcreate_resource_account".to_string(),
            Box::new(decode_resource_account_create_resource_account),
        );
        map.insert(
            "stakeadd_stake".to_string(),
            Box::new(decode_stake_add_stake),
        );
        map.insert(
            "stakeincrease_lockup".to_string(),
            Box::new(decode_stake_increase_lockup),
        );
        map.insert(
            "stakejoin_validator_set".to_string(),
            Box::new(decode_stake_join_validator_set),
        );
        map.insert(
            "stakeleave_validator_set".to_string(),
            Box::new(decode_stake_leave_validator_set),
        );
        map.insert(
            "stakeregister_validator_candidate".to_string(),
            Box::new(decode_stake_register_validator_candidate),
        );
        map.insert(
            "stakerotate_consensus_key".to_string(),
            Box::new(decode_stake_rotate_consensus_key),
        );
        map.insert(
            "stakeset_delegated_voter".to_string(),
            Box::new(decode_stake_set_delegated_voter),
        );
        map.insert(
            "stakeset_operator".to_string(),
            Box::new(decode_stake_set_operator),
        );
        map.insert("stakeunlock".to_string(), Box::new(decode_stake_unlock));
        map.insert(
            "stakeupdate_network_and_fullnode_addresses".to_string(),
            Box::new(decode_stake_update_network_and_fullnode_addresses),
        );
        map.insert("stakewithdraw".to_string(), Box::new(decode_stake_withdraw));
        map.insert(
            "test_coinclaim_mint_capability".to_string(),
            Box::new(decode_test_coin_claim_mint_capability),
        );
        map.insert(
            "test_coindelegate_mint_capability".to_string(),
            Box::new(decode_test_coin_delegate_mint_capability),
        );
        map.insert("test_coinmint".to_string(), Box::new(decode_test_coin_mint));
        map.insert(
            "tokencreate_limited_collection_script".to_string(),
            Box::new(decode_token_create_limited_collection_script),
        );
        map.insert(
            "tokencreate_limited_token_script".to_string(),
            Box::new(decode_token_create_limited_token_script),
        );
        map.insert(
            "tokencreate_unlimited_collection_script".to_string(),
            Box::new(decode_token_create_unlimited_collection_script),
        );
        map.insert(
            "tokencreate_unlimited_token_script".to_string(),
            Box::new(decode_token_create_unlimited_token_script),
        );
        map.insert(
            "tokendirect_transfer_script".to_string(),
            Box::new(decode_token_direct_transfer_script),
        );
        map.insert(
            "tokeninitialize_token_for_id".to_string(),
            Box::new(decode_token_initialize_token_for_id),
        );
        map.insert(
            "tokeninitialize_token_script".to_string(),
            Box::new(decode_token_initialize_token_script),
        );
        map.insert(
            "tokenTransferscancel_offer_script".to_string(),
            Box::new(decode_token_transfers_cancel_offer_script),
        );
        map.insert(
            "tokenTransfersclaim_script".to_string(),
            Box::new(decode_token_transfers_claim_script),
        );
        map.insert(
            "tokenTransfersoffer_script".to_string(),
            Box::new(decode_token_transfers_offer_script),
        );
        map.insert(
            "transaction_publishing_optionset_module_publishing_allowed".to_string(),
            Box::new(decode_transaction_publishing_option_set_module_publishing_allowed),
        );
        map.insert(
            "vm_configset_gas_constants".to_string(),
            Box::new(decode_vm_config_set_gas_constants),
        );
        map.insert(
            "ValidatorSetScriptadd_validator".to_string(),
            Box::new(decode_validator_set_script_add_validator),
        );
        map.insert(
            "validator_setScriptcreate_validator_account".to_string(),
            Box::new(decode_validator_set_script_create_validator_account),
        );
        map.insert(
            "validator_setScriptcreate_validator_operator_account".to_string(),
            Box::new(decode_validator_set_script_create_validator_operator_account),
        );
        map.insert(
            "validator_setScriptregister_validator_config".to_string(),
            Box::new(decode_validator_set_script_register_validator_config),
        );
        map.insert(
            "validator_setScriptremove_validator".to_string(),
            Box::new(decode_validator_set_script_remove_validator),
        );
        map.insert(
            "validator_setScriptset_validator_config_and_reconfigure".to_string(),
            Box::new(decode_validator_set_script_set_validator_config_and_reconfigure),
        );
        map.insert(
            "validator_setScriptset_validator_operator".to_string(),
            Box::new(decode_validator_set_script_set_validator_operator),
        );
        map.insert(
            "versionset_version".to_string(),
            Box::new(decode_version_set_version),
        );
        map
    });
