// Copyright (c) Aptos
// SPDX-License-Identifier: Apache-2.0

// This file is generated by rust-protobuf 3.1.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `src/protos/extractor.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_1_0;

///  Transaction is actually right what will be transported inside the Firehose's Block envelope.
///  meaning we get a 1 transaction == 1 block mapping.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:Transaction)
pub struct Transaction {
    // message fields
    // @@protoc_insertion_point(field:Transaction.timestamp)
    pub timestamp: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    // @@protoc_insertion_point(field:Transaction.version)
    pub version: u64,
    // @@protoc_insertion_point(field:Transaction.info)
    pub info: ::protobuf::MessageField<TransactionInfo>,
    // @@protoc_insertion_point(field:Transaction.epoch)
    pub epoch: u64,
    // @@protoc_insertion_point(field:Transaction.block_height)
    pub block_height: u64,
    // @@protoc_insertion_point(field:Transaction.type)
    pub type_: ::protobuf::EnumOrUnknown<transaction::TransactionType>,
    // message oneof groups
    pub txn_data: ::std::option::Option<transaction::Txn_data>,
    // special fields
    // @@protoc_insertion_point(special_field:Transaction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Transaction {
    fn default() -> &'a Transaction {
        <Transaction as ::protobuf::Message>::default_instance()
    }
}

impl Transaction {
    pub fn new() -> Transaction {
        ::std::default::Default::default()
    }

    // .BlockMetadataTransaction block_metadata = 7;

    pub fn block_metadata(&self) -> &BlockMetadataTransaction {
        match self.txn_data {
            ::std::option::Option::Some(transaction::Txn_data::BlockMetadata(ref v)) => v,
            _ => <BlockMetadataTransaction as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_block_metadata(&mut self) {
        self.txn_data = ::std::option::Option::None;
    }

    pub fn has_block_metadata(&self) -> bool {
        match self.txn_data {
            ::std::option::Option::Some(transaction::Txn_data::BlockMetadata(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_block_metadata(&mut self, v: BlockMetadataTransaction) {
        self.txn_data = ::std::option::Option::Some(transaction::Txn_data::BlockMetadata(v))
    }

    // Mutable pointer to the field.
    pub fn mut_block_metadata(&mut self) -> &mut BlockMetadataTransaction {
        if let ::std::option::Option::Some(transaction::Txn_data::BlockMetadata(_)) = self.txn_data {
        } else {
            self.txn_data = ::std::option::Option::Some(transaction::Txn_data::BlockMetadata(BlockMetadataTransaction::new()));
        }
        match self.txn_data {
            ::std::option::Option::Some(transaction::Txn_data::BlockMetadata(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_block_metadata(&mut self) -> BlockMetadataTransaction {
        if self.has_block_metadata() {
            match self.txn_data.take() {
                ::std::option::Option::Some(transaction::Txn_data::BlockMetadata(v)) => v,
                _ => panic!(),
            }
        } else {
            BlockMetadataTransaction::new()
        }
    }

    // .GenesisTransaction genesis = 8;

    pub fn genesis(&self) -> &GenesisTransaction {
        match self.txn_data {
            ::std::option::Option::Some(transaction::Txn_data::Genesis(ref v)) => v,
            _ => <GenesisTransaction as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_genesis(&mut self) {
        self.txn_data = ::std::option::Option::None;
    }

    pub fn has_genesis(&self) -> bool {
        match self.txn_data {
            ::std::option::Option::Some(transaction::Txn_data::Genesis(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_genesis(&mut self, v: GenesisTransaction) {
        self.txn_data = ::std::option::Option::Some(transaction::Txn_data::Genesis(v))
    }

    // Mutable pointer to the field.
    pub fn mut_genesis(&mut self) -> &mut GenesisTransaction {
        if let ::std::option::Option::Some(transaction::Txn_data::Genesis(_)) = self.txn_data {
        } else {
            self.txn_data = ::std::option::Option::Some(transaction::Txn_data::Genesis(GenesisTransaction::new()));
        }
        match self.txn_data {
            ::std::option::Option::Some(transaction::Txn_data::Genesis(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_genesis(&mut self) -> GenesisTransaction {
        if self.has_genesis() {
            match self.txn_data.take() {
                ::std::option::Option::Some(transaction::Txn_data::Genesis(v)) => v,
                _ => panic!(),
            }
        } else {
            GenesisTransaction::new()
        }
    }

    // .StateCheckpointTransaction state_checkpoint = 9;

    pub fn state_checkpoint(&self) -> &StateCheckpointTransaction {
        match self.txn_data {
            ::std::option::Option::Some(transaction::Txn_data::StateCheckpoint(ref v)) => v,
            _ => <StateCheckpointTransaction as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_state_checkpoint(&mut self) {
        self.txn_data = ::std::option::Option::None;
    }

    pub fn has_state_checkpoint(&self) -> bool {
        match self.txn_data {
            ::std::option::Option::Some(transaction::Txn_data::StateCheckpoint(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_state_checkpoint(&mut self, v: StateCheckpointTransaction) {
        self.txn_data = ::std::option::Option::Some(transaction::Txn_data::StateCheckpoint(v))
    }

    // Mutable pointer to the field.
    pub fn mut_state_checkpoint(&mut self) -> &mut StateCheckpointTransaction {
        if let ::std::option::Option::Some(transaction::Txn_data::StateCheckpoint(_)) = self.txn_data {
        } else {
            self.txn_data = ::std::option::Option::Some(transaction::Txn_data::StateCheckpoint(StateCheckpointTransaction::new()));
        }
        match self.txn_data {
            ::std::option::Option::Some(transaction::Txn_data::StateCheckpoint(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_state_checkpoint(&mut self) -> StateCheckpointTransaction {
        if self.has_state_checkpoint() {
            match self.txn_data.take() {
                ::std::option::Option::Some(transaction::Txn_data::StateCheckpoint(v)) => v,
                _ => panic!(),
            }
        } else {
            StateCheckpointTransaction::new()
        }
    }

    // .UserTransaction user = 10;

    pub fn user(&self) -> &UserTransaction {
        match self.txn_data {
            ::std::option::Option::Some(transaction::Txn_data::User(ref v)) => v,
            _ => <UserTransaction as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_user(&mut self) {
        self.txn_data = ::std::option::Option::None;
    }

    pub fn has_user(&self) -> bool {
        match self.txn_data {
            ::std::option::Option::Some(transaction::Txn_data::User(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: UserTransaction) {
        self.txn_data = ::std::option::Option::Some(transaction::Txn_data::User(v))
    }

    // Mutable pointer to the field.
    pub fn mut_user(&mut self) -> &mut UserTransaction {
        if let ::std::option::Option::Some(transaction::Txn_data::User(_)) = self.txn_data {
        } else {
            self.txn_data = ::std::option::Option::Some(transaction::Txn_data::User(UserTransaction::new()));
        }
        match self.txn_data {
            ::std::option::Option::Some(transaction::Txn_data::User(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_user(&mut self) -> UserTransaction {
        if self.has_user() {
            match self.txn_data.take() {
                ::std::option::Option::Some(transaction::Txn_data::User(v)) => v,
                _ => panic!(),
            }
        } else {
            UserTransaction::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "timestamp",
            |m: &Transaction| { &m.timestamp },
            |m: &mut Transaction| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version",
            |m: &Transaction| { &m.version },
            |m: &mut Transaction| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TransactionInfo>(
            "info",
            |m: &Transaction| { &m.info },
            |m: &mut Transaction| { &mut m.info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "epoch",
            |m: &Transaction| { &m.epoch },
            |m: &mut Transaction| { &mut m.epoch },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "block_height",
            |m: &Transaction| { &m.block_height },
            |m: &mut Transaction| { &mut m.block_height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &Transaction| { &m.type_ },
            |m: &mut Transaction| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, BlockMetadataTransaction>(
            "block_metadata",
            Transaction::has_block_metadata,
            Transaction::block_metadata,
            Transaction::mut_block_metadata,
            Transaction::set_block_metadata,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, GenesisTransaction>(
            "genesis",
            Transaction::has_genesis,
            Transaction::genesis,
            Transaction::mut_genesis,
            Transaction::set_genesis,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, StateCheckpointTransaction>(
            "state_checkpoint",
            Transaction::has_state_checkpoint,
            Transaction::state_checkpoint,
            Transaction::mut_state_checkpoint,
            Transaction::set_state_checkpoint,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, UserTransaction>(
            "user",
            Transaction::has_user,
            Transaction::user,
            Transaction::mut_user,
            Transaction::set_user,
        ));
        oneofs.push(transaction::Txn_data::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Transaction>(
            "Transaction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Transaction {
    const NAME: &'static str = "Transaction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.timestamp)?;
                },
                16 => {
                    self.version = is.read_uint64()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.info)?;
                },
                32 => {
                    self.epoch = is.read_uint64()?;
                },
                40 => {
                    self.block_height = is.read_uint64()?;
                },
                48 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                58 => {
                    self.txn_data = ::std::option::Option::Some(transaction::Txn_data::BlockMetadata(is.read_message()?));
                },
                66 => {
                    self.txn_data = ::std::option::Option::Some(transaction::Txn_data::Genesis(is.read_message()?));
                },
                74 => {
                    self.txn_data = ::std::option::Option::Some(transaction::Txn_data::StateCheckpoint(is.read_message()?));
                },
                82 => {
                    self.txn_data = ::std::option::Option::Some(transaction::Txn_data::User(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.timestamp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.version != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.version);
        }
        if let Some(v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.epoch != 0 {
            my_size += ::protobuf::rt::uint64_size(4, self.epoch);
        }
        if self.block_height != 0 {
            my_size += ::protobuf::rt::uint64_size(5, self.block_height);
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(transaction::TransactionType::GENESIS) {
            my_size += ::protobuf::rt::int32_size(6, self.type_.value());
        }
        if let ::std::option::Option::Some(ref v) = self.txn_data {
            match v {
                &transaction::Txn_data::BlockMetadata(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &transaction::Txn_data::Genesis(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &transaction::Txn_data::StateCheckpoint(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &transaction::Txn_data::User(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.timestamp.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.version != 0 {
            os.write_uint64(2, self.version)?;
        }
        if let Some(v) = self.info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if self.epoch != 0 {
            os.write_uint64(4, self.epoch)?;
        }
        if self.block_height != 0 {
            os.write_uint64(5, self.block_height)?;
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(transaction::TransactionType::GENESIS) {
            os.write_enum(6, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if let ::std::option::Option::Some(ref v) = self.txn_data {
            match v {
                &transaction::Txn_data::BlockMetadata(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
                &transaction::Txn_data::Genesis(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
                },
                &transaction::Txn_data::StateCheckpoint(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
                },
                &transaction::Txn_data::User(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Transaction {
        Transaction::new()
    }

    fn clear(&mut self) {
        self.timestamp.clear();
        self.version = 0;
        self.info.clear();
        self.epoch = 0;
        self.block_height = 0;
        self.type_ = ::protobuf::EnumOrUnknown::new(transaction::TransactionType::GENESIS);
        self.txn_data = ::std::option::Option::None;
        self.txn_data = ::std::option::Option::None;
        self.txn_data = ::std::option::Option::None;
        self.txn_data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Transaction {
        static instance: Transaction = Transaction {
            timestamp: ::protobuf::MessageField::none(),
            version: 0,
            info: ::protobuf::MessageField::none(),
            epoch: 0,
            block_height: 0,
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            txn_data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Transaction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Transaction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Transaction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Transaction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Transaction`
pub mod transaction {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:Transaction.txn_data)
    pub enum Txn_data {
        // @@protoc_insertion_point(oneof_field:Transaction.block_metadata)
        BlockMetadata(super::BlockMetadataTransaction),
        // @@protoc_insertion_point(oneof_field:Transaction.genesis)
        Genesis(super::GenesisTransaction),
        // @@protoc_insertion_point(oneof_field:Transaction.state_checkpoint)
        StateCheckpoint(super::StateCheckpointTransaction),
        // @@protoc_insertion_point(oneof_field:Transaction.user)
        User(super::UserTransaction),
    }

    impl ::protobuf::Oneof for Txn_data {
    }

    impl ::protobuf::OneofFull for Txn_data {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::Transaction as ::protobuf::MessageFull>::descriptor().oneof_by_name("txn_data").unwrap()).clone()
        }
    }

    impl Txn_data {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Txn_data>("txn_data")
        }
    }
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:Transaction.TransactionType)
    pub enum TransactionType {
        // @@protoc_insertion_point(enum_value:Transaction.TransactionType.GENESIS)
        GENESIS = 0,
        // @@protoc_insertion_point(enum_value:Transaction.TransactionType.BLOCK_METADATA)
        BLOCK_METADATA = 1,
        // @@protoc_insertion_point(enum_value:Transaction.TransactionType.STATE_CHECKPOINT)
        STATE_CHECKPOINT = 2,
        // @@protoc_insertion_point(enum_value:Transaction.TransactionType.USER)
        USER = 3,
    }

    impl ::protobuf::Enum for TransactionType {
        const NAME: &'static str = "TransactionType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<TransactionType> {
            match value {
                0 => ::std::option::Option::Some(TransactionType::GENESIS),
                1 => ::std::option::Option::Some(TransactionType::BLOCK_METADATA),
                2 => ::std::option::Option::Some(TransactionType::STATE_CHECKPOINT),
                3 => ::std::option::Option::Some(TransactionType::USER),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [TransactionType] = &[
            TransactionType::GENESIS,
            TransactionType::BLOCK_METADATA,
            TransactionType::STATE_CHECKPOINT,
            TransactionType::USER,
        ];
    }

    impl ::protobuf::EnumFull for TransactionType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Transaction.TransactionType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for TransactionType {
        fn default() -> Self {
            TransactionType::GENESIS
        }
    }

    impl TransactionType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<TransactionType>("Transaction.TransactionType")
        }
    }
}

///  TransactionTrimmed is a real Transaction with most of the fields removed so that
///  we can easily decode only the few fields that we have interest in in certain situations.
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:TransactionTrimmed)
pub struct TransactionTrimmed {
    // message fields
    // @@protoc_insertion_point(field:TransactionTrimmed.timestamp)
    pub timestamp: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    // @@protoc_insertion_point(field:TransactionTrimmed.version)
    pub version: u64,
    // special fields
    // @@protoc_insertion_point(special_field:TransactionTrimmed.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TransactionTrimmed {
    fn default() -> &'a TransactionTrimmed {
        <TransactionTrimmed as ::protobuf::Message>::default_instance()
    }
}

impl TransactionTrimmed {
    pub fn new() -> TransactionTrimmed {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "timestamp",
            |m: &TransactionTrimmed| { &m.timestamp },
            |m: &mut TransactionTrimmed| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version",
            |m: &TransactionTrimmed| { &m.version },
            |m: &mut TransactionTrimmed| { &mut m.version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TransactionTrimmed>(
            "TransactionTrimmed",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TransactionTrimmed {
    const NAME: &'static str = "TransactionTrimmed";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.timestamp)?;
                },
                16 => {
                    self.version = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.timestamp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.version != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.version);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.timestamp.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.version != 0 {
            os.write_uint64(2, self.version)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TransactionTrimmed {
        TransactionTrimmed::new()
    }

    fn clear(&mut self) {
        self.timestamp.clear();
        self.version = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TransactionTrimmed {
        static instance: TransactionTrimmed = TransactionTrimmed {
            timestamp: ::protobuf::MessageField::none(),
            version: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TransactionTrimmed {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TransactionTrimmed").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TransactionTrimmed {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionTrimmed {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:BlockMetadataTransaction)
pub struct BlockMetadataTransaction {
    // message fields
    // @@protoc_insertion_point(field:BlockMetadataTransaction.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:BlockMetadataTransaction.round)
    pub round: u64,
    // @@protoc_insertion_point(field:BlockMetadataTransaction.events)
    pub events: ::std::vec::Vec<Event>,
    // @@protoc_insertion_point(field:BlockMetadataTransaction.previous_block_votes)
    pub previous_block_votes: ::std::vec::Vec<bool>,
    // @@protoc_insertion_point(field:BlockMetadataTransaction.proposer)
    pub proposer: ::std::string::String,
    // @@protoc_insertion_point(field:BlockMetadataTransaction.failed_proposer_indices)
    pub failed_proposer_indices: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:BlockMetadataTransaction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BlockMetadataTransaction {
    fn default() -> &'a BlockMetadataTransaction {
        <BlockMetadataTransaction as ::protobuf::Message>::default_instance()
    }
}

impl BlockMetadataTransaction {
    pub fn new() -> BlockMetadataTransaction {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &BlockMetadataTransaction| { &m.id },
            |m: &mut BlockMetadataTransaction| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "round",
            |m: &BlockMetadataTransaction| { &m.round },
            |m: &mut BlockMetadataTransaction| { &mut m.round },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "events",
            |m: &BlockMetadataTransaction| { &m.events },
            |m: &mut BlockMetadataTransaction| { &mut m.events },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "previous_block_votes",
            |m: &BlockMetadataTransaction| { &m.previous_block_votes },
            |m: &mut BlockMetadataTransaction| { &mut m.previous_block_votes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "proposer",
            |m: &BlockMetadataTransaction| { &m.proposer },
            |m: &mut BlockMetadataTransaction| { &mut m.proposer },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "failed_proposer_indices",
            |m: &BlockMetadataTransaction| { &m.failed_proposer_indices },
            |m: &mut BlockMetadataTransaction| { &mut m.failed_proposer_indices },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BlockMetadataTransaction>(
            "BlockMetadataTransaction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BlockMetadataTransaction {
    const NAME: &'static str = "BlockMetadataTransaction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                16 => {
                    self.round = is.read_uint64()?;
                },
                26 => {
                    self.events.push(is.read_message()?);
                },
                34 => {
                    is.read_repeated_packed_bool_into(&mut self.previous_block_votes)?;
                },
                32 => {
                    self.previous_block_votes.push(is.read_bool()?);
                },
                42 => {
                    self.proposer = is.read_string()?;
                },
                50 => {
                    is.read_repeated_packed_uint32_into(&mut self.failed_proposer_indices)?;
                },
                48 => {
                    self.failed_proposer_indices.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if self.round != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.round);
        }
        for value in &self.events {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += 2 * self.previous_block_votes.len() as u64;
        if !self.proposer.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.proposer);
        }
        for value in &self.failed_proposer_indices {
            my_size += ::protobuf::rt::uint32_size(6, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if self.round != 0 {
            os.write_uint64(2, self.round)?;
        }
        for v in &self.events {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.previous_block_votes {
            os.write_bool(4, *v)?;
        };
        if !self.proposer.is_empty() {
            os.write_string(5, &self.proposer)?;
        }
        for v in &self.failed_proposer_indices {
            os.write_uint32(6, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BlockMetadataTransaction {
        BlockMetadataTransaction::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.round = 0;
        self.events.clear();
        self.previous_block_votes.clear();
        self.proposer.clear();
        self.failed_proposer_indices.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BlockMetadataTransaction {
        static instance: BlockMetadataTransaction = BlockMetadataTransaction {
            id: ::std::string::String::new(),
            round: 0,
            events: ::std::vec::Vec::new(),
            previous_block_votes: ::std::vec::Vec::new(),
            proposer: ::std::string::String::new(),
            failed_proposer_indices: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BlockMetadataTransaction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BlockMetadataTransaction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BlockMetadataTransaction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockMetadataTransaction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:GenesisTransaction)
pub struct GenesisTransaction {
    // message fields
    // @@protoc_insertion_point(field:GenesisTransaction.payload)
    pub payload: ::protobuf::MessageField<WriteSet>,
    // @@protoc_insertion_point(field:GenesisTransaction.events)
    pub events: ::std::vec::Vec<Event>,
    // special fields
    // @@protoc_insertion_point(special_field:GenesisTransaction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GenesisTransaction {
    fn default() -> &'a GenesisTransaction {
        <GenesisTransaction as ::protobuf::Message>::default_instance()
    }
}

impl GenesisTransaction {
    pub fn new() -> GenesisTransaction {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, WriteSet>(
            "payload",
            |m: &GenesisTransaction| { &m.payload },
            |m: &mut GenesisTransaction| { &mut m.payload },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "events",
            |m: &GenesisTransaction| { &m.events },
            |m: &mut GenesisTransaction| { &mut m.events },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GenesisTransaction>(
            "GenesisTransaction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GenesisTransaction {
    const NAME: &'static str = "GenesisTransaction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.payload)?;
                },
                18 => {
                    self.events.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payload.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.events {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payload.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.events {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GenesisTransaction {
        GenesisTransaction::new()
    }

    fn clear(&mut self) {
        self.payload.clear();
        self.events.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GenesisTransaction {
        static instance: GenesisTransaction = GenesisTransaction {
            payload: ::protobuf::MessageField::none(),
            events: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GenesisTransaction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GenesisTransaction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GenesisTransaction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GenesisTransaction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:StateCheckpointTransaction)
pub struct StateCheckpointTransaction {
    // special fields
    // @@protoc_insertion_point(special_field:StateCheckpointTransaction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StateCheckpointTransaction {
    fn default() -> &'a StateCheckpointTransaction {
        <StateCheckpointTransaction as ::protobuf::Message>::default_instance()
    }
}

impl StateCheckpointTransaction {
    pub fn new() -> StateCheckpointTransaction {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StateCheckpointTransaction>(
            "StateCheckpointTransaction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StateCheckpointTransaction {
    const NAME: &'static str = "StateCheckpointTransaction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StateCheckpointTransaction {
        StateCheckpointTransaction::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StateCheckpointTransaction {
        static instance: StateCheckpointTransaction = StateCheckpointTransaction {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StateCheckpointTransaction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StateCheckpointTransaction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StateCheckpointTransaction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StateCheckpointTransaction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:UserTransaction)
pub struct UserTransaction {
    // message fields
    // @@protoc_insertion_point(field:UserTransaction.request)
    pub request: ::protobuf::MessageField<UserTransactionRequest>,
    // @@protoc_insertion_point(field:UserTransaction.events)
    pub events: ::std::vec::Vec<Event>,
    // special fields
    // @@protoc_insertion_point(special_field:UserTransaction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserTransaction {
    fn default() -> &'a UserTransaction {
        <UserTransaction as ::protobuf::Message>::default_instance()
    }
}

impl UserTransaction {
    pub fn new() -> UserTransaction {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, UserTransactionRequest>(
            "request",
            |m: &UserTransaction| { &m.request },
            |m: &mut UserTransaction| { &mut m.request },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "events",
            |m: &UserTransaction| { &m.events },
            |m: &mut UserTransaction| { &mut m.events },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserTransaction>(
            "UserTransaction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserTransaction {
    const NAME: &'static str = "UserTransaction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.request)?;
                },
                18 => {
                    self.events.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.request.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.events {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.request.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.events {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserTransaction {
        UserTransaction::new()
    }

    fn clear(&mut self) {
        self.request.clear();
        self.events.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserTransaction {
        static instance: UserTransaction = UserTransaction {
            request: ::protobuf::MessageField::none(),
            events: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UserTransaction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserTransaction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserTransaction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserTransaction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:Event)
pub struct Event {
    // message fields
    // @@protoc_insertion_point(field:Event.key)
    pub key: ::protobuf::MessageField<EventKey>,
    // @@protoc_insertion_point(field:Event.sequence_number)
    pub sequence_number: u64,
    // @@protoc_insertion_point(field:Event.type)
    pub type_: ::protobuf::MessageField<MoveType>,
    // @@protoc_insertion_point(field:Event.data)
    pub data: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:Event.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Event {
    fn default() -> &'a Event {
        <Event as ::protobuf::Message>::default_instance()
    }
}

impl Event {
    pub fn new() -> Event {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, EventKey>(
            "key",
            |m: &Event| { &m.key },
            |m: &mut Event| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sequence_number",
            |m: &Event| { &m.sequence_number },
            |m: &mut Event| { &mut m.sequence_number },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MoveType>(
            "type",
            |m: &Event| { &m.type_ },
            |m: &mut Event| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data",
            |m: &Event| { &m.data },
            |m: &mut Event| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Event>(
            "Event",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Event {
    const NAME: &'static str = "Event";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.key)?;
                },
                16 => {
                    self.sequence_number = is.read_uint64()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.type_)?;
                },
                34 => {
                    self.data = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.sequence_number != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.sequence_number);
        }
        if let Some(v) = self.type_.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.key.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.sequence_number != 0 {
            os.write_uint64(2, self.sequence_number)?;
        }
        if let Some(v) = self.type_.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if !self.data.is_empty() {
            os.write_string(4, &self.data)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Event {
        Event::new()
    }

    fn clear(&mut self) {
        self.key.clear();
        self.sequence_number = 0;
        self.type_.clear();
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Event {
        static instance: Event = Event {
            key: ::protobuf::MessageField::none(),
            sequence_number: 0,
            type_: ::protobuf::MessageField::none(),
            data: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Event {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Event").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Event {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Event {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:TransactionInfo)
pub struct TransactionInfo {
    // message fields
    // @@protoc_insertion_point(field:TransactionInfo.hash)
    pub hash: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:TransactionInfo.state_root_hash)
    pub state_root_hash: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:TransactionInfo.event_root_hash)
    pub event_root_hash: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:TransactionInfo.gas_used)
    pub gas_used: u64,
    // @@protoc_insertion_point(field:TransactionInfo.success)
    pub success: bool,
    // @@protoc_insertion_point(field:TransactionInfo.vm_status)
    pub vm_status: ::std::string::String,
    // @@protoc_insertion_point(field:TransactionInfo.accumulator_root_hash)
    pub accumulator_root_hash: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:TransactionInfo.changes)
    pub changes: ::std::vec::Vec<WriteSetChange>,
    // special fields
    // @@protoc_insertion_point(special_field:TransactionInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TransactionInfo {
    fn default() -> &'a TransactionInfo {
        <TransactionInfo as ::protobuf::Message>::default_instance()
    }
}

impl TransactionInfo {
    pub fn new() -> TransactionInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hash",
            |m: &TransactionInfo| { &m.hash },
            |m: &mut TransactionInfo| { &mut m.hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state_root_hash",
            |m: &TransactionInfo| { &m.state_root_hash },
            |m: &mut TransactionInfo| { &mut m.state_root_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "event_root_hash",
            |m: &TransactionInfo| { &m.event_root_hash },
            |m: &mut TransactionInfo| { &mut m.event_root_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "gas_used",
            |m: &TransactionInfo| { &m.gas_used },
            |m: &mut TransactionInfo| { &mut m.gas_used },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "success",
            |m: &TransactionInfo| { &m.success },
            |m: &mut TransactionInfo| { &mut m.success },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "vm_status",
            |m: &TransactionInfo| { &m.vm_status },
            |m: &mut TransactionInfo| { &mut m.vm_status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "accumulator_root_hash",
            |m: &TransactionInfo| { &m.accumulator_root_hash },
            |m: &mut TransactionInfo| { &mut m.accumulator_root_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "changes",
            |m: &TransactionInfo| { &m.changes },
            |m: &mut TransactionInfo| { &mut m.changes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TransactionInfo>(
            "TransactionInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TransactionInfo {
    const NAME: &'static str = "TransactionInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.hash = is.read_bytes()?;
                },
                18 => {
                    self.state_root_hash = is.read_bytes()?;
                },
                26 => {
                    self.event_root_hash = is.read_bytes()?;
                },
                32 => {
                    self.gas_used = is.read_uint64()?;
                },
                40 => {
                    self.success = is.read_bool()?;
                },
                50 => {
                    self.vm_status = is.read_string()?;
                },
                58 => {
                    self.accumulator_root_hash = is.read_bytes()?;
                },
                66 => {
                    self.changes.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.hash);
        }
        if !self.state_root_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.state_root_hash);
        }
        if !self.event_root_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.event_root_hash);
        }
        if self.gas_used != 0 {
            my_size += ::protobuf::rt::uint64_size(4, self.gas_used);
        }
        if self.success != false {
            my_size += 1 + 1;
        }
        if !self.vm_status.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.vm_status);
        }
        if !self.accumulator_root_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(7, &self.accumulator_root_hash);
        }
        for value in &self.changes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.hash.is_empty() {
            os.write_bytes(1, &self.hash)?;
        }
        if !self.state_root_hash.is_empty() {
            os.write_bytes(2, &self.state_root_hash)?;
        }
        if !self.event_root_hash.is_empty() {
            os.write_bytes(3, &self.event_root_hash)?;
        }
        if self.gas_used != 0 {
            os.write_uint64(4, self.gas_used)?;
        }
        if self.success != false {
            os.write_bool(5, self.success)?;
        }
        if !self.vm_status.is_empty() {
            os.write_string(6, &self.vm_status)?;
        }
        if !self.accumulator_root_hash.is_empty() {
            os.write_bytes(7, &self.accumulator_root_hash)?;
        }
        for v in &self.changes {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TransactionInfo {
        TransactionInfo::new()
    }

    fn clear(&mut self) {
        self.hash.clear();
        self.state_root_hash.clear();
        self.event_root_hash.clear();
        self.gas_used = 0;
        self.success = false;
        self.vm_status.clear();
        self.accumulator_root_hash.clear();
        self.changes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TransactionInfo {
        static instance: TransactionInfo = TransactionInfo {
            hash: ::std::vec::Vec::new(),
            state_root_hash: ::std::vec::Vec::new(),
            event_root_hash: ::std::vec::Vec::new(),
            gas_used: 0,
            success: false,
            vm_status: ::std::string::String::new(),
            accumulator_root_hash: ::std::vec::Vec::new(),
            changes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TransactionInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TransactionInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TransactionInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:EventKey)
pub struct EventKey {
    // message fields
    // @@protoc_insertion_point(field:EventKey.creation_number)
    pub creation_number: u64,
    // @@protoc_insertion_point(field:EventKey.account_address)
    pub account_address: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:EventKey.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EventKey {
    fn default() -> &'a EventKey {
        <EventKey as ::protobuf::Message>::default_instance()
    }
}

impl EventKey {
    pub fn new() -> EventKey {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "creation_number",
            |m: &EventKey| { &m.creation_number },
            |m: &mut EventKey| { &mut m.creation_number },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "account_address",
            |m: &EventKey| { &m.account_address },
            |m: &mut EventKey| { &mut m.account_address },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EventKey>(
            "EventKey",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EventKey {
    const NAME: &'static str = "EventKey";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.creation_number = is.read_uint64()?;
                },
                18 => {
                    self.account_address = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.creation_number != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.creation_number);
        }
        if !self.account_address.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.account_address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.creation_number != 0 {
            os.write_uint64(1, self.creation_number)?;
        }
        if !self.account_address.is_empty() {
            os.write_string(2, &self.account_address)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EventKey {
        EventKey::new()
    }

    fn clear(&mut self) {
        self.creation_number = 0;
        self.account_address.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EventKey {
        static instance: EventKey = EventKey {
            creation_number: 0,
            account_address: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EventKey {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EventKey").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EventKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EventKey {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:UserTransactionRequest)
pub struct UserTransactionRequest {
    // message fields
    // @@protoc_insertion_point(field:UserTransactionRequest.sender)
    pub sender: ::std::string::String,
    // @@protoc_insertion_point(field:UserTransactionRequest.sequence_number)
    pub sequence_number: u64,
    // @@protoc_insertion_point(field:UserTransactionRequest.max_gas_amount)
    pub max_gas_amount: u64,
    // @@protoc_insertion_point(field:UserTransactionRequest.gas_unit_price)
    pub gas_unit_price: u64,
    // @@protoc_insertion_point(field:UserTransactionRequest.expiration_timestamp_secs)
    pub expiration_timestamp_secs: ::protobuf::MessageField<::protobuf::well_known_types::timestamp::Timestamp>,
    // @@protoc_insertion_point(field:UserTransactionRequest.payload)
    pub payload: ::protobuf::MessageField<TransactionPayload>,
    // @@protoc_insertion_point(field:UserTransactionRequest.signature)
    pub signature: ::protobuf::MessageField<Signature>,
    // special fields
    // @@protoc_insertion_point(special_field:UserTransactionRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserTransactionRequest {
    fn default() -> &'a UserTransactionRequest {
        <UserTransactionRequest as ::protobuf::Message>::default_instance()
    }
}

impl UserTransactionRequest {
    pub fn new() -> UserTransactionRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sender",
            |m: &UserTransactionRequest| { &m.sender },
            |m: &mut UserTransactionRequest| { &mut m.sender },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sequence_number",
            |m: &UserTransactionRequest| { &m.sequence_number },
            |m: &mut UserTransactionRequest| { &mut m.sequence_number },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "max_gas_amount",
            |m: &UserTransactionRequest| { &m.max_gas_amount },
            |m: &mut UserTransactionRequest| { &mut m.max_gas_amount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "gas_unit_price",
            |m: &UserTransactionRequest| { &m.gas_unit_price },
            |m: &mut UserTransactionRequest| { &mut m.gas_unit_price },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ::protobuf::well_known_types::timestamp::Timestamp>(
            "expiration_timestamp_secs",
            |m: &UserTransactionRequest| { &m.expiration_timestamp_secs },
            |m: &mut UserTransactionRequest| { &mut m.expiration_timestamp_secs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TransactionPayload>(
            "payload",
            |m: &UserTransactionRequest| { &m.payload },
            |m: &mut UserTransactionRequest| { &mut m.payload },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Signature>(
            "signature",
            |m: &UserTransactionRequest| { &m.signature },
            |m: &mut UserTransactionRequest| { &mut m.signature },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserTransactionRequest>(
            "UserTransactionRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserTransactionRequest {
    const NAME: &'static str = "UserTransactionRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.sender = is.read_string()?;
                },
                16 => {
                    self.sequence_number = is.read_uint64()?;
                },
                24 => {
                    self.max_gas_amount = is.read_uint64()?;
                },
                32 => {
                    self.gas_unit_price = is.read_uint64()?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.expiration_timestamp_secs)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.payload)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.signature)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.sender.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.sender);
        }
        if self.sequence_number != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.sequence_number);
        }
        if self.max_gas_amount != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.max_gas_amount);
        }
        if self.gas_unit_price != 0 {
            my_size += ::protobuf::rt::uint64_size(4, self.gas_unit_price);
        }
        if let Some(v) = self.expiration_timestamp_secs.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.payload.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.signature.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.sender.is_empty() {
            os.write_string(1, &self.sender)?;
        }
        if self.sequence_number != 0 {
            os.write_uint64(2, self.sequence_number)?;
        }
        if self.max_gas_amount != 0 {
            os.write_uint64(3, self.max_gas_amount)?;
        }
        if self.gas_unit_price != 0 {
            os.write_uint64(4, self.gas_unit_price)?;
        }
        if let Some(v) = self.expiration_timestamp_secs.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.payload.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.signature.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserTransactionRequest {
        UserTransactionRequest::new()
    }

    fn clear(&mut self) {
        self.sender.clear();
        self.sequence_number = 0;
        self.max_gas_amount = 0;
        self.gas_unit_price = 0;
        self.expiration_timestamp_secs.clear();
        self.payload.clear();
        self.signature.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserTransactionRequest {
        static instance: UserTransactionRequest = UserTransactionRequest {
            sender: ::std::string::String::new(),
            sequence_number: 0,
            max_gas_amount: 0,
            gas_unit_price: 0,
            expiration_timestamp_secs: ::protobuf::MessageField::none(),
            payload: ::protobuf::MessageField::none(),
            signature: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UserTransactionRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserTransactionRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserTransactionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserTransactionRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:WriteSet)
pub struct WriteSet {
    // message fields
    // @@protoc_insertion_point(field:WriteSet.write_set_type)
    pub write_set_type: ::protobuf::EnumOrUnknown<write_set::WriteSetType>,
    // message oneof groups
    pub write_set: ::std::option::Option<write_set::Write_set>,
    // special fields
    // @@protoc_insertion_point(special_field:WriteSet.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WriteSet {
    fn default() -> &'a WriteSet {
        <WriteSet as ::protobuf::Message>::default_instance()
    }
}

impl WriteSet {
    pub fn new() -> WriteSet {
        ::std::default::Default::default()
    }

    // .ScriptWriteSet script_write_set = 2;

    pub fn script_write_set(&self) -> &ScriptWriteSet {
        match self.write_set {
            ::std::option::Option::Some(write_set::Write_set::ScriptWriteSet(ref v)) => v,
            _ => <ScriptWriteSet as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_script_write_set(&mut self) {
        self.write_set = ::std::option::Option::None;
    }

    pub fn has_script_write_set(&self) -> bool {
        match self.write_set {
            ::std::option::Option::Some(write_set::Write_set::ScriptWriteSet(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_script_write_set(&mut self, v: ScriptWriteSet) {
        self.write_set = ::std::option::Option::Some(write_set::Write_set::ScriptWriteSet(v))
    }

    // Mutable pointer to the field.
    pub fn mut_script_write_set(&mut self) -> &mut ScriptWriteSet {
        if let ::std::option::Option::Some(write_set::Write_set::ScriptWriteSet(_)) = self.write_set {
        } else {
            self.write_set = ::std::option::Option::Some(write_set::Write_set::ScriptWriteSet(ScriptWriteSet::new()));
        }
        match self.write_set {
            ::std::option::Option::Some(write_set::Write_set::ScriptWriteSet(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_script_write_set(&mut self) -> ScriptWriteSet {
        if self.has_script_write_set() {
            match self.write_set.take() {
                ::std::option::Option::Some(write_set::Write_set::ScriptWriteSet(v)) => v,
                _ => panic!(),
            }
        } else {
            ScriptWriteSet::new()
        }
    }

    // .DirectWriteSet direct_write_set = 3;

    pub fn direct_write_set(&self) -> &DirectWriteSet {
        match self.write_set {
            ::std::option::Option::Some(write_set::Write_set::DirectWriteSet(ref v)) => v,
            _ => <DirectWriteSet as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_direct_write_set(&mut self) {
        self.write_set = ::std::option::Option::None;
    }

    pub fn has_direct_write_set(&self) -> bool {
        match self.write_set {
            ::std::option::Option::Some(write_set::Write_set::DirectWriteSet(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_direct_write_set(&mut self, v: DirectWriteSet) {
        self.write_set = ::std::option::Option::Some(write_set::Write_set::DirectWriteSet(v))
    }

    // Mutable pointer to the field.
    pub fn mut_direct_write_set(&mut self) -> &mut DirectWriteSet {
        if let ::std::option::Option::Some(write_set::Write_set::DirectWriteSet(_)) = self.write_set {
        } else {
            self.write_set = ::std::option::Option::Some(write_set::Write_set::DirectWriteSet(DirectWriteSet::new()));
        }
        match self.write_set {
            ::std::option::Option::Some(write_set::Write_set::DirectWriteSet(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_direct_write_set(&mut self) -> DirectWriteSet {
        if self.has_direct_write_set() {
            match self.write_set.take() {
                ::std::option::Option::Some(write_set::Write_set::DirectWriteSet(v)) => v,
                _ => panic!(),
            }
        } else {
            DirectWriteSet::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "write_set_type",
            |m: &WriteSet| { &m.write_set_type },
            |m: &mut WriteSet| { &mut m.write_set_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ScriptWriteSet>(
            "script_write_set",
            WriteSet::has_script_write_set,
            WriteSet::script_write_set,
            WriteSet::mut_script_write_set,
            WriteSet::set_script_write_set,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, DirectWriteSet>(
            "direct_write_set",
            WriteSet::has_direct_write_set,
            WriteSet::direct_write_set,
            WriteSet::mut_direct_write_set,
            WriteSet::set_direct_write_set,
        ));
        oneofs.push(write_set::Write_set::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WriteSet>(
            "WriteSet",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WriteSet {
    const NAME: &'static str = "WriteSet";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.write_set_type = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.write_set = ::std::option::Option::Some(write_set::Write_set::ScriptWriteSet(is.read_message()?));
                },
                26 => {
                    self.write_set = ::std::option::Option::Some(write_set::Write_set::DirectWriteSet(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.write_set_type != ::protobuf::EnumOrUnknown::new(write_set::WriteSetType::SCRIPT_WRITE_SET) {
            my_size += ::protobuf::rt::int32_size(1, self.write_set_type.value());
        }
        if let ::std::option::Option::Some(ref v) = self.write_set {
            match v {
                &write_set::Write_set::ScriptWriteSet(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &write_set::Write_set::DirectWriteSet(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.write_set_type != ::protobuf::EnumOrUnknown::new(write_set::WriteSetType::SCRIPT_WRITE_SET) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.write_set_type))?;
        }
        if let ::std::option::Option::Some(ref v) = self.write_set {
            match v {
                &write_set::Write_set::ScriptWriteSet(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &write_set::Write_set::DirectWriteSet(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WriteSet {
        WriteSet::new()
    }

    fn clear(&mut self) {
        self.write_set_type = ::protobuf::EnumOrUnknown::new(write_set::WriteSetType::SCRIPT_WRITE_SET);
        self.write_set = ::std::option::Option::None;
        self.write_set = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WriteSet {
        static instance: WriteSet = WriteSet {
            write_set_type: ::protobuf::EnumOrUnknown::from_i32(0),
            write_set: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WriteSet {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WriteSet").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WriteSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WriteSet {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `WriteSet`
pub mod write_set {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:WriteSet.write_set)
    pub enum Write_set {
        // @@protoc_insertion_point(oneof_field:WriteSet.script_write_set)
        ScriptWriteSet(super::ScriptWriteSet),
        // @@protoc_insertion_point(oneof_field:WriteSet.direct_write_set)
        DirectWriteSet(super::DirectWriteSet),
    }

    impl ::protobuf::Oneof for Write_set {
    }

    impl ::protobuf::OneofFull for Write_set {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::WriteSet as ::protobuf::MessageFull>::descriptor().oneof_by_name("write_set").unwrap()).clone()
        }
    }

    impl Write_set {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Write_set>("write_set")
        }
    }
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:WriteSet.WriteSetType)
    pub enum WriteSetType {
        // @@protoc_insertion_point(enum_value:WriteSet.WriteSetType.SCRIPT_WRITE_SET)
        SCRIPT_WRITE_SET = 0,
        // @@protoc_insertion_point(enum_value:WriteSet.WriteSetType.DIRECT_WRITE_SET)
        DIRECT_WRITE_SET = 1,
    }

    impl ::protobuf::Enum for WriteSetType {
        const NAME: &'static str = "WriteSetType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<WriteSetType> {
            match value {
                0 => ::std::option::Option::Some(WriteSetType::SCRIPT_WRITE_SET),
                1 => ::std::option::Option::Some(WriteSetType::DIRECT_WRITE_SET),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [WriteSetType] = &[
            WriteSetType::SCRIPT_WRITE_SET,
            WriteSetType::DIRECT_WRITE_SET,
        ];
    }

    impl ::protobuf::EnumFull for WriteSetType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("WriteSet.WriteSetType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for WriteSetType {
        fn default() -> Self {
            WriteSetType::SCRIPT_WRITE_SET
        }
    }

    impl WriteSetType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<WriteSetType>("WriteSet.WriteSetType")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ScriptWriteSet)
pub struct ScriptWriteSet {
    // message fields
    // @@protoc_insertion_point(field:ScriptWriteSet.execute_as)
    pub execute_as: ::std::string::String,
    // @@protoc_insertion_point(field:ScriptWriteSet.script)
    pub script: ::protobuf::MessageField<ScriptPayload>,
    // special fields
    // @@protoc_insertion_point(special_field:ScriptWriteSet.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ScriptWriteSet {
    fn default() -> &'a ScriptWriteSet {
        <ScriptWriteSet as ::protobuf::Message>::default_instance()
    }
}

impl ScriptWriteSet {
    pub fn new() -> ScriptWriteSet {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "execute_as",
            |m: &ScriptWriteSet| { &m.execute_as },
            |m: &mut ScriptWriteSet| { &mut m.execute_as },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ScriptPayload>(
            "script",
            |m: &ScriptWriteSet| { &m.script },
            |m: &mut ScriptWriteSet| { &mut m.script },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ScriptWriteSet>(
            "ScriptWriteSet",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ScriptWriteSet {
    const NAME: &'static str = "ScriptWriteSet";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.execute_as = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.script)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.execute_as.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.execute_as);
        }
        if let Some(v) = self.script.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.execute_as.is_empty() {
            os.write_string(1, &self.execute_as)?;
        }
        if let Some(v) = self.script.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ScriptWriteSet {
        ScriptWriteSet::new()
    }

    fn clear(&mut self) {
        self.execute_as.clear();
        self.script.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ScriptWriteSet {
        static instance: ScriptWriteSet = ScriptWriteSet {
            execute_as: ::std::string::String::new(),
            script: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ScriptWriteSet {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ScriptWriteSet").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ScriptWriteSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScriptWriteSet {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:DirectWriteSet)
pub struct DirectWriteSet {
    // message fields
    // @@protoc_insertion_point(field:DirectWriteSet.write_set_change)
    pub write_set_change: ::std::vec::Vec<WriteSetChange>,
    // @@protoc_insertion_point(field:DirectWriteSet.events)
    pub events: ::std::vec::Vec<Event>,
    // special fields
    // @@protoc_insertion_point(special_field:DirectWriteSet.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DirectWriteSet {
    fn default() -> &'a DirectWriteSet {
        <DirectWriteSet as ::protobuf::Message>::default_instance()
    }
}

impl DirectWriteSet {
    pub fn new() -> DirectWriteSet {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "write_set_change",
            |m: &DirectWriteSet| { &m.write_set_change },
            |m: &mut DirectWriteSet| { &mut m.write_set_change },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "events",
            |m: &DirectWriteSet| { &m.events },
            |m: &mut DirectWriteSet| { &mut m.events },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DirectWriteSet>(
            "DirectWriteSet",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DirectWriteSet {
    const NAME: &'static str = "DirectWriteSet";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.write_set_change.push(is.read_message()?);
                },
                18 => {
                    self.events.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.write_set_change {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.events {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.write_set_change {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.events {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DirectWriteSet {
        DirectWriteSet::new()
    }

    fn clear(&mut self) {
        self.write_set_change.clear();
        self.events.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DirectWriteSet {
        static instance: DirectWriteSet = DirectWriteSet {
            write_set_change: ::std::vec::Vec::new(),
            events: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DirectWriteSet {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DirectWriteSet").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DirectWriteSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DirectWriteSet {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:WriteSetChange)
pub struct WriteSetChange {
    // message fields
    // @@protoc_insertion_point(field:WriteSetChange.type)
    pub type_: ::protobuf::EnumOrUnknown<write_set_change::Type>,
    // message oneof groups
    pub change: ::std::option::Option<write_set_change::Change>,
    // special fields
    // @@protoc_insertion_point(special_field:WriteSetChange.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WriteSetChange {
    fn default() -> &'a WriteSetChange {
        <WriteSetChange as ::protobuf::Message>::default_instance()
    }
}

impl WriteSetChange {
    pub fn new() -> WriteSetChange {
        ::std::default::Default::default()
    }

    // .DeleteModule delete_module = 2;

    pub fn delete_module(&self) -> &DeleteModule {
        match self.change {
            ::std::option::Option::Some(write_set_change::Change::DeleteModule(ref v)) => v,
            _ => <DeleteModule as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_delete_module(&mut self) {
        self.change = ::std::option::Option::None;
    }

    pub fn has_delete_module(&self) -> bool {
        match self.change {
            ::std::option::Option::Some(write_set_change::Change::DeleteModule(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_delete_module(&mut self, v: DeleteModule) {
        self.change = ::std::option::Option::Some(write_set_change::Change::DeleteModule(v))
    }

    // Mutable pointer to the field.
    pub fn mut_delete_module(&mut self) -> &mut DeleteModule {
        if let ::std::option::Option::Some(write_set_change::Change::DeleteModule(_)) = self.change {
        } else {
            self.change = ::std::option::Option::Some(write_set_change::Change::DeleteModule(DeleteModule::new()));
        }
        match self.change {
            ::std::option::Option::Some(write_set_change::Change::DeleteModule(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_delete_module(&mut self) -> DeleteModule {
        if self.has_delete_module() {
            match self.change.take() {
                ::std::option::Option::Some(write_set_change::Change::DeleteModule(v)) => v,
                _ => panic!(),
            }
        } else {
            DeleteModule::new()
        }
    }

    // .DeleteResource delete_resource = 3;

    pub fn delete_resource(&self) -> &DeleteResource {
        match self.change {
            ::std::option::Option::Some(write_set_change::Change::DeleteResource(ref v)) => v,
            _ => <DeleteResource as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_delete_resource(&mut self) {
        self.change = ::std::option::Option::None;
    }

    pub fn has_delete_resource(&self) -> bool {
        match self.change {
            ::std::option::Option::Some(write_set_change::Change::DeleteResource(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_delete_resource(&mut self, v: DeleteResource) {
        self.change = ::std::option::Option::Some(write_set_change::Change::DeleteResource(v))
    }

    // Mutable pointer to the field.
    pub fn mut_delete_resource(&mut self) -> &mut DeleteResource {
        if let ::std::option::Option::Some(write_set_change::Change::DeleteResource(_)) = self.change {
        } else {
            self.change = ::std::option::Option::Some(write_set_change::Change::DeleteResource(DeleteResource::new()));
        }
        match self.change {
            ::std::option::Option::Some(write_set_change::Change::DeleteResource(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_delete_resource(&mut self) -> DeleteResource {
        if self.has_delete_resource() {
            match self.change.take() {
                ::std::option::Option::Some(write_set_change::Change::DeleteResource(v)) => v,
                _ => panic!(),
            }
        } else {
            DeleteResource::new()
        }
    }

    // .DeleteTableItem delete_table_item = 4;

    pub fn delete_table_item(&self) -> &DeleteTableItem {
        match self.change {
            ::std::option::Option::Some(write_set_change::Change::DeleteTableItem(ref v)) => v,
            _ => <DeleteTableItem as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_delete_table_item(&mut self) {
        self.change = ::std::option::Option::None;
    }

    pub fn has_delete_table_item(&self) -> bool {
        match self.change {
            ::std::option::Option::Some(write_set_change::Change::DeleteTableItem(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_delete_table_item(&mut self, v: DeleteTableItem) {
        self.change = ::std::option::Option::Some(write_set_change::Change::DeleteTableItem(v))
    }

    // Mutable pointer to the field.
    pub fn mut_delete_table_item(&mut self) -> &mut DeleteTableItem {
        if let ::std::option::Option::Some(write_set_change::Change::DeleteTableItem(_)) = self.change {
        } else {
            self.change = ::std::option::Option::Some(write_set_change::Change::DeleteTableItem(DeleteTableItem::new()));
        }
        match self.change {
            ::std::option::Option::Some(write_set_change::Change::DeleteTableItem(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_delete_table_item(&mut self) -> DeleteTableItem {
        if self.has_delete_table_item() {
            match self.change.take() {
                ::std::option::Option::Some(write_set_change::Change::DeleteTableItem(v)) => v,
                _ => panic!(),
            }
        } else {
            DeleteTableItem::new()
        }
    }

    // .WriteModule write_module = 5;

    pub fn write_module(&self) -> &WriteModule {
        match self.change {
            ::std::option::Option::Some(write_set_change::Change::WriteModule(ref v)) => v,
            _ => <WriteModule as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_write_module(&mut self) {
        self.change = ::std::option::Option::None;
    }

    pub fn has_write_module(&self) -> bool {
        match self.change {
            ::std::option::Option::Some(write_set_change::Change::WriteModule(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_write_module(&mut self, v: WriteModule) {
        self.change = ::std::option::Option::Some(write_set_change::Change::WriteModule(v))
    }

    // Mutable pointer to the field.
    pub fn mut_write_module(&mut self) -> &mut WriteModule {
        if let ::std::option::Option::Some(write_set_change::Change::WriteModule(_)) = self.change {
        } else {
            self.change = ::std::option::Option::Some(write_set_change::Change::WriteModule(WriteModule::new()));
        }
        match self.change {
            ::std::option::Option::Some(write_set_change::Change::WriteModule(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_write_module(&mut self) -> WriteModule {
        if self.has_write_module() {
            match self.change.take() {
                ::std::option::Option::Some(write_set_change::Change::WriteModule(v)) => v,
                _ => panic!(),
            }
        } else {
            WriteModule::new()
        }
    }

    // .WriteResource write_resource = 6;

    pub fn write_resource(&self) -> &WriteResource {
        match self.change {
            ::std::option::Option::Some(write_set_change::Change::WriteResource(ref v)) => v,
            _ => <WriteResource as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_write_resource(&mut self) {
        self.change = ::std::option::Option::None;
    }

    pub fn has_write_resource(&self) -> bool {
        match self.change {
            ::std::option::Option::Some(write_set_change::Change::WriteResource(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_write_resource(&mut self, v: WriteResource) {
        self.change = ::std::option::Option::Some(write_set_change::Change::WriteResource(v))
    }

    // Mutable pointer to the field.
    pub fn mut_write_resource(&mut self) -> &mut WriteResource {
        if let ::std::option::Option::Some(write_set_change::Change::WriteResource(_)) = self.change {
        } else {
            self.change = ::std::option::Option::Some(write_set_change::Change::WriteResource(WriteResource::new()));
        }
        match self.change {
            ::std::option::Option::Some(write_set_change::Change::WriteResource(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_write_resource(&mut self) -> WriteResource {
        if self.has_write_resource() {
            match self.change.take() {
                ::std::option::Option::Some(write_set_change::Change::WriteResource(v)) => v,
                _ => panic!(),
            }
        } else {
            WriteResource::new()
        }
    }

    // .WriteTableItem write_table_item = 7;

    pub fn write_table_item(&self) -> &WriteTableItem {
        match self.change {
            ::std::option::Option::Some(write_set_change::Change::WriteTableItem(ref v)) => v,
            _ => <WriteTableItem as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_write_table_item(&mut self) {
        self.change = ::std::option::Option::None;
    }

    pub fn has_write_table_item(&self) -> bool {
        match self.change {
            ::std::option::Option::Some(write_set_change::Change::WriteTableItem(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_write_table_item(&mut self, v: WriteTableItem) {
        self.change = ::std::option::Option::Some(write_set_change::Change::WriteTableItem(v))
    }

    // Mutable pointer to the field.
    pub fn mut_write_table_item(&mut self) -> &mut WriteTableItem {
        if let ::std::option::Option::Some(write_set_change::Change::WriteTableItem(_)) = self.change {
        } else {
            self.change = ::std::option::Option::Some(write_set_change::Change::WriteTableItem(WriteTableItem::new()));
        }
        match self.change {
            ::std::option::Option::Some(write_set_change::Change::WriteTableItem(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_write_table_item(&mut self) -> WriteTableItem {
        if self.has_write_table_item() {
            match self.change.take() {
                ::std::option::Option::Some(write_set_change::Change::WriteTableItem(v)) => v,
                _ => panic!(),
            }
        } else {
            WriteTableItem::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &WriteSetChange| { &m.type_ },
            |m: &mut WriteSetChange| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, DeleteModule>(
            "delete_module",
            WriteSetChange::has_delete_module,
            WriteSetChange::delete_module,
            WriteSetChange::mut_delete_module,
            WriteSetChange::set_delete_module,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, DeleteResource>(
            "delete_resource",
            WriteSetChange::has_delete_resource,
            WriteSetChange::delete_resource,
            WriteSetChange::mut_delete_resource,
            WriteSetChange::set_delete_resource,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, DeleteTableItem>(
            "delete_table_item",
            WriteSetChange::has_delete_table_item,
            WriteSetChange::delete_table_item,
            WriteSetChange::mut_delete_table_item,
            WriteSetChange::set_delete_table_item,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, WriteModule>(
            "write_module",
            WriteSetChange::has_write_module,
            WriteSetChange::write_module,
            WriteSetChange::mut_write_module,
            WriteSetChange::set_write_module,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, WriteResource>(
            "write_resource",
            WriteSetChange::has_write_resource,
            WriteSetChange::write_resource,
            WriteSetChange::mut_write_resource,
            WriteSetChange::set_write_resource,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, WriteTableItem>(
            "write_table_item",
            WriteSetChange::has_write_table_item,
            WriteSetChange::write_table_item,
            WriteSetChange::mut_write_table_item,
            WriteSetChange::set_write_table_item,
        ));
        oneofs.push(write_set_change::Change::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WriteSetChange>(
            "WriteSetChange",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WriteSetChange {
    const NAME: &'static str = "WriteSetChange";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.change = ::std::option::Option::Some(write_set_change::Change::DeleteModule(is.read_message()?));
                },
                26 => {
                    self.change = ::std::option::Option::Some(write_set_change::Change::DeleteResource(is.read_message()?));
                },
                34 => {
                    self.change = ::std::option::Option::Some(write_set_change::Change::DeleteTableItem(is.read_message()?));
                },
                42 => {
                    self.change = ::std::option::Option::Some(write_set_change::Change::WriteModule(is.read_message()?));
                },
                50 => {
                    self.change = ::std::option::Option::Some(write_set_change::Change::WriteResource(is.read_message()?));
                },
                58 => {
                    self.change = ::std::option::Option::Some(write_set_change::Change::WriteTableItem(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.type_ != ::protobuf::EnumOrUnknown::new(write_set_change::Type::DELETE_MODULE) {
            my_size += ::protobuf::rt::int32_size(1, self.type_.value());
        }
        if let ::std::option::Option::Some(ref v) = self.change {
            match v {
                &write_set_change::Change::DeleteModule(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &write_set_change::Change::DeleteResource(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &write_set_change::Change::DeleteTableItem(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &write_set_change::Change::WriteModule(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &write_set_change::Change::WriteResource(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &write_set_change::Change::WriteTableItem(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.type_ != ::protobuf::EnumOrUnknown::new(write_set_change::Type::DELETE_MODULE) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if let ::std::option::Option::Some(ref v) = self.change {
            match v {
                &write_set_change::Change::DeleteModule(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &write_set_change::Change::DeleteResource(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &write_set_change::Change::DeleteTableItem(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &write_set_change::Change::WriteModule(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &write_set_change::Change::WriteResource(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &write_set_change::Change::WriteTableItem(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WriteSetChange {
        WriteSetChange::new()
    }

    fn clear(&mut self) {
        self.type_ = ::protobuf::EnumOrUnknown::new(write_set_change::Type::DELETE_MODULE);
        self.change = ::std::option::Option::None;
        self.change = ::std::option::Option::None;
        self.change = ::std::option::Option::None;
        self.change = ::std::option::Option::None;
        self.change = ::std::option::Option::None;
        self.change = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WriteSetChange {
        static instance: WriteSetChange = WriteSetChange {
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            change: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WriteSetChange {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WriteSetChange").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WriteSetChange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WriteSetChange {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `WriteSetChange`
pub mod write_set_change {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:WriteSetChange.change)
    pub enum Change {
        // @@protoc_insertion_point(oneof_field:WriteSetChange.delete_module)
        DeleteModule(super::DeleteModule),
        // @@protoc_insertion_point(oneof_field:WriteSetChange.delete_resource)
        DeleteResource(super::DeleteResource),
        // @@protoc_insertion_point(oneof_field:WriteSetChange.delete_table_item)
        DeleteTableItem(super::DeleteTableItem),
        // @@protoc_insertion_point(oneof_field:WriteSetChange.write_module)
        WriteModule(super::WriteModule),
        // @@protoc_insertion_point(oneof_field:WriteSetChange.write_resource)
        WriteResource(super::WriteResource),
        // @@protoc_insertion_point(oneof_field:WriteSetChange.write_table_item)
        WriteTableItem(super::WriteTableItem),
    }

    impl ::protobuf::Oneof for Change {
    }

    impl ::protobuf::OneofFull for Change {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::WriteSetChange as ::protobuf::MessageFull>::descriptor().oneof_by_name("change").unwrap()).clone()
        }
    }

    impl Change {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Change>("change")
        }
    }
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:WriteSetChange.Type)
    pub enum Type {
        // @@protoc_insertion_point(enum_value:WriteSetChange.Type.DELETE_MODULE)
        DELETE_MODULE = 0,
        // @@protoc_insertion_point(enum_value:WriteSetChange.Type.DELETE_RESOURCE)
        DELETE_RESOURCE = 1,
        // @@protoc_insertion_point(enum_value:WriteSetChange.Type.DELETE_TABLE_ITEM)
        DELETE_TABLE_ITEM = 2,
        // @@protoc_insertion_point(enum_value:WriteSetChange.Type.WRITE_MODULE)
        WRITE_MODULE = 3,
        // @@protoc_insertion_point(enum_value:WriteSetChange.Type.WRITE_RESOURCE)
        WRITE_RESOURCE = 4,
        // @@protoc_insertion_point(enum_value:WriteSetChange.Type.WRITE_TABLE_ITEM)
        WRITE_TABLE_ITEM = 5,
    }

    impl ::protobuf::Enum for Type {
        const NAME: &'static str = "Type";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Type> {
            match value {
                0 => ::std::option::Option::Some(Type::DELETE_MODULE),
                1 => ::std::option::Option::Some(Type::DELETE_RESOURCE),
                2 => ::std::option::Option::Some(Type::DELETE_TABLE_ITEM),
                3 => ::std::option::Option::Some(Type::WRITE_MODULE),
                4 => ::std::option::Option::Some(Type::WRITE_RESOURCE),
                5 => ::std::option::Option::Some(Type::WRITE_TABLE_ITEM),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Type] = &[
            Type::DELETE_MODULE,
            Type::DELETE_RESOURCE,
            Type::DELETE_TABLE_ITEM,
            Type::WRITE_MODULE,
            Type::WRITE_RESOURCE,
            Type::WRITE_TABLE_ITEM,
        ];
    }

    impl ::protobuf::EnumFull for Type {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("WriteSetChange.Type").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Type {
        fn default() -> Self {
            Type::DELETE_MODULE
        }
    }

    impl Type {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Type>("WriteSetChange.Type")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:DeleteModule)
pub struct DeleteModule {
    // message fields
    // @@protoc_insertion_point(field:DeleteModule.address)
    pub address: ::std::string::String,
    // @@protoc_insertion_point(field:DeleteModule.state_key_hash)
    pub state_key_hash: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:DeleteModule.module)
    pub module: ::protobuf::MessageField<MoveModuleId>,
    // special fields
    // @@protoc_insertion_point(special_field:DeleteModule.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteModule {
    fn default() -> &'a DeleteModule {
        <DeleteModule as ::protobuf::Message>::default_instance()
    }
}

impl DeleteModule {
    pub fn new() -> DeleteModule {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &DeleteModule| { &m.address },
            |m: &mut DeleteModule| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state_key_hash",
            |m: &DeleteModule| { &m.state_key_hash },
            |m: &mut DeleteModule| { &mut m.state_key_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MoveModuleId>(
            "module",
            |m: &DeleteModule| { &m.module },
            |m: &mut DeleteModule| { &mut m.module },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteModule>(
            "DeleteModule",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteModule {
    const NAME: &'static str = "DeleteModule";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.address = is.read_string()?;
                },
                18 => {
                    self.state_key_hash = is.read_bytes()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.module)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if !self.state_key_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.state_key_hash);
        }
        if let Some(v) = self.module.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if !self.state_key_hash.is_empty() {
            os.write_bytes(2, &self.state_key_hash)?;
        }
        if let Some(v) = self.module.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteModule {
        DeleteModule::new()
    }

    fn clear(&mut self) {
        self.address.clear();
        self.state_key_hash.clear();
        self.module.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteModule {
        static instance: DeleteModule = DeleteModule {
            address: ::std::string::String::new(),
            state_key_hash: ::std::vec::Vec::new(),
            module: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteModule {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteModule").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteModule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteModule {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:DeleteResource)
pub struct DeleteResource {
    // message fields
    // @@protoc_insertion_point(field:DeleteResource.address)
    pub address: ::std::string::String,
    // @@protoc_insertion_point(field:DeleteResource.state_key_hash)
    pub state_key_hash: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:DeleteResource.resource)
    pub resource: ::protobuf::MessageField<MoveStructTag>,
    // special fields
    // @@protoc_insertion_point(special_field:DeleteResource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteResource {
    fn default() -> &'a DeleteResource {
        <DeleteResource as ::protobuf::Message>::default_instance()
    }
}

impl DeleteResource {
    pub fn new() -> DeleteResource {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &DeleteResource| { &m.address },
            |m: &mut DeleteResource| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state_key_hash",
            |m: &DeleteResource| { &m.state_key_hash },
            |m: &mut DeleteResource| { &mut m.state_key_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MoveStructTag>(
            "resource",
            |m: &DeleteResource| { &m.resource },
            |m: &mut DeleteResource| { &mut m.resource },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteResource>(
            "DeleteResource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteResource {
    const NAME: &'static str = "DeleteResource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.address = is.read_string()?;
                },
                18 => {
                    self.state_key_hash = is.read_bytes()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.resource)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if !self.state_key_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.state_key_hash);
        }
        if let Some(v) = self.resource.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if !self.state_key_hash.is_empty() {
            os.write_bytes(2, &self.state_key_hash)?;
        }
        if let Some(v) = self.resource.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteResource {
        DeleteResource::new()
    }

    fn clear(&mut self) {
        self.address.clear();
        self.state_key_hash.clear();
        self.resource.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteResource {
        static instance: DeleteResource = DeleteResource {
            address: ::std::string::String::new(),
            state_key_hash: ::std::vec::Vec::new(),
            resource: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteResource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteResource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteResource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteResource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:DeleteTableItem)
pub struct DeleteTableItem {
    // message fields
    // @@protoc_insertion_point(field:DeleteTableItem.state_key_hash)
    pub state_key_hash: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:DeleteTableItem.handle)
    pub handle: ::std::string::String,
    // @@protoc_insertion_point(field:DeleteTableItem.key)
    pub key: ::std::string::String,
    // @@protoc_insertion_point(field:DeleteTableItem.data)
    pub data: ::protobuf::MessageField<DeleteTableData>,
    // special fields
    // @@protoc_insertion_point(special_field:DeleteTableItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteTableItem {
    fn default() -> &'a DeleteTableItem {
        <DeleteTableItem as ::protobuf::Message>::default_instance()
    }
}

impl DeleteTableItem {
    pub fn new() -> DeleteTableItem {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state_key_hash",
            |m: &DeleteTableItem| { &m.state_key_hash },
            |m: &mut DeleteTableItem| { &mut m.state_key_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "handle",
            |m: &DeleteTableItem| { &m.handle },
            |m: &mut DeleteTableItem| { &mut m.handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &DeleteTableItem| { &m.key },
            |m: &mut DeleteTableItem| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, DeleteTableData>(
            "data",
            |m: &DeleteTableItem| { &m.data },
            |m: &mut DeleteTableItem| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteTableItem>(
            "DeleteTableItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteTableItem {
    const NAME: &'static str = "DeleteTableItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.state_key_hash = is.read_bytes()?;
                },
                18 => {
                    self.handle = is.read_string()?;
                },
                26 => {
                    self.key = is.read_string()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.state_key_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.state_key_hash);
        }
        if !self.handle.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.handle);
        }
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.key);
        }
        if let Some(v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.state_key_hash.is_empty() {
            os.write_bytes(1, &self.state_key_hash)?;
        }
        if !self.handle.is_empty() {
            os.write_string(2, &self.handle)?;
        }
        if !self.key.is_empty() {
            os.write_string(3, &self.key)?;
        }
        if let Some(v) = self.data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteTableItem {
        DeleteTableItem::new()
    }

    fn clear(&mut self) {
        self.state_key_hash.clear();
        self.handle.clear();
        self.key.clear();
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteTableItem {
        static instance: DeleteTableItem = DeleteTableItem {
            state_key_hash: ::std::vec::Vec::new(),
            handle: ::std::string::String::new(),
            key: ::std::string::String::new(),
            data: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteTableItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteTableItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteTableItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteTableItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:DeleteTableData)
pub struct DeleteTableData {
    // message fields
    // @@protoc_insertion_point(field:DeleteTableData.key)
    pub key: ::std::string::String,
    // @@protoc_insertion_point(field:DeleteTableData.key_type)
    pub key_type: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:DeleteTableData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteTableData {
    fn default() -> &'a DeleteTableData {
        <DeleteTableData as ::protobuf::Message>::default_instance()
    }
}

impl DeleteTableData {
    pub fn new() -> DeleteTableData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &DeleteTableData| { &m.key },
            |m: &mut DeleteTableData| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key_type",
            |m: &DeleteTableData| { &m.key_type },
            |m: &mut DeleteTableData| { &mut m.key_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteTableData>(
            "DeleteTableData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteTableData {
    const NAME: &'static str = "DeleteTableData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key = is.read_string()?;
                },
                18 => {
                    self.key_type = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key);
        }
        if !self.key_type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.key_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.key.is_empty() {
            os.write_string(1, &self.key)?;
        }
        if !self.key_type.is_empty() {
            os.write_string(2, &self.key_type)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteTableData {
        DeleteTableData::new()
    }

    fn clear(&mut self) {
        self.key.clear();
        self.key_type.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteTableData {
        static instance: DeleteTableData = DeleteTableData {
            key: ::std::string::String::new(),
            key_type: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteTableData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteTableData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteTableData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteTableData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:WriteModule)
pub struct WriteModule {
    // message fields
    // @@protoc_insertion_point(field:WriteModule.address)
    pub address: ::std::string::String,
    // @@protoc_insertion_point(field:WriteModule.state_key_hash)
    pub state_key_hash: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:WriteModule.data)
    pub data: ::protobuf::MessageField<MoveModuleBytecode>,
    // special fields
    // @@protoc_insertion_point(special_field:WriteModule.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WriteModule {
    fn default() -> &'a WriteModule {
        <WriteModule as ::protobuf::Message>::default_instance()
    }
}

impl WriteModule {
    pub fn new() -> WriteModule {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &WriteModule| { &m.address },
            |m: &mut WriteModule| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state_key_hash",
            |m: &WriteModule| { &m.state_key_hash },
            |m: &mut WriteModule| { &mut m.state_key_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MoveModuleBytecode>(
            "data",
            |m: &WriteModule| { &m.data },
            |m: &mut WriteModule| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WriteModule>(
            "WriteModule",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WriteModule {
    const NAME: &'static str = "WriteModule";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.address = is.read_string()?;
                },
                18 => {
                    self.state_key_hash = is.read_bytes()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if !self.state_key_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.state_key_hash);
        }
        if let Some(v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if !self.state_key_hash.is_empty() {
            os.write_bytes(2, &self.state_key_hash)?;
        }
        if let Some(v) = self.data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WriteModule {
        WriteModule::new()
    }

    fn clear(&mut self) {
        self.address.clear();
        self.state_key_hash.clear();
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WriteModule {
        static instance: WriteModule = WriteModule {
            address: ::std::string::String::new(),
            state_key_hash: ::std::vec::Vec::new(),
            data: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WriteModule {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WriteModule").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WriteModule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WriteModule {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:WriteResource)
pub struct WriteResource {
    // message fields
    // @@protoc_insertion_point(field:WriteResource.address)
    pub address: ::std::string::String,
    // @@protoc_insertion_point(field:WriteResource.state_key_hash)
    pub state_key_hash: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:WriteResource.data)
    pub data: ::protobuf::MessageField<MoveResource>,
    // special fields
    // @@protoc_insertion_point(special_field:WriteResource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WriteResource {
    fn default() -> &'a WriteResource {
        <WriteResource as ::protobuf::Message>::default_instance()
    }
}

impl WriteResource {
    pub fn new() -> WriteResource {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &WriteResource| { &m.address },
            |m: &mut WriteResource| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state_key_hash",
            |m: &WriteResource| { &m.state_key_hash },
            |m: &mut WriteResource| { &mut m.state_key_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MoveResource>(
            "data",
            |m: &WriteResource| { &m.data },
            |m: &mut WriteResource| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WriteResource>(
            "WriteResource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WriteResource {
    const NAME: &'static str = "WriteResource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.address = is.read_string()?;
                },
                18 => {
                    self.state_key_hash = is.read_bytes()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if !self.state_key_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.state_key_hash);
        }
        if let Some(v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if !self.state_key_hash.is_empty() {
            os.write_bytes(2, &self.state_key_hash)?;
        }
        if let Some(v) = self.data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WriteResource {
        WriteResource::new()
    }

    fn clear(&mut self) {
        self.address.clear();
        self.state_key_hash.clear();
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WriteResource {
        static instance: WriteResource = WriteResource {
            address: ::std::string::String::new(),
            state_key_hash: ::std::vec::Vec::new(),
            data: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WriteResource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WriteResource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WriteResource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WriteResource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:WriteTableData)
pub struct WriteTableData {
    // message fields
    // @@protoc_insertion_point(field:WriteTableData.key)
    pub key: ::std::string::String,
    // @@protoc_insertion_point(field:WriteTableData.key_type)
    pub key_type: ::std::string::String,
    // @@protoc_insertion_point(field:WriteTableData.value)
    pub value: ::std::string::String,
    // @@protoc_insertion_point(field:WriteTableData.value_type)
    pub value_type: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:WriteTableData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WriteTableData {
    fn default() -> &'a WriteTableData {
        <WriteTableData as ::protobuf::Message>::default_instance()
    }
}

impl WriteTableData {
    pub fn new() -> WriteTableData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &WriteTableData| { &m.key },
            |m: &mut WriteTableData| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key_type",
            |m: &WriteTableData| { &m.key_type },
            |m: &mut WriteTableData| { &mut m.key_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &WriteTableData| { &m.value },
            |m: &mut WriteTableData| { &mut m.value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value_type",
            |m: &WriteTableData| { &m.value_type },
            |m: &mut WriteTableData| { &mut m.value_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WriteTableData>(
            "WriteTableData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WriteTableData {
    const NAME: &'static str = "WriteTableData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key = is.read_string()?;
                },
                18 => {
                    self.key_type = is.read_string()?;
                },
                26 => {
                    self.value = is.read_string()?;
                },
                34 => {
                    self.value_type = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key);
        }
        if !self.key_type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.key_type);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.value);
        }
        if !self.value_type.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.value_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.key.is_empty() {
            os.write_string(1, &self.key)?;
        }
        if !self.key_type.is_empty() {
            os.write_string(2, &self.key_type)?;
        }
        if !self.value.is_empty() {
            os.write_string(3, &self.value)?;
        }
        if !self.value_type.is_empty() {
            os.write_string(4, &self.value_type)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WriteTableData {
        WriteTableData::new()
    }

    fn clear(&mut self) {
        self.key.clear();
        self.key_type.clear();
        self.value.clear();
        self.value_type.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WriteTableData {
        static instance: WriteTableData = WriteTableData {
            key: ::std::string::String::new(),
            key_type: ::std::string::String::new(),
            value: ::std::string::String::new(),
            value_type: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WriteTableData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WriteTableData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WriteTableData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WriteTableData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:WriteTableItem)
pub struct WriteTableItem {
    // message fields
    // @@protoc_insertion_point(field:WriteTableItem.state_key_hash)
    pub state_key_hash: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:WriteTableItem.handle)
    pub handle: ::std::string::String,
    // @@protoc_insertion_point(field:WriteTableItem.key)
    pub key: ::std::string::String,
    // @@protoc_insertion_point(field:WriteTableItem.data)
    pub data: ::protobuf::MessageField<WriteTableData>,
    // special fields
    // @@protoc_insertion_point(special_field:WriteTableItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WriteTableItem {
    fn default() -> &'a WriteTableItem {
        <WriteTableItem as ::protobuf::Message>::default_instance()
    }
}

impl WriteTableItem {
    pub fn new() -> WriteTableItem {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state_key_hash",
            |m: &WriteTableItem| { &m.state_key_hash },
            |m: &mut WriteTableItem| { &mut m.state_key_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "handle",
            |m: &WriteTableItem| { &m.handle },
            |m: &mut WriteTableItem| { &mut m.handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &WriteTableItem| { &m.key },
            |m: &mut WriteTableItem| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, WriteTableData>(
            "data",
            |m: &WriteTableItem| { &m.data },
            |m: &mut WriteTableItem| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WriteTableItem>(
            "WriteTableItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WriteTableItem {
    const NAME: &'static str = "WriteTableItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.state_key_hash = is.read_bytes()?;
                },
                18 => {
                    self.handle = is.read_string()?;
                },
                26 => {
                    self.key = is.read_string()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.state_key_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.state_key_hash);
        }
        if !self.handle.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.handle);
        }
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.key);
        }
        if let Some(v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.state_key_hash.is_empty() {
            os.write_bytes(1, &self.state_key_hash)?;
        }
        if !self.handle.is_empty() {
            os.write_string(2, &self.handle)?;
        }
        if !self.key.is_empty() {
            os.write_string(3, &self.key)?;
        }
        if let Some(v) = self.data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WriteTableItem {
        WriteTableItem::new()
    }

    fn clear(&mut self) {
        self.state_key_hash.clear();
        self.handle.clear();
        self.key.clear();
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WriteTableItem {
        static instance: WriteTableItem = WriteTableItem {
            state_key_hash: ::std::vec::Vec::new(),
            handle: ::std::string::String::new(),
            key: ::std::string::String::new(),
            data: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WriteTableItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WriteTableItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WriteTableItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WriteTableItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:TransactionPayload)
pub struct TransactionPayload {
    // message fields
    // @@protoc_insertion_point(field:TransactionPayload.type)
    pub type_: ::protobuf::EnumOrUnknown<transaction_payload::Type>,
    // message oneof groups
    pub payload: ::std::option::Option<transaction_payload::Payload>,
    // special fields
    // @@protoc_insertion_point(special_field:TransactionPayload.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TransactionPayload {
    fn default() -> &'a TransactionPayload {
        <TransactionPayload as ::protobuf::Message>::default_instance()
    }
}

impl TransactionPayload {
    pub fn new() -> TransactionPayload {
        ::std::default::Default::default()
    }

    // .ScriptFunctionPayload script_function_payload = 2;

    pub fn script_function_payload(&self) -> &ScriptFunctionPayload {
        match self.payload {
            ::std::option::Option::Some(transaction_payload::Payload::ScriptFunctionPayload(ref v)) => v,
            _ => <ScriptFunctionPayload as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_script_function_payload(&mut self) {
        self.payload = ::std::option::Option::None;
    }

    pub fn has_script_function_payload(&self) -> bool {
        match self.payload {
            ::std::option::Option::Some(transaction_payload::Payload::ScriptFunctionPayload(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_script_function_payload(&mut self, v: ScriptFunctionPayload) {
        self.payload = ::std::option::Option::Some(transaction_payload::Payload::ScriptFunctionPayload(v))
    }

    // Mutable pointer to the field.
    pub fn mut_script_function_payload(&mut self) -> &mut ScriptFunctionPayload {
        if let ::std::option::Option::Some(transaction_payload::Payload::ScriptFunctionPayload(_)) = self.payload {
        } else {
            self.payload = ::std::option::Option::Some(transaction_payload::Payload::ScriptFunctionPayload(ScriptFunctionPayload::new()));
        }
        match self.payload {
            ::std::option::Option::Some(transaction_payload::Payload::ScriptFunctionPayload(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_script_function_payload(&mut self) -> ScriptFunctionPayload {
        if self.has_script_function_payload() {
            match self.payload.take() {
                ::std::option::Option::Some(transaction_payload::Payload::ScriptFunctionPayload(v)) => v,
                _ => panic!(),
            }
        } else {
            ScriptFunctionPayload::new()
        }
    }

    // .ScriptPayload script_payload = 3;

    pub fn script_payload(&self) -> &ScriptPayload {
        match self.payload {
            ::std::option::Option::Some(transaction_payload::Payload::ScriptPayload(ref v)) => v,
            _ => <ScriptPayload as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_script_payload(&mut self) {
        self.payload = ::std::option::Option::None;
    }

    pub fn has_script_payload(&self) -> bool {
        match self.payload {
            ::std::option::Option::Some(transaction_payload::Payload::ScriptPayload(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_script_payload(&mut self, v: ScriptPayload) {
        self.payload = ::std::option::Option::Some(transaction_payload::Payload::ScriptPayload(v))
    }

    // Mutable pointer to the field.
    pub fn mut_script_payload(&mut self) -> &mut ScriptPayload {
        if let ::std::option::Option::Some(transaction_payload::Payload::ScriptPayload(_)) = self.payload {
        } else {
            self.payload = ::std::option::Option::Some(transaction_payload::Payload::ScriptPayload(ScriptPayload::new()));
        }
        match self.payload {
            ::std::option::Option::Some(transaction_payload::Payload::ScriptPayload(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_script_payload(&mut self) -> ScriptPayload {
        if self.has_script_payload() {
            match self.payload.take() {
                ::std::option::Option::Some(transaction_payload::Payload::ScriptPayload(v)) => v,
                _ => panic!(),
            }
        } else {
            ScriptPayload::new()
        }
    }

    // .ModuleBundlePayload module_bundle_payload = 4;

    pub fn module_bundle_payload(&self) -> &ModuleBundlePayload {
        match self.payload {
            ::std::option::Option::Some(transaction_payload::Payload::ModuleBundlePayload(ref v)) => v,
            _ => <ModuleBundlePayload as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_module_bundle_payload(&mut self) {
        self.payload = ::std::option::Option::None;
    }

    pub fn has_module_bundle_payload(&self) -> bool {
        match self.payload {
            ::std::option::Option::Some(transaction_payload::Payload::ModuleBundlePayload(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_module_bundle_payload(&mut self, v: ModuleBundlePayload) {
        self.payload = ::std::option::Option::Some(transaction_payload::Payload::ModuleBundlePayload(v))
    }

    // Mutable pointer to the field.
    pub fn mut_module_bundle_payload(&mut self) -> &mut ModuleBundlePayload {
        if let ::std::option::Option::Some(transaction_payload::Payload::ModuleBundlePayload(_)) = self.payload {
        } else {
            self.payload = ::std::option::Option::Some(transaction_payload::Payload::ModuleBundlePayload(ModuleBundlePayload::new()));
        }
        match self.payload {
            ::std::option::Option::Some(transaction_payload::Payload::ModuleBundlePayload(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_module_bundle_payload(&mut self) -> ModuleBundlePayload {
        if self.has_module_bundle_payload() {
            match self.payload.take() {
                ::std::option::Option::Some(transaction_payload::Payload::ModuleBundlePayload(v)) => v,
                _ => panic!(),
            }
        } else {
            ModuleBundlePayload::new()
        }
    }

    // .WriteSetPayload write_set_payload = 5;

    pub fn write_set_payload(&self) -> &WriteSetPayload {
        match self.payload {
            ::std::option::Option::Some(transaction_payload::Payload::WriteSetPayload(ref v)) => v,
            _ => <WriteSetPayload as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_write_set_payload(&mut self) {
        self.payload = ::std::option::Option::None;
    }

    pub fn has_write_set_payload(&self) -> bool {
        match self.payload {
            ::std::option::Option::Some(transaction_payload::Payload::WriteSetPayload(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_write_set_payload(&mut self, v: WriteSetPayload) {
        self.payload = ::std::option::Option::Some(transaction_payload::Payload::WriteSetPayload(v))
    }

    // Mutable pointer to the field.
    pub fn mut_write_set_payload(&mut self) -> &mut WriteSetPayload {
        if let ::std::option::Option::Some(transaction_payload::Payload::WriteSetPayload(_)) = self.payload {
        } else {
            self.payload = ::std::option::Option::Some(transaction_payload::Payload::WriteSetPayload(WriteSetPayload::new()));
        }
        match self.payload {
            ::std::option::Option::Some(transaction_payload::Payload::WriteSetPayload(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_write_set_payload(&mut self) -> WriteSetPayload {
        if self.has_write_set_payload() {
            match self.payload.take() {
                ::std::option::Option::Some(transaction_payload::Payload::WriteSetPayload(v)) => v,
                _ => panic!(),
            }
        } else {
            WriteSetPayload::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &TransactionPayload| { &m.type_ },
            |m: &mut TransactionPayload| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ScriptFunctionPayload>(
            "script_function_payload",
            TransactionPayload::has_script_function_payload,
            TransactionPayload::script_function_payload,
            TransactionPayload::mut_script_function_payload,
            TransactionPayload::set_script_function_payload,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ScriptPayload>(
            "script_payload",
            TransactionPayload::has_script_payload,
            TransactionPayload::script_payload,
            TransactionPayload::mut_script_payload,
            TransactionPayload::set_script_payload,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, ModuleBundlePayload>(
            "module_bundle_payload",
            TransactionPayload::has_module_bundle_payload,
            TransactionPayload::module_bundle_payload,
            TransactionPayload::mut_module_bundle_payload,
            TransactionPayload::set_module_bundle_payload,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, WriteSetPayload>(
            "write_set_payload",
            TransactionPayload::has_write_set_payload,
            TransactionPayload::write_set_payload,
            TransactionPayload::mut_write_set_payload,
            TransactionPayload::set_write_set_payload,
        ));
        oneofs.push(transaction_payload::Payload::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TransactionPayload>(
            "TransactionPayload",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TransactionPayload {
    const NAME: &'static str = "TransactionPayload";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.payload = ::std::option::Option::Some(transaction_payload::Payload::ScriptFunctionPayload(is.read_message()?));
                },
                26 => {
                    self.payload = ::std::option::Option::Some(transaction_payload::Payload::ScriptPayload(is.read_message()?));
                },
                34 => {
                    self.payload = ::std::option::Option::Some(transaction_payload::Payload::ModuleBundlePayload(is.read_message()?));
                },
                42 => {
                    self.payload = ::std::option::Option::Some(transaction_payload::Payload::WriteSetPayload(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.type_ != ::protobuf::EnumOrUnknown::new(transaction_payload::Type::SCRIPT_FUNCTION_PAYLOAD) {
            my_size += ::protobuf::rt::int32_size(1, self.type_.value());
        }
        if let ::std::option::Option::Some(ref v) = self.payload {
            match v {
                &transaction_payload::Payload::ScriptFunctionPayload(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &transaction_payload::Payload::ScriptPayload(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &transaction_payload::Payload::ModuleBundlePayload(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &transaction_payload::Payload::WriteSetPayload(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.type_ != ::protobuf::EnumOrUnknown::new(transaction_payload::Type::SCRIPT_FUNCTION_PAYLOAD) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if let ::std::option::Option::Some(ref v) = self.payload {
            match v {
                &transaction_payload::Payload::ScriptFunctionPayload(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &transaction_payload::Payload::ScriptPayload(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &transaction_payload::Payload::ModuleBundlePayload(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &transaction_payload::Payload::WriteSetPayload(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TransactionPayload {
        TransactionPayload::new()
    }

    fn clear(&mut self) {
        self.type_ = ::protobuf::EnumOrUnknown::new(transaction_payload::Type::SCRIPT_FUNCTION_PAYLOAD);
        self.payload = ::std::option::Option::None;
        self.payload = ::std::option::Option::None;
        self.payload = ::std::option::Option::None;
        self.payload = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TransactionPayload {
        static instance: TransactionPayload = TransactionPayload {
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            payload: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TransactionPayload {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TransactionPayload").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TransactionPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionPayload {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `TransactionPayload`
pub mod transaction_payload {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:TransactionPayload.payload)
    pub enum Payload {
        // @@protoc_insertion_point(oneof_field:TransactionPayload.script_function_payload)
        ScriptFunctionPayload(super::ScriptFunctionPayload),
        // @@protoc_insertion_point(oneof_field:TransactionPayload.script_payload)
        ScriptPayload(super::ScriptPayload),
        // @@protoc_insertion_point(oneof_field:TransactionPayload.module_bundle_payload)
        ModuleBundlePayload(super::ModuleBundlePayload),
        // @@protoc_insertion_point(oneof_field:TransactionPayload.write_set_payload)
        WriteSetPayload(super::WriteSetPayload),
    }

    impl ::protobuf::Oneof for Payload {
    }

    impl ::protobuf::OneofFull for Payload {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::TransactionPayload as ::protobuf::MessageFull>::descriptor().oneof_by_name("payload").unwrap()).clone()
        }
    }

    impl Payload {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Payload>("payload")
        }
    }
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:TransactionPayload.Type)
    pub enum Type {
        // @@protoc_insertion_point(enum_value:TransactionPayload.Type.SCRIPT_FUNCTION_PAYLOAD)
        SCRIPT_FUNCTION_PAYLOAD = 0,
        // @@protoc_insertion_point(enum_value:TransactionPayload.Type.SCRIPT_PAYLOAD)
        SCRIPT_PAYLOAD = 1,
        // @@protoc_insertion_point(enum_value:TransactionPayload.Type.MODULE_BUNDLE_PAYLOAD)
        MODULE_BUNDLE_PAYLOAD = 2,
        // @@protoc_insertion_point(enum_value:TransactionPayload.Type.WRITE_SET_PAYLOAD)
        WRITE_SET_PAYLOAD = 3,
    }

    impl ::protobuf::Enum for Type {
        const NAME: &'static str = "Type";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Type> {
            match value {
                0 => ::std::option::Option::Some(Type::SCRIPT_FUNCTION_PAYLOAD),
                1 => ::std::option::Option::Some(Type::SCRIPT_PAYLOAD),
                2 => ::std::option::Option::Some(Type::MODULE_BUNDLE_PAYLOAD),
                3 => ::std::option::Option::Some(Type::WRITE_SET_PAYLOAD),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Type] = &[
            Type::SCRIPT_FUNCTION_PAYLOAD,
            Type::SCRIPT_PAYLOAD,
            Type::MODULE_BUNDLE_PAYLOAD,
            Type::WRITE_SET_PAYLOAD,
        ];
    }

    impl ::protobuf::EnumFull for Type {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("TransactionPayload.Type").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Type {
        fn default() -> Self {
            Type::SCRIPT_FUNCTION_PAYLOAD
        }
    }

    impl Type {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Type>("TransactionPayload.Type")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ScriptFunctionPayload)
pub struct ScriptFunctionPayload {
    // message fields
    // @@protoc_insertion_point(field:ScriptFunctionPayload.function)
    pub function: ::protobuf::MessageField<ScriptFunctionId>,
    // @@protoc_insertion_point(field:ScriptFunctionPayload.type_arguments)
    pub type_arguments: ::std::vec::Vec<MoveType>,
    // @@protoc_insertion_point(field:ScriptFunctionPayload.arguments)
    pub arguments: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:ScriptFunctionPayload.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ScriptFunctionPayload {
    fn default() -> &'a ScriptFunctionPayload {
        <ScriptFunctionPayload as ::protobuf::Message>::default_instance()
    }
}

impl ScriptFunctionPayload {
    pub fn new() -> ScriptFunctionPayload {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ScriptFunctionId>(
            "function",
            |m: &ScriptFunctionPayload| { &m.function },
            |m: &mut ScriptFunctionPayload| { &mut m.function },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "type_arguments",
            |m: &ScriptFunctionPayload| { &m.type_arguments },
            |m: &mut ScriptFunctionPayload| { &mut m.type_arguments },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "arguments",
            |m: &ScriptFunctionPayload| { &m.arguments },
            |m: &mut ScriptFunctionPayload| { &mut m.arguments },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ScriptFunctionPayload>(
            "ScriptFunctionPayload",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ScriptFunctionPayload {
    const NAME: &'static str = "ScriptFunctionPayload";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.function)?;
                },
                18 => {
                    self.type_arguments.push(is.read_message()?);
                },
                26 => {
                    self.arguments.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.function.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.type_arguments {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.arguments {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.function.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.type_arguments {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.arguments {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ScriptFunctionPayload {
        ScriptFunctionPayload::new()
    }

    fn clear(&mut self) {
        self.function.clear();
        self.type_arguments.clear();
        self.arguments.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ScriptFunctionPayload {
        static instance: ScriptFunctionPayload = ScriptFunctionPayload {
            function: ::protobuf::MessageField::none(),
            type_arguments: ::std::vec::Vec::new(),
            arguments: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ScriptFunctionPayload {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ScriptFunctionPayload").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ScriptFunctionPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScriptFunctionPayload {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:MoveScriptBytecode)
pub struct MoveScriptBytecode {
    // message fields
    // @@protoc_insertion_point(field:MoveScriptBytecode.bytecode)
    pub bytecode: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:MoveScriptBytecode.abi)
    pub abi: ::protobuf::MessageField<MoveFunction>,
    // special fields
    // @@protoc_insertion_point(special_field:MoveScriptBytecode.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoveScriptBytecode {
    fn default() -> &'a MoveScriptBytecode {
        <MoveScriptBytecode as ::protobuf::Message>::default_instance()
    }
}

impl MoveScriptBytecode {
    pub fn new() -> MoveScriptBytecode {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "bytecode",
            |m: &MoveScriptBytecode| { &m.bytecode },
            |m: &mut MoveScriptBytecode| { &mut m.bytecode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MoveFunction>(
            "abi",
            |m: &MoveScriptBytecode| { &m.abi },
            |m: &mut MoveScriptBytecode| { &mut m.abi },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoveScriptBytecode>(
            "MoveScriptBytecode",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoveScriptBytecode {
    const NAME: &'static str = "MoveScriptBytecode";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.bytecode = is.read_bytes()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.abi)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.bytecode.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.bytecode);
        }
        if let Some(v) = self.abi.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.bytecode.is_empty() {
            os.write_bytes(1, &self.bytecode)?;
        }
        if let Some(v) = self.abi.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoveScriptBytecode {
        MoveScriptBytecode::new()
    }

    fn clear(&mut self) {
        self.bytecode.clear();
        self.abi.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoveScriptBytecode {
        static instance: MoveScriptBytecode = MoveScriptBytecode {
            bytecode: ::std::vec::Vec::new(),
            abi: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoveScriptBytecode {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoveScriptBytecode").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoveScriptBytecode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoveScriptBytecode {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ScriptPayload)
pub struct ScriptPayload {
    // message fields
    // @@protoc_insertion_point(field:ScriptPayload.code)
    pub code: ::protobuf::MessageField<MoveScriptBytecode>,
    // @@protoc_insertion_point(field:ScriptPayload.type_arguments)
    pub type_arguments: ::std::vec::Vec<MoveType>,
    // @@protoc_insertion_point(field:ScriptPayload.arguments)
    pub arguments: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:ScriptPayload.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ScriptPayload {
    fn default() -> &'a ScriptPayload {
        <ScriptPayload as ::protobuf::Message>::default_instance()
    }
}

impl ScriptPayload {
    pub fn new() -> ScriptPayload {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MoveScriptBytecode>(
            "code",
            |m: &ScriptPayload| { &m.code },
            |m: &mut ScriptPayload| { &mut m.code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "type_arguments",
            |m: &ScriptPayload| { &m.type_arguments },
            |m: &mut ScriptPayload| { &mut m.type_arguments },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "arguments",
            |m: &ScriptPayload| { &m.arguments },
            |m: &mut ScriptPayload| { &mut m.arguments },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ScriptPayload>(
            "ScriptPayload",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ScriptPayload {
    const NAME: &'static str = "ScriptPayload";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.code)?;
                },
                18 => {
                    self.type_arguments.push(is.read_message()?);
                },
                26 => {
                    self.arguments.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.code.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.type_arguments {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.arguments {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.code.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.type_arguments {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.arguments {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ScriptPayload {
        ScriptPayload::new()
    }

    fn clear(&mut self) {
        self.code.clear();
        self.type_arguments.clear();
        self.arguments.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ScriptPayload {
        static instance: ScriptPayload = ScriptPayload {
            code: ::protobuf::MessageField::none(),
            type_arguments: ::std::vec::Vec::new(),
            arguments: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ScriptPayload {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ScriptPayload").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ScriptPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScriptPayload {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ModuleBundlePayload)
pub struct ModuleBundlePayload {
    // message fields
    // @@protoc_insertion_point(field:ModuleBundlePayload.modules)
    pub modules: ::std::vec::Vec<MoveModuleBytecode>,
    // special fields
    // @@protoc_insertion_point(special_field:ModuleBundlePayload.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ModuleBundlePayload {
    fn default() -> &'a ModuleBundlePayload {
        <ModuleBundlePayload as ::protobuf::Message>::default_instance()
    }
}

impl ModuleBundlePayload {
    pub fn new() -> ModuleBundlePayload {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "modules",
            |m: &ModuleBundlePayload| { &m.modules },
            |m: &mut ModuleBundlePayload| { &mut m.modules },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ModuleBundlePayload>(
            "ModuleBundlePayload",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ModuleBundlePayload {
    const NAME: &'static str = "ModuleBundlePayload";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.modules.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.modules {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.modules {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ModuleBundlePayload {
        ModuleBundlePayload::new()
    }

    fn clear(&mut self) {
        self.modules.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ModuleBundlePayload {
        static instance: ModuleBundlePayload = ModuleBundlePayload {
            modules: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ModuleBundlePayload {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ModuleBundlePayload").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ModuleBundlePayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModuleBundlePayload {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:MoveModuleBytecode)
pub struct MoveModuleBytecode {
    // message fields
    // @@protoc_insertion_point(field:MoveModuleBytecode.bytecode)
    pub bytecode: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:MoveModuleBytecode.abi)
    pub abi: ::protobuf::MessageField<MoveModule>,
    // special fields
    // @@protoc_insertion_point(special_field:MoveModuleBytecode.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoveModuleBytecode {
    fn default() -> &'a MoveModuleBytecode {
        <MoveModuleBytecode as ::protobuf::Message>::default_instance()
    }
}

impl MoveModuleBytecode {
    pub fn new() -> MoveModuleBytecode {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "bytecode",
            |m: &MoveModuleBytecode| { &m.bytecode },
            |m: &mut MoveModuleBytecode| { &mut m.bytecode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MoveModule>(
            "abi",
            |m: &MoveModuleBytecode| { &m.abi },
            |m: &mut MoveModuleBytecode| { &mut m.abi },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoveModuleBytecode>(
            "MoveModuleBytecode",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoveModuleBytecode {
    const NAME: &'static str = "MoveModuleBytecode";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.bytecode = is.read_bytes()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.abi)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.bytecode.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.bytecode);
        }
        if let Some(v) = self.abi.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.bytecode.is_empty() {
            os.write_bytes(1, &self.bytecode)?;
        }
        if let Some(v) = self.abi.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoveModuleBytecode {
        MoveModuleBytecode::new()
    }

    fn clear(&mut self) {
        self.bytecode.clear();
        self.abi.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoveModuleBytecode {
        static instance: MoveModuleBytecode = MoveModuleBytecode {
            bytecode: ::std::vec::Vec::new(),
            abi: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoveModuleBytecode {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoveModuleBytecode").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoveModuleBytecode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoveModuleBytecode {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:MoveModule)
pub struct MoveModule {
    // message fields
    // @@protoc_insertion_point(field:MoveModule.address)
    pub address: ::std::string::String,
    // @@protoc_insertion_point(field:MoveModule.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:MoveModule.friends)
    pub friends: ::std::vec::Vec<MoveModuleId>,
    // @@protoc_insertion_point(field:MoveModule.exposed_functions)
    pub exposed_functions: ::std::vec::Vec<MoveFunction>,
    // @@protoc_insertion_point(field:MoveModule.structs)
    pub structs: ::std::vec::Vec<MoveStruct>,
    // special fields
    // @@protoc_insertion_point(special_field:MoveModule.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoveModule {
    fn default() -> &'a MoveModule {
        <MoveModule as ::protobuf::Message>::default_instance()
    }
}

impl MoveModule {
    pub fn new() -> MoveModule {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &MoveModule| { &m.address },
            |m: &mut MoveModule| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &MoveModule| { &m.name },
            |m: &mut MoveModule| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "friends",
            |m: &MoveModule| { &m.friends },
            |m: &mut MoveModule| { &mut m.friends },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "exposed_functions",
            |m: &MoveModule| { &m.exposed_functions },
            |m: &mut MoveModule| { &mut m.exposed_functions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "structs",
            |m: &MoveModule| { &m.structs },
            |m: &mut MoveModule| { &mut m.structs },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoveModule>(
            "MoveModule",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoveModule {
    const NAME: &'static str = "MoveModule";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.address = is.read_string()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                26 => {
                    self.friends.push(is.read_message()?);
                },
                34 => {
                    self.exposed_functions.push(is.read_message()?);
                },
                42 => {
                    self.structs.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        for value in &self.friends {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.exposed_functions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.structs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        for v in &self.friends {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.exposed_functions {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.structs {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoveModule {
        MoveModule::new()
    }

    fn clear(&mut self) {
        self.address.clear();
        self.name.clear();
        self.friends.clear();
        self.exposed_functions.clear();
        self.structs.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoveModule {
        static instance: MoveModule = MoveModule {
            address: ::std::string::String::new(),
            name: ::std::string::String::new(),
            friends: ::std::vec::Vec::new(),
            exposed_functions: ::std::vec::Vec::new(),
            structs: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoveModule {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoveModule").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoveModule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoveModule {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:MoveFunction)
pub struct MoveFunction {
    // message fields
    // @@protoc_insertion_point(field:MoveFunction.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:MoveFunction.visibility)
    pub visibility: ::protobuf::EnumOrUnknown<move_function::Visibility>,
    // @@protoc_insertion_point(field:MoveFunction.is_entry)
    pub is_entry: bool,
    // @@protoc_insertion_point(field:MoveFunction.generic_type_params)
    pub generic_type_params: ::std::vec::Vec<MoveFunctionGenericTypeParam>,
    // @@protoc_insertion_point(field:MoveFunction.params)
    pub params: ::std::vec::Vec<MoveType>,
    // @@protoc_insertion_point(field:MoveFunction.return)
    pub return_: ::std::vec::Vec<MoveType>,
    // special fields
    // @@protoc_insertion_point(special_field:MoveFunction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoveFunction {
    fn default() -> &'a MoveFunction {
        <MoveFunction as ::protobuf::Message>::default_instance()
    }
}

impl MoveFunction {
    pub fn new() -> MoveFunction {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &MoveFunction| { &m.name },
            |m: &mut MoveFunction| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "visibility",
            |m: &MoveFunction| { &m.visibility },
            |m: &mut MoveFunction| { &mut m.visibility },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_entry",
            |m: &MoveFunction| { &m.is_entry },
            |m: &mut MoveFunction| { &mut m.is_entry },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "generic_type_params",
            |m: &MoveFunction| { &m.generic_type_params },
            |m: &mut MoveFunction| { &mut m.generic_type_params },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "params",
            |m: &MoveFunction| { &m.params },
            |m: &mut MoveFunction| { &mut m.params },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "return",
            |m: &MoveFunction| { &m.return_ },
            |m: &mut MoveFunction| { &mut m.return_ },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoveFunction>(
            "MoveFunction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoveFunction {
    const NAME: &'static str = "MoveFunction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                16 => {
                    self.visibility = is.read_enum_or_unknown()?;
                },
                24 => {
                    self.is_entry = is.read_bool()?;
                },
                34 => {
                    self.generic_type_params.push(is.read_message()?);
                },
                42 => {
                    self.params.push(is.read_message()?);
                },
                50 => {
                    self.return_.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.visibility != ::protobuf::EnumOrUnknown::new(move_function::Visibility::PRIVATE) {
            my_size += ::protobuf::rt::int32_size(2, self.visibility.value());
        }
        if self.is_entry != false {
            my_size += 1 + 1;
        }
        for value in &self.generic_type_params {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.params {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.return_ {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.visibility != ::protobuf::EnumOrUnknown::new(move_function::Visibility::PRIVATE) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.visibility))?;
        }
        if self.is_entry != false {
            os.write_bool(3, self.is_entry)?;
        }
        for v in &self.generic_type_params {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.params {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        for v in &self.return_ {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoveFunction {
        MoveFunction::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.visibility = ::protobuf::EnumOrUnknown::new(move_function::Visibility::PRIVATE);
        self.is_entry = false;
        self.generic_type_params.clear();
        self.params.clear();
        self.return_.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoveFunction {
        static instance: MoveFunction = MoveFunction {
            name: ::std::string::String::new(),
            visibility: ::protobuf::EnumOrUnknown::from_i32(0),
            is_entry: false,
            generic_type_params: ::std::vec::Vec::new(),
            params: ::std::vec::Vec::new(),
            return_: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoveFunction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoveFunction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoveFunction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoveFunction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `MoveFunction`
pub mod move_function {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:MoveFunction.Visibility)
    pub enum Visibility {
        // @@protoc_insertion_point(enum_value:MoveFunction.Visibility.PRIVATE)
        PRIVATE = 0,
        // @@protoc_insertion_point(enum_value:MoveFunction.Visibility.PUBLIC)
        PUBLIC = 1,
        // @@protoc_insertion_point(enum_value:MoveFunction.Visibility.FRIEND)
        FRIEND = 2,
    }

    impl ::protobuf::Enum for Visibility {
        const NAME: &'static str = "Visibility";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Visibility> {
            match value {
                0 => ::std::option::Option::Some(Visibility::PRIVATE),
                1 => ::std::option::Option::Some(Visibility::PUBLIC),
                2 => ::std::option::Option::Some(Visibility::FRIEND),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Visibility] = &[
            Visibility::PRIVATE,
            Visibility::PUBLIC,
            Visibility::FRIEND,
        ];
    }

    impl ::protobuf::EnumFull for Visibility {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("MoveFunction.Visibility").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Visibility {
        fn default() -> Self {
            Visibility::PRIVATE
        }
    }

    impl Visibility {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Visibility>("MoveFunction.Visibility")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:MoveStruct)
pub struct MoveStruct {
    // message fields
    // @@protoc_insertion_point(field:MoveStruct.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:MoveStruct.is_native)
    pub is_native: bool,
    // @@protoc_insertion_point(field:MoveStruct.abilities)
    pub abilities: ::std::vec::Vec<::protobuf::EnumOrUnknown<MoveAbility>>,
    // @@protoc_insertion_point(field:MoveStruct.generic_type_params)
    pub generic_type_params: ::std::vec::Vec<MoveStructGenericTypeParam>,
    // @@protoc_insertion_point(field:MoveStruct.fields)
    pub fields: ::std::vec::Vec<MoveStructField>,
    // special fields
    // @@protoc_insertion_point(special_field:MoveStruct.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoveStruct {
    fn default() -> &'a MoveStruct {
        <MoveStruct as ::protobuf::Message>::default_instance()
    }
}

impl MoveStruct {
    pub fn new() -> MoveStruct {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &MoveStruct| { &m.name },
            |m: &mut MoveStruct| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_native",
            |m: &MoveStruct| { &m.is_native },
            |m: &mut MoveStruct| { &mut m.is_native },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "abilities",
            |m: &MoveStruct| { &m.abilities },
            |m: &mut MoveStruct| { &mut m.abilities },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "generic_type_params",
            |m: &MoveStruct| { &m.generic_type_params },
            |m: &mut MoveStruct| { &mut m.generic_type_params },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "fields",
            |m: &MoveStruct| { &m.fields },
            |m: &mut MoveStruct| { &mut m.fields },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoveStruct>(
            "MoveStruct",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoveStruct {
    const NAME: &'static str = "MoveStruct";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                16 => {
                    self.is_native = is.read_bool()?;
                },
                24 => {
                    self.abilities.push(is.read_enum_or_unknown()?);
                },
                26 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.abilities)?
                },
                34 => {
                    self.generic_type_params.push(is.read_message()?);
                },
                42 => {
                    self.fields.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.is_native != false {
            my_size += 1 + 1;
        }
        for value in &self.abilities {
            my_size += ::protobuf::rt::int32_size(3, value.value());
        };
        for value in &self.generic_type_params {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.fields {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.is_native != false {
            os.write_bool(2, self.is_native)?;
        }
        for v in &self.abilities {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(v))?;
        };
        for v in &self.generic_type_params {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.fields {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoveStruct {
        MoveStruct::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.is_native = false;
        self.abilities.clear();
        self.generic_type_params.clear();
        self.fields.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoveStruct {
        static instance: MoveStruct = MoveStruct {
            name: ::std::string::String::new(),
            is_native: false,
            abilities: ::std::vec::Vec::new(),
            generic_type_params: ::std::vec::Vec::new(),
            fields: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoveStruct {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoveStruct").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoveStruct {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoveStruct {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:MoveStructGenericTypeParam)
pub struct MoveStructGenericTypeParam {
    // message fields
    // @@protoc_insertion_point(field:MoveStructGenericTypeParam.constraints)
    pub constraints: ::std::vec::Vec<::protobuf::EnumOrUnknown<MoveAbility>>,
    // @@protoc_insertion_point(field:MoveStructGenericTypeParam.is_phantom)
    pub is_phantom: bool,
    // special fields
    // @@protoc_insertion_point(special_field:MoveStructGenericTypeParam.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoveStructGenericTypeParam {
    fn default() -> &'a MoveStructGenericTypeParam {
        <MoveStructGenericTypeParam as ::protobuf::Message>::default_instance()
    }
}

impl MoveStructGenericTypeParam {
    pub fn new() -> MoveStructGenericTypeParam {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "constraints",
            |m: &MoveStructGenericTypeParam| { &m.constraints },
            |m: &mut MoveStructGenericTypeParam| { &mut m.constraints },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_phantom",
            |m: &MoveStructGenericTypeParam| { &m.is_phantom },
            |m: &mut MoveStructGenericTypeParam| { &mut m.is_phantom },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoveStructGenericTypeParam>(
            "MoveStructGenericTypeParam",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoveStructGenericTypeParam {
    const NAME: &'static str = "MoveStructGenericTypeParam";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.constraints.push(is.read_enum_or_unknown()?);
                },
                10 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.constraints)?
                },
                16 => {
                    self.is_phantom = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.constraints {
            my_size += ::protobuf::rt::int32_size(1, value.value());
        };
        if self.is_phantom != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.constraints {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(v))?;
        };
        if self.is_phantom != false {
            os.write_bool(2, self.is_phantom)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoveStructGenericTypeParam {
        MoveStructGenericTypeParam::new()
    }

    fn clear(&mut self) {
        self.constraints.clear();
        self.is_phantom = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoveStructGenericTypeParam {
        static instance: MoveStructGenericTypeParam = MoveStructGenericTypeParam {
            constraints: ::std::vec::Vec::new(),
            is_phantom: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoveStructGenericTypeParam {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoveStructGenericTypeParam").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoveStructGenericTypeParam {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoveStructGenericTypeParam {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:MoveStructField)
pub struct MoveStructField {
    // message fields
    // @@protoc_insertion_point(field:MoveStructField.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:MoveStructField.type)
    pub type_: ::protobuf::MessageField<MoveType>,
    // special fields
    // @@protoc_insertion_point(special_field:MoveStructField.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoveStructField {
    fn default() -> &'a MoveStructField {
        <MoveStructField as ::protobuf::Message>::default_instance()
    }
}

impl MoveStructField {
    pub fn new() -> MoveStructField {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &MoveStructField| { &m.name },
            |m: &mut MoveStructField| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MoveType>(
            "type",
            |m: &MoveStructField| { &m.type_ },
            |m: &mut MoveStructField| { &mut m.type_ },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoveStructField>(
            "MoveStructField",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoveStructField {
    const NAME: &'static str = "MoveStructField";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.type_)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if let Some(v) = self.type_.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if let Some(v) = self.type_.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoveStructField {
        MoveStructField::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.type_.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoveStructField {
        static instance: MoveStructField = MoveStructField {
            name: ::std::string::String::new(),
            type_: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoveStructField {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoveStructField").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoveStructField {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoveStructField {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:MoveFunctionGenericTypeParam)
pub struct MoveFunctionGenericTypeParam {
    // message fields
    // @@protoc_insertion_point(field:MoveFunctionGenericTypeParam.constraints)
    pub constraints: ::std::vec::Vec<::protobuf::EnumOrUnknown<MoveAbility>>,
    // special fields
    // @@protoc_insertion_point(special_field:MoveFunctionGenericTypeParam.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoveFunctionGenericTypeParam {
    fn default() -> &'a MoveFunctionGenericTypeParam {
        <MoveFunctionGenericTypeParam as ::protobuf::Message>::default_instance()
    }
}

impl MoveFunctionGenericTypeParam {
    pub fn new() -> MoveFunctionGenericTypeParam {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "constraints",
            |m: &MoveFunctionGenericTypeParam| { &m.constraints },
            |m: &mut MoveFunctionGenericTypeParam| { &mut m.constraints },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoveFunctionGenericTypeParam>(
            "MoveFunctionGenericTypeParam",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoveFunctionGenericTypeParam {
    const NAME: &'static str = "MoveFunctionGenericTypeParam";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.constraints.push(is.read_enum_or_unknown()?);
                },
                10 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.constraints)?
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.constraints {
            my_size += ::protobuf::rt::int32_size(1, value.value());
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.constraints {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(v))?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoveFunctionGenericTypeParam {
        MoveFunctionGenericTypeParam::new()
    }

    fn clear(&mut self) {
        self.constraints.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoveFunctionGenericTypeParam {
        static instance: MoveFunctionGenericTypeParam = MoveFunctionGenericTypeParam {
            constraints: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoveFunctionGenericTypeParam {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoveFunctionGenericTypeParam").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoveFunctionGenericTypeParam {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoveFunctionGenericTypeParam {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:MoveType)
pub struct MoveType {
    // message fields
    // @@protoc_insertion_point(field:MoveType.type)
    pub type_: ::protobuf::EnumOrUnknown<MoveTypes>,
    // message oneof groups
    pub content: ::std::option::Option<move_type::Content>,
    // special fields
    // @@protoc_insertion_point(special_field:MoveType.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoveType {
    fn default() -> &'a MoveType {
        <MoveType as ::protobuf::Message>::default_instance()
    }
}

impl MoveType {
    pub fn new() -> MoveType {
        ::std::default::Default::default()
    }

    // .MoveType vector = 3;

    pub fn vector(&self) -> &MoveType {
        match self.content {
            ::std::option::Option::Some(move_type::Content::Vector(ref v)) => v,
            _ => <MoveType as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_vector(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_vector(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(move_type::Content::Vector(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_vector(&mut self, v: MoveType) {
        self.content = ::std::option::Option::Some(move_type::Content::Vector(::std::boxed::Box::new(v)))
    }

    // Mutable pointer to the field.
    pub fn mut_vector(&mut self) -> &mut MoveType {
        if let ::std::option::Option::Some(move_type::Content::Vector(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(move_type::Content::Vector(::std::boxed::Box::new(MoveType::new())));
        }
        match self.content {
            ::std::option::Option::Some(move_type::Content::Vector(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_vector(&mut self) -> MoveType {
        if self.has_vector() {
            match self.content.take() {
                ::std::option::Option::Some(move_type::Content::Vector(v)) => *v,
                _ => panic!(),
            }
        } else {
            MoveType::new()
        }
    }

    // .MoveStructTag struct = 4;

    pub fn struct_(&self) -> &MoveStructTag {
        match self.content {
            ::std::option::Option::Some(move_type::Content::Struct(ref v)) => v,
            _ => <MoveStructTag as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_struct_(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_struct(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(move_type::Content::Struct(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_struct(&mut self, v: MoveStructTag) {
        self.content = ::std::option::Option::Some(move_type::Content::Struct(v))
    }

    // Mutable pointer to the field.
    pub fn mut_struct(&mut self) -> &mut MoveStructTag {
        if let ::std::option::Option::Some(move_type::Content::Struct(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(move_type::Content::Struct(MoveStructTag::new()));
        }
        match self.content {
            ::std::option::Option::Some(move_type::Content::Struct(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_struct_(&mut self) -> MoveStructTag {
        if self.has_struct() {
            match self.content.take() {
                ::std::option::Option::Some(move_type::Content::Struct(v)) => v,
                _ => panic!(),
            }
        } else {
            MoveStructTag::new()
        }
    }

    // uint32 generic_type_param_index = 5;

    pub fn generic_type_param_index(&self) -> u32 {
        match self.content {
            ::std::option::Option::Some(move_type::Content::GenericTypeParamIndex(v)) => v,
            _ => 0,
        }
    }

    pub fn clear_generic_type_param_index(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_generic_type_param_index(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(move_type::Content::GenericTypeParamIndex(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_generic_type_param_index(&mut self, v: u32) {
        self.content = ::std::option::Option::Some(move_type::Content::GenericTypeParamIndex(v))
    }

    // .MoveType.ReferenceType reference = 6;

    pub fn reference(&self) -> &move_type::ReferenceType {
        match self.content {
            ::std::option::Option::Some(move_type::Content::Reference(ref v)) => v,
            _ => <move_type::ReferenceType as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_reference(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_reference(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(move_type::Content::Reference(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_reference(&mut self, v: move_type::ReferenceType) {
        self.content = ::std::option::Option::Some(move_type::Content::Reference(v))
    }

    // Mutable pointer to the field.
    pub fn mut_reference(&mut self) -> &mut move_type::ReferenceType {
        if let ::std::option::Option::Some(move_type::Content::Reference(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(move_type::Content::Reference(move_type::ReferenceType::new()));
        }
        match self.content {
            ::std::option::Option::Some(move_type::Content::Reference(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_reference(&mut self) -> move_type::ReferenceType {
        if self.has_reference() {
            match self.content.take() {
                ::std::option::Option::Some(move_type::Content::Reference(v)) => v,
                _ => panic!(),
            }
        } else {
            move_type::ReferenceType::new()
        }
    }

    // string unparsable = 7;

    pub fn unparsable(&self) -> &str {
        match self.content {
            ::std::option::Option::Some(move_type::Content::Unparsable(ref v)) => v,
            _ => "",
        }
    }

    pub fn clear_unparsable(&mut self) {
        self.content = ::std::option::Option::None;
    }

    pub fn has_unparsable(&self) -> bool {
        match self.content {
            ::std::option::Option::Some(move_type::Content::Unparsable(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_unparsable(&mut self, v: ::std::string::String) {
        self.content = ::std::option::Option::Some(move_type::Content::Unparsable(v))
    }

    // Mutable pointer to the field.
    pub fn mut_unparsable(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(move_type::Content::Unparsable(_)) = self.content {
        } else {
            self.content = ::std::option::Option::Some(move_type::Content::Unparsable(::std::string::String::new()));
        }
        match self.content {
            ::std::option::Option::Some(move_type::Content::Unparsable(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_unparsable(&mut self) -> ::std::string::String {
        if self.has_unparsable() {
            match self.content.take() {
                ::std::option::Option::Some(move_type::Content::Unparsable(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &MoveType| { &m.type_ },
            |m: &mut MoveType| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, MoveType>(
            "vector",
            MoveType::has_vector,
            MoveType::vector,
            MoveType::mut_vector,
            MoveType::set_vector,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, MoveStructTag>(
            "struct",
            MoveType::has_struct,
            MoveType::struct_,
            MoveType::mut_struct,
            MoveType::set_struct,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
            "generic_type_param_index",
            MoveType::has_generic_type_param_index,
            MoveType::generic_type_param_index,
            MoveType::set_generic_type_param_index,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, move_type::ReferenceType>(
            "reference",
            MoveType::has_reference,
            MoveType::reference,
            MoveType::mut_reference,
            MoveType::set_reference,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
            "unparsable",
            MoveType::has_unparsable,
            MoveType::unparsable,
            MoveType::set_unparsable,
        ));
        oneofs.push(move_type::Content::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoveType>(
            "MoveType",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoveType {
    const NAME: &'static str = "MoveType";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                26 => {
                    self.content = ::std::option::Option::Some(move_type::Content::Vector(::std::boxed::Box::new(is.read_message()?)));
                },
                34 => {
                    self.content = ::std::option::Option::Some(move_type::Content::Struct(is.read_message()?));
                },
                40 => {
                    self.content = ::std::option::Option::Some(move_type::Content::GenericTypeParamIndex(is.read_uint32()?));
                },
                50 => {
                    self.content = ::std::option::Option::Some(move_type::Content::Reference(is.read_message()?));
                },
                58 => {
                    self.content = ::std::option::Option::Some(move_type::Content::Unparsable(is.read_string()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.type_ != ::protobuf::EnumOrUnknown::new(MoveTypes::Bool) {
            my_size += ::protobuf::rt::int32_size(1, self.type_.value());
        }
        if let ::std::option::Option::Some(ref v) = self.content {
            match v {
                &move_type::Content::Vector(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &move_type::Content::Struct(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &move_type::Content::GenericTypeParamIndex(v) => {
                    my_size += ::protobuf::rt::uint32_size(5, v);
                },
                &move_type::Content::Reference(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &move_type::Content::Unparsable(ref v) => {
                    my_size += ::protobuf::rt::string_size(7, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.type_ != ::protobuf::EnumOrUnknown::new(MoveTypes::Bool) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if let ::std::option::Option::Some(ref v) = self.content {
            match v {
                &move_type::Content::Vector(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, &**v, os)?;
                },
                &move_type::Content::Struct(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &move_type::Content::GenericTypeParamIndex(v) => {
                    os.write_uint32(5, v)?;
                },
                &move_type::Content::Reference(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &move_type::Content::Unparsable(ref v) => {
                    os.write_string(7, v)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoveType {
        MoveType::new()
    }

    fn clear(&mut self) {
        self.type_ = ::protobuf::EnumOrUnknown::new(MoveTypes::Bool);
        self.content = ::std::option::Option::None;
        self.content = ::std::option::Option::None;
        self.content = ::std::option::Option::None;
        self.content = ::std::option::Option::None;
        self.content = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoveType {
        static instance: MoveType = MoveType {
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            content: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoveType {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoveType").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoveType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoveType {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `MoveType`
pub mod move_type {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:MoveType.content)
    pub enum Content {
        // @@protoc_insertion_point(oneof_field:MoveType.vector)
        Vector(::std::boxed::Box<super::MoveType>),
        // @@protoc_insertion_point(oneof_field:MoveType.struct)
        Struct(super::MoveStructTag),
        // @@protoc_insertion_point(oneof_field:MoveType.generic_type_param_index)
        GenericTypeParamIndex(u32),
        // @@protoc_insertion_point(oneof_field:MoveType.reference)
        Reference(ReferenceType),
        // @@protoc_insertion_point(oneof_field:MoveType.unparsable)
        Unparsable(::std::string::String),
    }

    impl ::protobuf::Oneof for Content {
    }

    impl ::protobuf::OneofFull for Content {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::MoveType as ::protobuf::MessageFull>::descriptor().oneof_by_name("content").unwrap()).clone()
        }
    }

    impl Content {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Content>("content")
        }
    }
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:MoveType.ReferenceType)
    pub struct ReferenceType {
        // message fields
        // @@protoc_insertion_point(field:MoveType.ReferenceType.mutable)
        pub mutable: bool,
        // @@protoc_insertion_point(field:MoveType.ReferenceType.to)
        pub to: ::protobuf::MessageField<super::MoveType>,
        // special fields
        // @@protoc_insertion_point(special_field:MoveType.ReferenceType.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ReferenceType {
        fn default() -> &'a ReferenceType {
            <ReferenceType as ::protobuf::Message>::default_instance()
        }
    }

    impl ReferenceType {
        pub fn new() -> ReferenceType {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "mutable",
                |m: &ReferenceType| { &m.mutable },
                |m: &mut ReferenceType| { &mut m.mutable },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::MoveType>(
                "to",
                |m: &ReferenceType| { &m.to },
                |m: &mut ReferenceType| { &mut m.to },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ReferenceType>(
                "MoveType.ReferenceType",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ReferenceType {
        const NAME: &'static str = "ReferenceType";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.mutable = is.read_bool()?;
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.to)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.mutable != false {
                my_size += 1 + 1;
            }
            if let Some(v) = self.to.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.mutable != false {
                os.write_bool(1, self.mutable)?;
            }
            if let Some(v) = self.to.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ReferenceType {
            ReferenceType::new()
        }

        fn clear(&mut self) {
            self.mutable = false;
            self.to.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ReferenceType {
            static instance: ReferenceType = ReferenceType {
                mutable: false,
                to: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ReferenceType {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("MoveType.ReferenceType").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ReferenceType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ReferenceType {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:WriteSetPayload)
pub struct WriteSetPayload {
    // message fields
    // @@protoc_insertion_point(field:WriteSetPayload.write_set)
    pub write_set: ::protobuf::MessageField<WriteSet>,
    // special fields
    // @@protoc_insertion_point(special_field:WriteSetPayload.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WriteSetPayload {
    fn default() -> &'a WriteSetPayload {
        <WriteSetPayload as ::protobuf::Message>::default_instance()
    }
}

impl WriteSetPayload {
    pub fn new() -> WriteSetPayload {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, WriteSet>(
            "write_set",
            |m: &WriteSetPayload| { &m.write_set },
            |m: &mut WriteSetPayload| { &mut m.write_set },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WriteSetPayload>(
            "WriteSetPayload",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WriteSetPayload {
    const NAME: &'static str = "WriteSetPayload";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.write_set)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.write_set.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.write_set.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WriteSetPayload {
        WriteSetPayload::new()
    }

    fn clear(&mut self) {
        self.write_set.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WriteSetPayload {
        static instance: WriteSetPayload = WriteSetPayload {
            write_set: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WriteSetPayload {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WriteSetPayload").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WriteSetPayload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WriteSetPayload {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ScriptFunctionId)
pub struct ScriptFunctionId {
    // message fields
    // @@protoc_insertion_point(field:ScriptFunctionId.module)
    pub module: ::protobuf::MessageField<MoveModuleId>,
    // @@protoc_insertion_point(field:ScriptFunctionId.name)
    pub name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:ScriptFunctionId.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ScriptFunctionId {
    fn default() -> &'a ScriptFunctionId {
        <ScriptFunctionId as ::protobuf::Message>::default_instance()
    }
}

impl ScriptFunctionId {
    pub fn new() -> ScriptFunctionId {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MoveModuleId>(
            "module",
            |m: &ScriptFunctionId| { &m.module },
            |m: &mut ScriptFunctionId| { &mut m.module },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ScriptFunctionId| { &m.name },
            |m: &mut ScriptFunctionId| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ScriptFunctionId>(
            "ScriptFunctionId",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ScriptFunctionId {
    const NAME: &'static str = "ScriptFunctionId";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.module)?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.module.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.module.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ScriptFunctionId {
        ScriptFunctionId::new()
    }

    fn clear(&mut self) {
        self.module.clear();
        self.name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ScriptFunctionId {
        static instance: ScriptFunctionId = ScriptFunctionId {
            module: ::protobuf::MessageField::none(),
            name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ScriptFunctionId {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ScriptFunctionId").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ScriptFunctionId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScriptFunctionId {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:MoveResource)
pub struct MoveResource {
    // message fields
    // @@protoc_insertion_point(field:MoveResource.type)
    pub type_: ::protobuf::MessageField<MoveStructTag>,
    // @@protoc_insertion_point(field:MoveResource.data)
    pub data: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:MoveResource.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoveResource {
    fn default() -> &'a MoveResource {
        <MoveResource as ::protobuf::Message>::default_instance()
    }
}

impl MoveResource {
    pub fn new() -> MoveResource {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MoveStructTag>(
            "type",
            |m: &MoveResource| { &m.type_ },
            |m: &mut MoveResource| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data",
            |m: &MoveResource| { &m.data },
            |m: &mut MoveResource| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoveResource>(
            "MoveResource",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoveResource {
    const NAME: &'static str = "MoveResource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.type_)?;
                },
                18 => {
                    self.data = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.data.is_empty() {
            os.write_string(2, &self.data)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoveResource {
        MoveResource::new()
    }

    fn clear(&mut self) {
        self.type_.clear();
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoveResource {
        static instance: MoveResource = MoveResource {
            type_: ::protobuf::MessageField::none(),
            data: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoveResource {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoveResource").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoveResource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoveResource {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:MoveModuleId)
pub struct MoveModuleId {
    // message fields
    // @@protoc_insertion_point(field:MoveModuleId.address)
    pub address: ::std::string::String,
    // @@protoc_insertion_point(field:MoveModuleId.name)
    pub name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:MoveModuleId.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoveModuleId {
    fn default() -> &'a MoveModuleId {
        <MoveModuleId as ::protobuf::Message>::default_instance()
    }
}

impl MoveModuleId {
    pub fn new() -> MoveModuleId {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &MoveModuleId| { &m.address },
            |m: &mut MoveModuleId| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &MoveModuleId| { &m.name },
            |m: &mut MoveModuleId| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoveModuleId>(
            "MoveModuleId",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoveModuleId {
    const NAME: &'static str = "MoveModuleId";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.address = is.read_string()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoveModuleId {
        MoveModuleId::new()
    }

    fn clear(&mut self) {
        self.address.clear();
        self.name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoveModuleId {
        static instance: MoveModuleId = MoveModuleId {
            address: ::std::string::String::new(),
            name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoveModuleId {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoveModuleId").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoveModuleId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoveModuleId {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:MoveStructTag)
pub struct MoveStructTag {
    // message fields
    // @@protoc_insertion_point(field:MoveStructTag.address)
    pub address: ::std::string::String,
    // @@protoc_insertion_point(field:MoveStructTag.module)
    pub module: ::std::string::String,
    // @@protoc_insertion_point(field:MoveStructTag.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:MoveStructTag.generic_type_params)
    pub generic_type_params: ::std::vec::Vec<MoveType>,
    // special fields
    // @@protoc_insertion_point(special_field:MoveStructTag.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MoveStructTag {
    fn default() -> &'a MoveStructTag {
        <MoveStructTag as ::protobuf::Message>::default_instance()
    }
}

impl MoveStructTag {
    pub fn new() -> MoveStructTag {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &MoveStructTag| { &m.address },
            |m: &mut MoveStructTag| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "module",
            |m: &MoveStructTag| { &m.module },
            |m: &mut MoveStructTag| { &mut m.module },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &MoveStructTag| { &m.name },
            |m: &mut MoveStructTag| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "generic_type_params",
            |m: &MoveStructTag| { &m.generic_type_params },
            |m: &mut MoveStructTag| { &mut m.generic_type_params },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MoveStructTag>(
            "MoveStructTag",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MoveStructTag {
    const NAME: &'static str = "MoveStructTag";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.address = is.read_string()?;
                },
                18 => {
                    self.module = is.read_string()?;
                },
                26 => {
                    self.name = is.read_string()?;
                },
                34 => {
                    self.generic_type_params.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if !self.module.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.module);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        for value in &self.generic_type_params {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if !self.module.is_empty() {
            os.write_string(2, &self.module)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        for v in &self.generic_type_params {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MoveStructTag {
        MoveStructTag::new()
    }

    fn clear(&mut self) {
        self.address.clear();
        self.module.clear();
        self.name.clear();
        self.generic_type_params.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MoveStructTag {
        static instance: MoveStructTag = MoveStructTag {
            address: ::std::string::String::new(),
            module: ::std::string::String::new(),
            name: ::std::string::String::new(),
            generic_type_params: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MoveStructTag {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MoveStructTag").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MoveStructTag {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoveStructTag {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:Signature)
pub struct Signature {
    // message fields
    // @@protoc_insertion_point(field:Signature.type)
    pub type_: ::protobuf::EnumOrUnknown<signature::Type>,
    // message oneof groups
    pub signature: ::std::option::Option<signature::Signature>,
    // special fields
    // @@protoc_insertion_point(special_field:Signature.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Signature {
    fn default() -> &'a Signature {
        <Signature as ::protobuf::Message>::default_instance()
    }
}

impl Signature {
    pub fn new() -> Signature {
        ::std::default::Default::default()
    }

    // .Ed25519Signature ed255198 = 2;

    pub fn ed255198(&self) -> &Ed25519Signature {
        match self.signature {
            ::std::option::Option::Some(signature::Signature::Ed255198(ref v)) => v,
            _ => <Ed25519Signature as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_ed255198(&mut self) {
        self.signature = ::std::option::Option::None;
    }

    pub fn has_ed255198(&self) -> bool {
        match self.signature {
            ::std::option::Option::Some(signature::Signature::Ed255198(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ed255198(&mut self, v: Ed25519Signature) {
        self.signature = ::std::option::Option::Some(signature::Signature::Ed255198(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ed255198(&mut self) -> &mut Ed25519Signature {
        if let ::std::option::Option::Some(signature::Signature::Ed255198(_)) = self.signature {
        } else {
            self.signature = ::std::option::Option::Some(signature::Signature::Ed255198(Ed25519Signature::new()));
        }
        match self.signature {
            ::std::option::Option::Some(signature::Signature::Ed255198(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ed255198(&mut self) -> Ed25519Signature {
        if self.has_ed255198() {
            match self.signature.take() {
                ::std::option::Option::Some(signature::Signature::Ed255198(v)) => v,
                _ => panic!(),
            }
        } else {
            Ed25519Signature::new()
        }
    }

    // .MultiEd25519Signature multi_ed255198 = 3;

    pub fn multi_ed255198(&self) -> &MultiEd25519Signature {
        match self.signature {
            ::std::option::Option::Some(signature::Signature::MultiEd255198(ref v)) => v,
            _ => <MultiEd25519Signature as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_multi_ed255198(&mut self) {
        self.signature = ::std::option::Option::None;
    }

    pub fn has_multi_ed255198(&self) -> bool {
        match self.signature {
            ::std::option::Option::Some(signature::Signature::MultiEd255198(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_multi_ed255198(&mut self, v: MultiEd25519Signature) {
        self.signature = ::std::option::Option::Some(signature::Signature::MultiEd255198(v))
    }

    // Mutable pointer to the field.
    pub fn mut_multi_ed255198(&mut self) -> &mut MultiEd25519Signature {
        if let ::std::option::Option::Some(signature::Signature::MultiEd255198(_)) = self.signature {
        } else {
            self.signature = ::std::option::Option::Some(signature::Signature::MultiEd255198(MultiEd25519Signature::new()));
        }
        match self.signature {
            ::std::option::Option::Some(signature::Signature::MultiEd255198(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_multi_ed255198(&mut self) -> MultiEd25519Signature {
        if self.has_multi_ed255198() {
            match self.signature.take() {
                ::std::option::Option::Some(signature::Signature::MultiEd255198(v)) => v,
                _ => panic!(),
            }
        } else {
            MultiEd25519Signature::new()
        }
    }

    // .MultiAgentSignature multi_agent = 4;

    pub fn multi_agent(&self) -> &MultiAgentSignature {
        match self.signature {
            ::std::option::Option::Some(signature::Signature::MultiAgent(ref v)) => v,
            _ => <MultiAgentSignature as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_multi_agent(&mut self) {
        self.signature = ::std::option::Option::None;
    }

    pub fn has_multi_agent(&self) -> bool {
        match self.signature {
            ::std::option::Option::Some(signature::Signature::MultiAgent(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_multi_agent(&mut self, v: MultiAgentSignature) {
        self.signature = ::std::option::Option::Some(signature::Signature::MultiAgent(v))
    }

    // Mutable pointer to the field.
    pub fn mut_multi_agent(&mut self) -> &mut MultiAgentSignature {
        if let ::std::option::Option::Some(signature::Signature::MultiAgent(_)) = self.signature {
        } else {
            self.signature = ::std::option::Option::Some(signature::Signature::MultiAgent(MultiAgentSignature::new()));
        }
        match self.signature {
            ::std::option::Option::Some(signature::Signature::MultiAgent(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_multi_agent(&mut self) -> MultiAgentSignature {
        if self.has_multi_agent() {
            match self.signature.take() {
                ::std::option::Option::Some(signature::Signature::MultiAgent(v)) => v,
                _ => panic!(),
            }
        } else {
            MultiAgentSignature::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &Signature| { &m.type_ },
            |m: &mut Signature| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Ed25519Signature>(
            "ed255198",
            Signature::has_ed255198,
            Signature::ed255198,
            Signature::mut_ed255198,
            Signature::set_ed255198,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, MultiEd25519Signature>(
            "multi_ed255198",
            Signature::has_multi_ed255198,
            Signature::multi_ed255198,
            Signature::mut_multi_ed255198,
            Signature::set_multi_ed255198,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, MultiAgentSignature>(
            "multi_agent",
            Signature::has_multi_agent,
            Signature::multi_agent,
            Signature::mut_multi_agent,
            Signature::set_multi_agent,
        ));
        oneofs.push(signature::Signature::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Signature>(
            "Signature",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Signature {
    const NAME: &'static str = "Signature";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.signature = ::std::option::Option::Some(signature::Signature::Ed255198(is.read_message()?));
                },
                26 => {
                    self.signature = ::std::option::Option::Some(signature::Signature::MultiEd255198(is.read_message()?));
                },
                34 => {
                    self.signature = ::std::option::Option::Some(signature::Signature::MultiAgent(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.type_ != ::protobuf::EnumOrUnknown::new(signature::Type::ED255198) {
            my_size += ::protobuf::rt::int32_size(1, self.type_.value());
        }
        if let ::std::option::Option::Some(ref v) = self.signature {
            match v {
                &signature::Signature::Ed255198(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &signature::Signature::MultiEd255198(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &signature::Signature::MultiAgent(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.type_ != ::protobuf::EnumOrUnknown::new(signature::Type::ED255198) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if let ::std::option::Option::Some(ref v) = self.signature {
            match v {
                &signature::Signature::Ed255198(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &signature::Signature::MultiEd255198(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &signature::Signature::MultiAgent(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Signature {
        Signature::new()
    }

    fn clear(&mut self) {
        self.type_ = ::protobuf::EnumOrUnknown::new(signature::Type::ED255198);
        self.signature = ::std::option::Option::None;
        self.signature = ::std::option::Option::None;
        self.signature = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Signature {
        static instance: Signature = Signature {
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            signature: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Signature {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Signature").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Signature {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Signature {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Signature`
pub mod signature {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:Signature.signature)
    pub enum Signature {
        // @@protoc_insertion_point(oneof_field:Signature.ed255198)
        Ed255198(super::Ed25519Signature),
        // @@protoc_insertion_point(oneof_field:Signature.multi_ed255198)
        MultiEd255198(super::MultiEd25519Signature),
        // @@protoc_insertion_point(oneof_field:Signature.multi_agent)
        MultiAgent(super::MultiAgentSignature),
    }

    impl ::protobuf::Oneof for Signature {
    }

    impl ::protobuf::OneofFull for Signature {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::Signature as ::protobuf::MessageFull>::descriptor().oneof_by_name("signature").unwrap()).clone()
        }
    }

    impl Signature {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Signature>("signature")
        }
    }
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:Signature.Type)
    pub enum Type {
        // @@protoc_insertion_point(enum_value:Signature.Type.ED255198)
        ED255198 = 0,
        // @@protoc_insertion_point(enum_value:Signature.Type.MULTI_ED255198)
        MULTI_ED255198 = 1,
        // @@protoc_insertion_point(enum_value:Signature.Type.MULTI_AGENT)
        MULTI_AGENT = 2,
    }

    impl ::protobuf::Enum for Type {
        const NAME: &'static str = "Type";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Type> {
            match value {
                0 => ::std::option::Option::Some(Type::ED255198),
                1 => ::std::option::Option::Some(Type::MULTI_ED255198),
                2 => ::std::option::Option::Some(Type::MULTI_AGENT),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Type] = &[
            Type::ED255198,
            Type::MULTI_ED255198,
            Type::MULTI_AGENT,
        ];
    }

    impl ::protobuf::EnumFull for Type {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Signature.Type").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Type {
        fn default() -> Self {
            Type::ED255198
        }
    }

    impl Type {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Type>("Signature.Type")
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:Ed25519Signature)
pub struct Ed25519Signature {
    // message fields
    // @@protoc_insertion_point(field:Ed25519Signature.public_key)
    pub public_key: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:Ed25519Signature.signature)
    pub signature: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:Ed25519Signature.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Ed25519Signature {
    fn default() -> &'a Ed25519Signature {
        <Ed25519Signature as ::protobuf::Message>::default_instance()
    }
}

impl Ed25519Signature {
    pub fn new() -> Ed25519Signature {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "public_key",
            |m: &Ed25519Signature| { &m.public_key },
            |m: &mut Ed25519Signature| { &mut m.public_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "signature",
            |m: &Ed25519Signature| { &m.signature },
            |m: &mut Ed25519Signature| { &mut m.signature },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Ed25519Signature>(
            "Ed25519Signature",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Ed25519Signature {
    const NAME: &'static str = "Ed25519Signature";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.public_key = is.read_bytes()?;
                },
                18 => {
                    self.signature = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.public_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.public_key);
        }
        if !self.signature.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.signature);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.public_key.is_empty() {
            os.write_bytes(1, &self.public_key)?;
        }
        if !self.signature.is_empty() {
            os.write_bytes(2, &self.signature)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Ed25519Signature {
        Ed25519Signature::new()
    }

    fn clear(&mut self) {
        self.public_key.clear();
        self.signature.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Ed25519Signature {
        static instance: Ed25519Signature = Ed25519Signature {
            public_key: ::std::vec::Vec::new(),
            signature: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Ed25519Signature {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Ed25519Signature").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Ed25519Signature {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Ed25519Signature {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:MultiEd25519Signature)
pub struct MultiEd25519Signature {
    // message fields
    // @@protoc_insertion_point(field:MultiEd25519Signature.public_keys)
    pub public_keys: ::std::vec::Vec<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:MultiEd25519Signature.signatures)
    pub signatures: ::std::vec::Vec<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:MultiEd25519Signature.threshold)
    pub threshold: u32,
    // @@protoc_insertion_point(field:MultiEd25519Signature.bitmap)
    pub bitmap: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:MultiEd25519Signature.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiEd25519Signature {
    fn default() -> &'a MultiEd25519Signature {
        <MultiEd25519Signature as ::protobuf::Message>::default_instance()
    }
}

impl MultiEd25519Signature {
    pub fn new() -> MultiEd25519Signature {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "public_keys",
            |m: &MultiEd25519Signature| { &m.public_keys },
            |m: &mut MultiEd25519Signature| { &mut m.public_keys },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "signatures",
            |m: &MultiEd25519Signature| { &m.signatures },
            |m: &mut MultiEd25519Signature| { &mut m.signatures },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "threshold",
            |m: &MultiEd25519Signature| { &m.threshold },
            |m: &mut MultiEd25519Signature| { &mut m.threshold },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "bitmap",
            |m: &MultiEd25519Signature| { &m.bitmap },
            |m: &mut MultiEd25519Signature| { &mut m.bitmap },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiEd25519Signature>(
            "MultiEd25519Signature",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiEd25519Signature {
    const NAME: &'static str = "MultiEd25519Signature";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.public_keys.push(is.read_bytes()?);
                },
                18 => {
                    self.signatures.push(is.read_bytes()?);
                },
                24 => {
                    self.threshold = is.read_uint32()?;
                },
                34 => {
                    self.bitmap = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.public_keys {
            my_size += ::protobuf::rt::bytes_size(1, &value);
        };
        for value in &self.signatures {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        };
        if self.threshold != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.threshold);
        }
        if !self.bitmap.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.bitmap);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.public_keys {
            os.write_bytes(1, &v)?;
        };
        for v in &self.signatures {
            os.write_bytes(2, &v)?;
        };
        if self.threshold != 0 {
            os.write_uint32(3, self.threshold)?;
        }
        if !self.bitmap.is_empty() {
            os.write_bytes(4, &self.bitmap)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiEd25519Signature {
        MultiEd25519Signature::new()
    }

    fn clear(&mut self) {
        self.public_keys.clear();
        self.signatures.clear();
        self.threshold = 0;
        self.bitmap.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiEd25519Signature {
        static instance: MultiEd25519Signature = MultiEd25519Signature {
            public_keys: ::std::vec::Vec::new(),
            signatures: ::std::vec::Vec::new(),
            threshold: 0,
            bitmap: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiEd25519Signature {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiEd25519Signature").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiEd25519Signature {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiEd25519Signature {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:MultiAgentSignature)
pub struct MultiAgentSignature {
    // message fields
    // @@protoc_insertion_point(field:MultiAgentSignature.sender)
    pub sender: ::protobuf::MessageField<AccountSignature>,
    // @@protoc_insertion_point(field:MultiAgentSignature.secondary_signer_addresses)
    pub secondary_signer_addresses: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:MultiAgentSignature.secondary_signers)
    pub secondary_signers: ::std::vec::Vec<AccountSignature>,
    // special fields
    // @@protoc_insertion_point(special_field:MultiAgentSignature.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MultiAgentSignature {
    fn default() -> &'a MultiAgentSignature {
        <MultiAgentSignature as ::protobuf::Message>::default_instance()
    }
}

impl MultiAgentSignature {
    pub fn new() -> MultiAgentSignature {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AccountSignature>(
            "sender",
            |m: &MultiAgentSignature| { &m.sender },
            |m: &mut MultiAgentSignature| { &mut m.sender },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "secondary_signer_addresses",
            |m: &MultiAgentSignature| { &m.secondary_signer_addresses },
            |m: &mut MultiAgentSignature| { &mut m.secondary_signer_addresses },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "secondary_signers",
            |m: &MultiAgentSignature| { &m.secondary_signers },
            |m: &mut MultiAgentSignature| { &mut m.secondary_signers },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MultiAgentSignature>(
            "MultiAgentSignature",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MultiAgentSignature {
    const NAME: &'static str = "MultiAgentSignature";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.sender)?;
                },
                18 => {
                    self.secondary_signer_addresses.push(is.read_string()?);
                },
                26 => {
                    self.secondary_signers.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.sender.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.secondary_signer_addresses {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.secondary_signers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.sender.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.secondary_signer_addresses {
            os.write_string(2, &v)?;
        };
        for v in &self.secondary_signers {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MultiAgentSignature {
        MultiAgentSignature::new()
    }

    fn clear(&mut self) {
        self.sender.clear();
        self.secondary_signer_addresses.clear();
        self.secondary_signers.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MultiAgentSignature {
        static instance: MultiAgentSignature = MultiAgentSignature {
            sender: ::protobuf::MessageField::none(),
            secondary_signer_addresses: ::std::vec::Vec::new(),
            secondary_signers: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MultiAgentSignature {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MultiAgentSignature").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MultiAgentSignature {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MultiAgentSignature {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:AccountSignature)
pub struct AccountSignature {
    // message fields
    // @@protoc_insertion_point(field:AccountSignature.type)
    pub type_: ::protobuf::EnumOrUnknown<account_signature::Type>,
    // message oneof groups
    pub signature: ::std::option::Option<account_signature::Signature>,
    // special fields
    // @@protoc_insertion_point(special_field:AccountSignature.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AccountSignature {
    fn default() -> &'a AccountSignature {
        <AccountSignature as ::protobuf::Message>::default_instance()
    }
}

impl AccountSignature {
    pub fn new() -> AccountSignature {
        ::std::default::Default::default()
    }

    // .Ed25519Signature ed255198 = 2;

    pub fn ed255198(&self) -> &Ed25519Signature {
        match self.signature {
            ::std::option::Option::Some(account_signature::Signature::Ed255198(ref v)) => v,
            _ => <Ed25519Signature as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_ed255198(&mut self) {
        self.signature = ::std::option::Option::None;
    }

    pub fn has_ed255198(&self) -> bool {
        match self.signature {
            ::std::option::Option::Some(account_signature::Signature::Ed255198(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ed255198(&mut self, v: Ed25519Signature) {
        self.signature = ::std::option::Option::Some(account_signature::Signature::Ed255198(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ed255198(&mut self) -> &mut Ed25519Signature {
        if let ::std::option::Option::Some(account_signature::Signature::Ed255198(_)) = self.signature {
        } else {
            self.signature = ::std::option::Option::Some(account_signature::Signature::Ed255198(Ed25519Signature::new()));
        }
        match self.signature {
            ::std::option::Option::Some(account_signature::Signature::Ed255198(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ed255198(&mut self) -> Ed25519Signature {
        if self.has_ed255198() {
            match self.signature.take() {
                ::std::option::Option::Some(account_signature::Signature::Ed255198(v)) => v,
                _ => panic!(),
            }
        } else {
            Ed25519Signature::new()
        }
    }

    // .MultiEd25519Signature multi_ed255198 = 3;

    pub fn multi_ed255198(&self) -> &MultiEd25519Signature {
        match self.signature {
            ::std::option::Option::Some(account_signature::Signature::MultiEd255198(ref v)) => v,
            _ => <MultiEd25519Signature as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_multi_ed255198(&mut self) {
        self.signature = ::std::option::Option::None;
    }

    pub fn has_multi_ed255198(&self) -> bool {
        match self.signature {
            ::std::option::Option::Some(account_signature::Signature::MultiEd255198(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_multi_ed255198(&mut self, v: MultiEd25519Signature) {
        self.signature = ::std::option::Option::Some(account_signature::Signature::MultiEd255198(v))
    }

    // Mutable pointer to the field.
    pub fn mut_multi_ed255198(&mut self) -> &mut MultiEd25519Signature {
        if let ::std::option::Option::Some(account_signature::Signature::MultiEd255198(_)) = self.signature {
        } else {
            self.signature = ::std::option::Option::Some(account_signature::Signature::MultiEd255198(MultiEd25519Signature::new()));
        }
        match self.signature {
            ::std::option::Option::Some(account_signature::Signature::MultiEd255198(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_multi_ed255198(&mut self) -> MultiEd25519Signature {
        if self.has_multi_ed255198() {
            match self.signature.take() {
                ::std::option::Option::Some(account_signature::Signature::MultiEd255198(v)) => v,
                _ => panic!(),
            }
        } else {
            MultiEd25519Signature::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &AccountSignature| { &m.type_ },
            |m: &mut AccountSignature| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, Ed25519Signature>(
            "ed255198",
            AccountSignature::has_ed255198,
            AccountSignature::ed255198,
            AccountSignature::mut_ed255198,
            AccountSignature::set_ed255198,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, MultiEd25519Signature>(
            "multi_ed255198",
            AccountSignature::has_multi_ed255198,
            AccountSignature::multi_ed255198,
            AccountSignature::mut_multi_ed255198,
            AccountSignature::set_multi_ed255198,
        ));
        oneofs.push(account_signature::Signature::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AccountSignature>(
            "AccountSignature",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AccountSignature {
    const NAME: &'static str = "AccountSignature";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.signature = ::std::option::Option::Some(account_signature::Signature::Ed255198(is.read_message()?));
                },
                26 => {
                    self.signature = ::std::option::Option::Some(account_signature::Signature::MultiEd255198(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.type_ != ::protobuf::EnumOrUnknown::new(account_signature::Type::ED255198) {
            my_size += ::protobuf::rt::int32_size(1, self.type_.value());
        }
        if let ::std::option::Option::Some(ref v) = self.signature {
            match v {
                &account_signature::Signature::Ed255198(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &account_signature::Signature::MultiEd255198(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.type_ != ::protobuf::EnumOrUnknown::new(account_signature::Type::ED255198) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if let ::std::option::Option::Some(ref v) = self.signature {
            match v {
                &account_signature::Signature::Ed255198(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &account_signature::Signature::MultiEd255198(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AccountSignature {
        AccountSignature::new()
    }

    fn clear(&mut self) {
        self.type_ = ::protobuf::EnumOrUnknown::new(account_signature::Type::ED255198);
        self.signature = ::std::option::Option::None;
        self.signature = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AccountSignature {
        static instance: AccountSignature = AccountSignature {
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            signature: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AccountSignature {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AccountSignature").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AccountSignature {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AccountSignature {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `AccountSignature`
pub mod account_signature {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:AccountSignature.signature)
    pub enum Signature {
        // @@protoc_insertion_point(oneof_field:AccountSignature.ed255198)
        Ed255198(super::Ed25519Signature),
        // @@protoc_insertion_point(oneof_field:AccountSignature.multi_ed255198)
        MultiEd255198(super::MultiEd25519Signature),
    }

    impl ::protobuf::Oneof for Signature {
    }

    impl ::protobuf::OneofFull for Signature {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::AccountSignature as ::protobuf::MessageFull>::descriptor().oneof_by_name("signature").unwrap()).clone()
        }
    }

    impl Signature {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Signature>("signature")
        }
    }
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:AccountSignature.Type)
    pub enum Type {
        // @@protoc_insertion_point(enum_value:AccountSignature.Type.ED255198)
        ED255198 = 0,
        // @@protoc_insertion_point(enum_value:AccountSignature.Type.MULTI_ED255198)
        MULTI_ED255198 = 1,
    }

    impl ::protobuf::Enum for Type {
        const NAME: &'static str = "Type";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Type> {
            match value {
                0 => ::std::option::Option::Some(Type::ED255198),
                1 => ::std::option::Option::Some(Type::MULTI_ED255198),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Type] = &[
            Type::ED255198,
            Type::MULTI_ED255198,
        ];
    }

    impl ::protobuf::EnumFull for Type {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("AccountSignature.Type").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Type {
        fn default() -> Self {
            Type::ED255198
        }
    }

    impl Type {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Type>("AccountSignature.Type")
        }
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:MoveTypes)
pub enum MoveTypes {
    // @@protoc_insertion_point(enum_value:MoveTypes.Bool)
    Bool = 0,
    // @@protoc_insertion_point(enum_value:MoveTypes.U8)
    U8 = 1,
    // @@protoc_insertion_point(enum_value:MoveTypes.U64)
    U64 = 2,
    // @@protoc_insertion_point(enum_value:MoveTypes.U128)
    U128 = 3,
    // @@protoc_insertion_point(enum_value:MoveTypes.Address)
    Address = 4,
    // @@protoc_insertion_point(enum_value:MoveTypes.Signer)
    Signer = 5,
    // @@protoc_insertion_point(enum_value:MoveTypes.Vector)
    Vector = 6,
    // @@protoc_insertion_point(enum_value:MoveTypes.Struct)
    Struct = 7,
    // @@protoc_insertion_point(enum_value:MoveTypes.GenericTypeParam)
    GenericTypeParam = 8,
    // @@protoc_insertion_point(enum_value:MoveTypes.Reference)
    Reference = 9,
    // @@protoc_insertion_point(enum_value:MoveTypes.Unparsable)
    Unparsable = 10,
}

impl ::protobuf::Enum for MoveTypes {
    const NAME: &'static str = "MoveTypes";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MoveTypes> {
        match value {
            0 => ::std::option::Option::Some(MoveTypes::Bool),
            1 => ::std::option::Option::Some(MoveTypes::U8),
            2 => ::std::option::Option::Some(MoveTypes::U64),
            3 => ::std::option::Option::Some(MoveTypes::U128),
            4 => ::std::option::Option::Some(MoveTypes::Address),
            5 => ::std::option::Option::Some(MoveTypes::Signer),
            6 => ::std::option::Option::Some(MoveTypes::Vector),
            7 => ::std::option::Option::Some(MoveTypes::Struct),
            8 => ::std::option::Option::Some(MoveTypes::GenericTypeParam),
            9 => ::std::option::Option::Some(MoveTypes::Reference),
            10 => ::std::option::Option::Some(MoveTypes::Unparsable),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [MoveTypes] = &[
        MoveTypes::Bool,
        MoveTypes::U8,
        MoveTypes::U64,
        MoveTypes::U128,
        MoveTypes::Address,
        MoveTypes::Signer,
        MoveTypes::Vector,
        MoveTypes::Struct,
        MoveTypes::GenericTypeParam,
        MoveTypes::Reference,
        MoveTypes::Unparsable,
    ];
}

impl ::protobuf::EnumFull for MoveTypes {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("MoveTypes").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for MoveTypes {
    fn default() -> Self {
        MoveTypes::Bool
    }
}

impl MoveTypes {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<MoveTypes>("MoveTypes")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:MoveAbility)
pub enum MoveAbility {
    // @@protoc_insertion_point(enum_value:MoveAbility.COPY)
    COPY = 0,
    // @@protoc_insertion_point(enum_value:MoveAbility.DROP)
    DROP = 1,
    // @@protoc_insertion_point(enum_value:MoveAbility.STORE)
    STORE = 2,
    // @@protoc_insertion_point(enum_value:MoveAbility.KEY)
    KEY = 3,
}

impl ::protobuf::Enum for MoveAbility {
    const NAME: &'static str = "MoveAbility";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MoveAbility> {
        match value {
            0 => ::std::option::Option::Some(MoveAbility::COPY),
            1 => ::std::option::Option::Some(MoveAbility::DROP),
            2 => ::std::option::Option::Some(MoveAbility::STORE),
            3 => ::std::option::Option::Some(MoveAbility::KEY),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [MoveAbility] = &[
        MoveAbility::COPY,
        MoveAbility::DROP,
        MoveAbility::STORE,
        MoveAbility::KEY,
    ];
}

impl ::protobuf::EnumFull for MoveAbility {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("MoveAbility").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for MoveAbility {
    fn default() -> Self {
        MoveAbility::COPY
    }
}

impl MoveAbility {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<MoveAbility>("MoveAbility")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1asrc/protos/extractor.proto\x1a\x1fgoogle/protobuf/timestamp.proto\
    \"\xb9\x04\n\x0bTransaction\x128\n\ttimestamp\x18\x01\x20\x01(\x0b2\x1a.\
    google.protobuf.TimestampR\ttimestamp\x12\x18\n\x07version\x18\x02\x20\
    \x01(\x04R\x07version\x12$\n\x04info\x18\x03\x20\x01(\x0b2\x10.Transacti\
    onInfoR\x04info\x12\x14\n\x05epoch\x18\x04\x20\x01(\x04R\x05epoch\x12!\n\
    \x0cblock_height\x18\x05\x20\x01(\x04R\x0bblockHeight\x120\n\x04type\x18\
    \x06\x20\x01(\x0e2\x1c.Transaction.TransactionTypeR\x04type\x12B\n\x0ebl\
    ock_metadata\x18\x07\x20\x01(\x0b2\x19.BlockMetadataTransactionH\0R\rblo\
    ckMetadata\x12/\n\x07genesis\x18\x08\x20\x01(\x0b2\x13.GenesisTransactio\
    nH\0R\x07genesis\x12H\n\x10state_checkpoint\x18\t\x20\x01(\x0b2\x1b.Stat\
    eCheckpointTransactionH\0R\x0fstateCheckpoint\x12&\n\x04user\x18\n\x20\
    \x01(\x0b2\x10.UserTransactionH\0R\x04user\"R\n\x0fTransactionType\x12\
    \x0b\n\x07GENESIS\x10\0\x12\x12\n\x0eBLOCK_METADATA\x10\x01\x12\x14\n\
    \x10STATE_CHECKPOINT\x10\x02\x12\x08\n\x04USER\x10\x03B\n\n\x08txn_data\
    \"h\n\x12TransactionTrimmed\x128\n\ttimestamp\x18\x01\x20\x01(\x0b2\x1a.\
    google.protobuf.TimestampR\ttimestamp\x12\x18\n\x07version\x18\x02\x20\
    \x01(\x04R\x07version\"\xe6\x01\n\x18BlockMetadataTransaction\x12\x0e\n\
    \x02id\x18\x01\x20\x01(\tR\x02id\x12\x14\n\x05round\x18\x02\x20\x01(\x04\
    R\x05round\x12\x1e\n\x06events\x18\x03\x20\x03(\x0b2\x06.EventR\x06event\
    s\x120\n\x14previous_block_votes\x18\x04\x20\x03(\x08R\x12previousBlockV\
    otes\x12\x1a\n\x08proposer\x18\x05\x20\x01(\tR\x08proposer\x126\n\x17fai\
    led_proposer_indices\x18\x06\x20\x03(\rR\x15failedProposerIndices\"Y\n\
    \x12GenesisTransaction\x12#\n\x07payload\x18\x01\x20\x01(\x0b2\t.WriteSe\
    tR\x07payload\x12\x1e\n\x06events\x18\x02\x20\x03(\x0b2\x06.EventR\x06ev\
    ents\"\x1c\n\x1aStateCheckpointTransaction\"d\n\x0fUserTransaction\x121\
    \n\x07request\x18\x01\x20\x01(\x0b2\x17.UserTransactionRequestR\x07reque\
    st\x12\x1e\n\x06events\x18\x02\x20\x03(\x0b2\x06.EventR\x06events\"\x80\
    \x01\n\x05Event\x12\x1b\n\x03key\x18\x01\x20\x01(\x0b2\t.EventKeyR\x03ke\
    y\x12'\n\x0fsequence_number\x18\x02\x20\x01(\x04R\x0esequenceNumber\x12\
    \x1d\n\x04type\x18\x03\x20\x01(\x0b2\t.MoveTypeR\x04type\x12\x12\n\x04da\
    ta\x18\x04\x20\x01(\tR\x04data\"\xa6\x02\n\x0fTransactionInfo\x12\x12\n\
    \x04hash\x18\x01\x20\x01(\x0cR\x04hash\x12&\n\x0fstate_root_hash\x18\x02\
    \x20\x01(\x0cR\rstateRootHash\x12&\n\x0fevent_root_hash\x18\x03\x20\x01(\
    \x0cR\reventRootHash\x12\x19\n\x08gas_used\x18\x04\x20\x01(\x04R\x07gasU\
    sed\x12\x18\n\x07success\x18\x05\x20\x01(\x08R\x07success\x12\x1b\n\tvm_\
    status\x18\x06\x20\x01(\tR\x08vmStatus\x122\n\x15accumulator_root_hash\
    \x18\x07\x20\x01(\x0cR\x13accumulatorRootHash\x12)\n\x07changes\x18\x08\
    \x20\x03(\x0b2\x0f.WriteSetChangeR\x07changes\"\\\n\x08EventKey\x12'\n\
    \x0fcreation_number\x18\x01\x20\x01(\x04R\x0ecreationNumber\x12'\n\x0fac\
    count_address\x18\x02\x20\x01(\tR\x0eaccountAddress\"\xd6\x02\n\x16UserT\
    ransactionRequest\x12\x16\n\x06sender\x18\x01\x20\x01(\tR\x06sender\x12'\
    \n\x0fsequence_number\x18\x02\x20\x01(\x04R\x0esequenceNumber\x12$\n\x0e\
    max_gas_amount\x18\x03\x20\x01(\x04R\x0cmaxGasAmount\x12$\n\x0egas_unit_\
    price\x18\x04\x20\x01(\x04R\x0cgasUnitPrice\x12V\n\x19expiration_timesta\
    mp_secs\x18\x05\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\x17expirati\
    onTimestampSecs\x12-\n\x07payload\x18\x06\x20\x01(\x0b2\x13.TransactionP\
    ayloadR\x07payload\x12(\n\tsignature\x18\x07\x20\x01(\x0b2\n.SignatureR\
    \tsignature\"\x8b\x02\n\x08WriteSet\x12<\n\x0ewrite_set_type\x18\x01\x20\
    \x01(\x0e2\x16.WriteSet.WriteSetTypeR\x0cwriteSetType\x12;\n\x10script_w\
    rite_set\x18\x02\x20\x01(\x0b2\x0f.ScriptWriteSetH\0R\x0escriptWriteSet\
    \x12;\n\x10direct_write_set\x18\x03\x20\x01(\x0b2\x0f.DirectWriteSetH\0R\
    \x0edirectWriteSet\":\n\x0cWriteSetType\x12\x14\n\x10SCRIPT_WRITE_SET\
    \x10\0\x12\x14\n\x10DIRECT_WRITE_SET\x10\x01B\x0b\n\twrite_set\"W\n\x0eS\
    criptWriteSet\x12\x1d\n\nexecute_as\x18\x01\x20\x01(\tR\texecuteAs\x12&\
    \n\x06script\x18\x02\x20\x01(\x0b2\x0e.ScriptPayloadR\x06script\"k\n\x0e\
    DirectWriteSet\x129\n\x10write_set_change\x18\x01\x20\x03(\x0b2\x0f.Writ\
    eSetChangeR\x0ewriteSetChange\x12\x1e\n\x06events\x18\x02\x20\x03(\x0b2\
    \x06.EventR\x06events\"\xa3\x04\n\x0eWriteSetChange\x12(\n\x04type\x18\
    \x01\x20\x01(\x0e2\x14.WriteSetChange.TypeR\x04type\x124\n\rdelete_modul\
    e\x18\x02\x20\x01(\x0b2\r.DeleteModuleH\0R\x0cdeleteModule\x12:\n\x0fdel\
    ete_resource\x18\x03\x20\x01(\x0b2\x0f.DeleteResourceH\0R\x0edeleteResou\
    rce\x12>\n\x11delete_table_item\x18\x04\x20\x01(\x0b2\x10.DeleteTableIte\
    mH\0R\x0fdeleteTableItem\x121\n\x0cwrite_module\x18\x05\x20\x01(\x0b2\
    \x0c.WriteModuleH\0R\x0bwriteModule\x127\n\x0ewrite_resource\x18\x06\x20\
    \x01(\x0b2\x0e.WriteResourceH\0R\rwriteResource\x12;\n\x10write_table_it\
    em\x18\x07\x20\x01(\x0b2\x0f.WriteTableItemH\0R\x0ewriteTableItem\"\x81\
    \x01\n\x04Type\x12\x11\n\rDELETE_MODULE\x10\0\x12\x13\n\x0fDELETE_RESOUR\
    CE\x10\x01\x12\x15\n\x11DELETE_TABLE_ITEM\x10\x02\x12\x10\n\x0cWRITE_MOD\
    ULE\x10\x03\x12\x12\n\x0eWRITE_RESOURCE\x10\x04\x12\x14\n\x10WRITE_TABLE\
    _ITEM\x10\x05B\x08\n\x06change\"u\n\x0cDeleteModule\x12\x18\n\x07address\
    \x18\x01\x20\x01(\tR\x07address\x12$\n\x0estate_key_hash\x18\x02\x20\x01\
    (\x0cR\x0cstateKeyHash\x12%\n\x06module\x18\x03\x20\x01(\x0b2\r.MoveModu\
    leIdR\x06module\"|\n\x0eDeleteResource\x12\x18\n\x07address\x18\x01\x20\
    \x01(\tR\x07address\x12$\n\x0estate_key_hash\x18\x02\x20\x01(\x0cR\x0cst\
    ateKeyHash\x12*\n\x08resource\x18\x03\x20\x01(\x0b2\x0e.MoveStructTagR\
    \x08resource\"\x87\x01\n\x0fDeleteTableItem\x12$\n\x0estate_key_hash\x18\
    \x01\x20\x01(\x0cR\x0cstateKeyHash\x12\x16\n\x06handle\x18\x02\x20\x01(\
    \tR\x06handle\x12\x10\n\x03key\x18\x03\x20\x01(\tR\x03key\x12$\n\x04data\
    \x18\x04\x20\x01(\x0b2\x10.DeleteTableDataR\x04data\">\n\x0fDeleteTableD\
    ata\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x19\n\x08key_type\
    \x18\x02\x20\x01(\tR\x07keyType\"v\n\x0bWriteModule\x12\x18\n\x07address\
    \x18\x01\x20\x01(\tR\x07address\x12$\n\x0estate_key_hash\x18\x02\x20\x01\
    (\x0cR\x0cstateKeyHash\x12'\n\x04data\x18\x03\x20\x01(\x0b2\x13.MoveModu\
    leBytecodeR\x04data\"r\n\rWriteResource\x12\x18\n\x07address\x18\x01\x20\
    \x01(\tR\x07address\x12$\n\x0estate_key_hash\x18\x02\x20\x01(\x0cR\x0cst\
    ateKeyHash\x12!\n\x04data\x18\x03\x20\x01(\x0b2\r.MoveResourceR\x04data\
    \"r\n\x0eWriteTableData\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\
    \x19\n\x08key_type\x18\x02\x20\x01(\tR\x07keyType\x12\x14\n\x05value\x18\
    \x03\x20\x01(\tR\x05value\x12\x1d\n\nvalue_type\x18\x04\x20\x01(\tR\tval\
    ueType\"\x85\x01\n\x0eWriteTableItem\x12$\n\x0estate_key_hash\x18\x01\
    \x20\x01(\x0cR\x0cstateKeyHash\x12\x16\n\x06handle\x18\x02\x20\x01(\tR\
    \x06handle\x12\x10\n\x03key\x18\x03\x20\x01(\tR\x03key\x12#\n\x04data\
    \x18\x04\x20\x01(\x0b2\x0f.WriteTableDataR\x04data\"\xcf\x03\n\x12Transa\
    ctionPayload\x12,\n\x04type\x18\x01\x20\x01(\x0e2\x18.TransactionPayload\
    .TypeR\x04type\x12P\n\x17script_function_payload\x18\x02\x20\x01(\x0b2\
    \x16.ScriptFunctionPayloadH\0R\x15scriptFunctionPayload\x127\n\x0escript\
    _payload\x18\x03\x20\x01(\x0b2\x0e.ScriptPayloadH\0R\rscriptPayload\x12J\
    \n\x15module_bundle_payload\x18\x04\x20\x01(\x0b2\x14.ModuleBundlePayloa\
    dH\0R\x13moduleBundlePayload\x12>\n\x11write_set_payload\x18\x05\x20\x01\
    (\x0b2\x10.WriteSetPayloadH\0R\x0fwriteSetPayload\"i\n\x04Type\x12\x1b\n\
    \x17SCRIPT_FUNCTION_PAYLOAD\x10\0\x12\x12\n\x0eSCRIPT_PAYLOAD\x10\x01\
    \x12\x19\n\x15MODULE_BUNDLE_PAYLOAD\x10\x02\x12\x15\n\x11WRITE_SET_PAYLO\
    AD\x10\x03B\t\n\x07payload\"\x96\x01\n\x15ScriptFunctionPayload\x12-\n\
    \x08function\x18\x01\x20\x01(\x0b2\x11.ScriptFunctionIdR\x08function\x12\
    0\n\x0etype_arguments\x18\x02\x20\x03(\x0b2\t.MoveTypeR\rtypeArguments\
    \x12\x1c\n\targuments\x18\x03\x20\x03(\tR\targuments\"Q\n\x12MoveScriptB\
    ytecode\x12\x1a\n\x08bytecode\x18\x01\x20\x01(\x0cR\x08bytecode\x12\x1f\
    \n\x03abi\x18\x02\x20\x01(\x0b2\r.MoveFunctionR\x03abi\"\x88\x01\n\rScri\
    ptPayload\x12'\n\x04code\x18\x01\x20\x01(\x0b2\x13.MoveScriptBytecodeR\
    \x04code\x120\n\x0etype_arguments\x18\x02\x20\x03(\x0b2\t.MoveTypeR\rtyp\
    eArguments\x12\x1c\n\targuments\x18\x03\x20\x03(\tR\targuments\"D\n\x13M\
    oduleBundlePayload\x12-\n\x07modules\x18\x01\x20\x03(\x0b2\x13.MoveModul\
    eBytecodeR\x07modules\"O\n\x12MoveModuleBytecode\x12\x1a\n\x08bytecode\
    \x18\x01\x20\x01(\x0cR\x08bytecode\x12\x1d\n\x03abi\x18\x02\x20\x01(\x0b\
    2\x0b.MoveModuleR\x03abi\"\xc6\x01\n\nMoveModule\x12\x18\n\x07address\
    \x18\x01\x20\x01(\tR\x07address\x12\x12\n\x04name\x18\x02\x20\x01(\tR\
    \x04name\x12'\n\x07friends\x18\x03\x20\x03(\x0b2\r.MoveModuleIdR\x07frie\
    nds\x12:\n\x11exposed_functions\x18\x04\x20\x03(\x0b2\r.MoveFunctionR\
    \x10exposedFunctions\x12%\n\x07structs\x18\x05\x20\x03(\x0b2\x0b.MoveStr\
    uctR\x07structs\"\xbf\x02\n\x0cMoveFunction\x12\x12\n\x04name\x18\x01\
    \x20\x01(\tR\x04name\x128\n\nvisibility\x18\x02\x20\x01(\x0e2\x18.MoveFu\
    nction.VisibilityR\nvisibility\x12\x19\n\x08is_entry\x18\x03\x20\x01(\
    \x08R\x07isEntry\x12M\n\x13generic_type_params\x18\x04\x20\x03(\x0b2\x1d\
    .MoveFunctionGenericTypeParamR\x11genericTypeParams\x12!\n\x06params\x18\
    \x05\x20\x03(\x0b2\t.MoveTypeR\x06params\x12!\n\x06return\x18\x06\x20\
    \x03(\x0b2\t.MoveTypeR\x06return\"1\n\nVisibility\x12\x0b\n\x07PRIVATE\
    \x10\0\x12\n\n\x06PUBLIC\x10\x01\x12\n\n\x06FRIEND\x10\x02\"\xe0\x01\n\n\
    MoveStruct\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x1b\n\tis_n\
    ative\x18\x02\x20\x01(\x08R\x08isNative\x12*\n\tabilities\x18\x03\x20\
    \x03(\x0e2\x0c.MoveAbilityR\tabilities\x12K\n\x13generic_type_params\x18\
    \x04\x20\x03(\x0b2\x1b.MoveStructGenericTypeParamR\x11genericTypeParams\
    \x12(\n\x06fields\x18\x05\x20\x03(\x0b2\x10.MoveStructFieldR\x06fields\"\
    k\n\x1aMoveStructGenericTypeParam\x12.\n\x0bconstraints\x18\x01\x20\x03(\
    \x0e2\x0c.MoveAbilityR\x0bconstraints\x12\x1d\n\nis_phantom\x18\x02\x20\
    \x01(\x08R\tisPhantom\"D\n\x0fMoveStructField\x12\x12\n\x04name\x18\x01\
    \x20\x01(\tR\x04name\x12\x1d\n\x04type\x18\x02\x20\x01(\x0b2\t.MoveTypeR\
    \x04type\"N\n\x1cMoveFunctionGenericTypeParam\x12.\n\x0bconstraints\x18\
    \x01\x20\x03(\x0e2\x0c.MoveAbilityR\x0bconstraints\"\xe0\x02\n\x08MoveTy\
    pe\x12\x1e\n\x04type\x18\x01\x20\x01(\x0e2\n.MoveTypesR\x04type\x12#\n\
    \x06vector\x18\x03\x20\x01(\x0b2\t.MoveTypeH\0R\x06vector\x12(\n\x06stru\
    ct\x18\x04\x20\x01(\x0b2\x0e.MoveStructTagH\0R\x06struct\x129\n\x18gener\
    ic_type_param_index\x18\x05\x20\x01(\rH\0R\x15genericTypeParamIndex\x127\
    \n\treference\x18\x06\x20\x01(\x0b2\x17.MoveType.ReferenceTypeH\0R\trefe\
    rence\x12\x20\n\nunparsable\x18\x07\x20\x01(\tH\0R\nunparsable\x1aD\n\rR\
    eferenceType\x12\x18\n\x07mutable\x18\x01\x20\x01(\x08R\x07mutable\x12\
    \x19\n\x02to\x18\x02\x20\x01(\x0b2\t.MoveTypeR\x02toB\t\n\x07content\"9\
    \n\x0fWriteSetPayload\x12&\n\twrite_set\x18\x01\x20\x01(\x0b2\t.WriteSet\
    R\x08writeSet\"M\n\x10ScriptFunctionId\x12%\n\x06module\x18\x01\x20\x01(\
    \x0b2\r.MoveModuleIdR\x06module\x12\x12\n\x04name\x18\x02\x20\x01(\tR\
    \x04name\"F\n\x0cMoveResource\x12\"\n\x04type\x18\x01\x20\x01(\x0b2\x0e.\
    MoveStructTagR\x04type\x12\x12\n\x04data\x18\x02\x20\x01(\tR\x04data\"<\
    \n\x0cMoveModuleId\x12\x18\n\x07address\x18\x01\x20\x01(\tR\x07address\
    \x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\"\x90\x01\n\rMoveStructTa\
    g\x12\x18\n\x07address\x18\x01\x20\x01(\tR\x07address\x12\x16\n\x06modul\
    e\x18\x02\x20\x01(\tR\x06module\x12\x12\n\x04name\x18\x03\x20\x01(\tR\
    \x04name\x129\n\x13generic_type_params\x18\x04\x20\x03(\x0b2\t.MoveTypeR\
    \x11genericTypeParams\"\xa3\x02\n\tSignature\x12#\n\x04type\x18\x01\x20\
    \x01(\x0e2\x0f.Signature.TypeR\x04type\x12/\n\x08ed255198\x18\x02\x20\
    \x01(\x0b2\x11.Ed25519SignatureH\0R\x08ed255198\x12?\n\x0emulti_ed255198\
    \x18\x03\x20\x01(\x0b2\x16.MultiEd25519SignatureH\0R\rmultiEd255198\x127\
    \n\x0bmulti_agent\x18\x04\x20\x01(\x0b2\x14.MultiAgentSignatureH\0R\nmul\
    tiAgent\"9\n\x04Type\x12\x0c\n\x08ED255198\x10\0\x12\x12\n\x0eMULTI_ED25\
    5198\x10\x01\x12\x0f\n\x0bMULTI_AGENT\x10\x02B\x0b\n\tsignature\"O\n\x10\
    Ed25519Signature\x12\x1d\n\npublic_key\x18\x01\x20\x01(\x0cR\tpublicKey\
    \x12\x1c\n\tsignature\x18\x02\x20\x01(\x0cR\tsignature\"\x8e\x01\n\x15Mu\
    ltiEd25519Signature\x12\x1f\n\x0bpublic_keys\x18\x01\x20\x03(\x0cR\npubl\
    icKeys\x12\x1e\n\nsignatures\x18\x02\x20\x03(\x0cR\nsignatures\x12\x1c\n\
    \tthreshold\x18\x03\x20\x01(\rR\tthreshold\x12\x16\n\x06bitmap\x18\x04\
    \x20\x01(\x0cR\x06bitmap\"\xbe\x01\n\x13MultiAgentSignature\x12)\n\x06se\
    nder\x18\x01\x20\x01(\x0b2\x11.AccountSignatureR\x06sender\x12<\n\x1asec\
    ondary_signer_addresses\x18\x02\x20\x03(\tR\x18secondarySignerAddresses\
    \x12>\n\x11secondary_signers\x18\x03\x20\x03(\x0b2\x11.AccountSignatureR\
    \x10secondarySigners\"\xe7\x01\n\x10AccountSignature\x12*\n\x04type\x18\
    \x01\x20\x01(\x0e2\x16.AccountSignature.TypeR\x04type\x12/\n\x08ed255198\
    \x18\x02\x20\x01(\x0b2\x11.Ed25519SignatureH\0R\x08ed255198\x12?\n\x0emu\
    lti_ed255198\x18\x03\x20\x01(\x0b2\x16.MultiEd25519SignatureH\0R\rmultiE\
    d255198\"(\n\x04Type\x12\x0c\n\x08ED255198\x10\0\x12\x12\n\x0eMULTI_ED25\
    5198\x10\x01B\x0b\n\tsignature*\x96\x01\n\tMoveTypes\x12\x08\n\x04Bool\
    \x10\0\x12\x06\n\x02U8\x10\x01\x12\x07\n\x03U64\x10\x02\x12\x08\n\x04U12\
    8\x10\x03\x12\x0b\n\x07Address\x10\x04\x12\n\n\x06Signer\x10\x05\x12\n\n\
    \x06Vector\x10\x06\x12\n\n\x06Struct\x10\x07\x12\x14\n\x10GenericTypePar\
    am\x10\x08\x12\r\n\tReference\x10\t\x12\x0e\n\nUnparsable\x10\n*5\n\x0bM\
    oveAbility\x12\x08\n\x04COPY\x10\0\x12\x08\n\x04DROP\x10\x01\x12\t\n\x05\
    STORE\x10\x02\x12\x07\n\x03KEY\x10\x03BKZIgithub.com/streamingfast/fireh\
    ose-aptos/types/pb/sf/aptos/type/v1;pbaptosJ\x8ei\n\x07\x12\x05\x03\0\
    \x86\x03\x01\nD\n\x01\x0c\x12\x03\x03\0\x122:\x20Copyright\x20(c)\x20Apt\
    os\n\x20SPDX-License-Identifier:\x20Apache-2.0\n\n\t\n\x02\x03\0\x12\x03\
    \x05\0)\n\x08\n\x01\x08\x12\x03\x07\0`\n\t\n\x02\x08\x0b\x12\x03\x07\0`\
    \n\x9f\x01\n\x02\x04\0\x12\x04\x0b\0!\x01\x1a\x92\x01\x20Transaction\x20\
    is\x20actually\x20right\x20what\x20will\x20be\x20transported\x20inside\
    \x20the\x20Firehose's\x20Block\x20envelope.\n\x20meaning\x20we\x20get\
    \x20a\x201\x20transaction\x20==\x201\x20block\x20mapping.\n\n\n\n\x03\
    \x04\0\x01\x12\x03\x0b\x08\x13\n\x0b\n\x04\x04\0\x02\0\x12\x03\x0c\x02*\
    \n\x0c\n\x05\x04\0\x02\0\x06\x12\x03\x0c\x02\x1b\n\x0c\n\x05\x04\0\x02\0\
    \x01\x12\x03\x0c\x1c%\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03\x0c()\n\x0b\n\
    \x04\x04\0\x02\x01\x12\x03\r\x02\x15\n\x0c\n\x05\x04\0\x02\x01\x05\x12\
    \x03\r\x02\x08\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03\r\t\x10\n\x0c\n\x05\
    \x04\0\x02\x01\x03\x12\x03\r\x13\x14\n\x0b\n\x04\x04\0\x02\x02\x12\x03\
    \x0e\x02\x1b\n\x0c\n\x05\x04\0\x02\x02\x06\x12\x03\x0e\x02\x11\n\x0c\n\
    \x05\x04\0\x02\x02\x01\x12\x03\x0e\x12\x16\n\x0c\n\x05\x04\0\x02\x02\x03\
    \x12\x03\x0e\x19\x1a\n\x0b\n\x04\x04\0\x02\x03\x12\x03\x0f\x02\x13\n\x0c\
    \n\x05\x04\0\x02\x03\x05\x12\x03\x0f\x02\x08\n\x0c\n\x05\x04\0\x02\x03\
    \x01\x12\x03\x0f\t\x0e\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x03\x0f\x11\x12\
    \n\x0b\n\x04\x04\0\x02\x04\x12\x03\x10\x02\x1a\n\x0c\n\x05\x04\0\x02\x04\
    \x05\x12\x03\x10\x02\x08\n\x0c\n\x05\x04\0\x02\x04\x01\x12\x03\x10\t\x15\
    \n\x0c\n\x05\x04\0\x02\x04\x03\x12\x03\x10\x18\x19\n\x0c\n\x04\x04\0\x04\
    \0\x12\x04\x12\x02\x17\x03\n\x0c\n\x05\x04\0\x04\0\x01\x12\x03\x12\x07\
    \x16\n\r\n\x06\x04\0\x04\0\x02\0\x12\x03\x13\x04\x10\n\x0e\n\x07\x04\0\
    \x04\0\x02\0\x01\x12\x03\x13\x04\x0b\n\x0e\n\x07\x04\0\x04\0\x02\0\x02\
    \x12\x03\x13\x0e\x0f\n\r\n\x06\x04\0\x04\0\x02\x01\x12\x03\x14\x04\x17\n\
    \x0e\n\x07\x04\0\x04\0\x02\x01\x01\x12\x03\x14\x04\x12\n\x0e\n\x07\x04\0\
    \x04\0\x02\x01\x02\x12\x03\x14\x15\x16\n\r\n\x06\x04\0\x04\0\x02\x02\x12\
    \x03\x15\x04\x19\n\x0e\n\x07\x04\0\x04\0\x02\x02\x01\x12\x03\x15\x04\x14\
    \n\x0e\n\x07\x04\0\x04\0\x02\x02\x02\x12\x03\x15\x17\x18\n\r\n\x06\x04\0\
    \x04\0\x02\x03\x12\x03\x16\x04\r\n\x0e\n\x07\x04\0\x04\0\x02\x03\x01\x12\
    \x03\x16\x04\x08\n\x0e\n\x07\x04\0\x04\0\x02\x03\x02\x12\x03\x16\x0b\x0c\
    \n\x0b\n\x04\x04\0\x02\x05\x12\x03\x19\x02\x1b\n\x0c\n\x05\x04\0\x02\x05\
    \x06\x12\x03\x19\x02\x11\n\x0c\n\x05\x04\0\x02\x05\x01\x12\x03\x19\x12\
    \x16\n\x0c\n\x05\x04\0\x02\x05\x03\x12\x03\x19\x19\x1a\n\x0c\n\x04\x04\0\
    \x08\0\x12\x04\x1b\x02\x20\x03\n\x0c\n\x05\x04\0\x08\0\x01\x12\x03\x1b\
    \x08\x10\n\x0b\n\x04\x04\0\x02\x06\x12\x03\x1c\x040\n\x0c\n\x05\x04\0\
    \x02\x06\x06\x12\x03\x1c\x04\x1c\n\x0c\n\x05\x04\0\x02\x06\x01\x12\x03\
    \x1c\x1d+\n\x0c\n\x05\x04\0\x02\x06\x03\x12\x03\x1c./\n\x0b\n\x04\x04\0\
    \x02\x07\x12\x03\x1d\x04#\n\x0c\n\x05\x04\0\x02\x07\x06\x12\x03\x1d\x04\
    \x16\n\x0c\n\x05\x04\0\x02\x07\x01\x12\x03\x1d\x17\x1e\n\x0c\n\x05\x04\0\
    \x02\x07\x03\x12\x03\x1d!\"\n\x0b\n\x04\x04\0\x02\x08\x12\x03\x1e\x044\n\
    \x0c\n\x05\x04\0\x02\x08\x06\x12\x03\x1e\x04\x1e\n\x0c\n\x05\x04\0\x02\
    \x08\x01\x12\x03\x1e\x1f/\n\x0c\n\x05\x04\0\x02\x08\x03\x12\x03\x1e23\n\
    \x0b\n\x04\x04\0\x02\t\x12\x03\x1f\x04\x1e\n\x0c\n\x05\x04\0\x02\t\x06\
    \x12\x03\x1f\x04\x13\n\x0c\n\x05\x04\0\x02\t\x01\x12\x03\x1f\x14\x18\n\
    \x0c\n\x05\x04\0\x02\t\x03\x12\x03\x1f\x1b\x1d\n\xb9\x01\n\x02\x04\x01\
    \x12\x04%\0(\x01\x1a\xac\x01\x20TransactionTrimmed\x20is\x20a\x20real\
    \x20Transaction\x20with\x20most\x20of\x20the\x20fields\x20removed\x20so\
    \x20that\n\x20we\x20can\x20easily\x20decode\x20only\x20the\x20few\x20fie\
    lds\x20that\x20we\x20have\x20interest\x20in\x20in\x20certain\x20situatio\
    ns.\n\n\n\n\x03\x04\x01\x01\x12\x03%\x08\x1a\n\x0b\n\x04\x04\x01\x02\0\
    \x12\x03&\x02*\n\x0c\n\x05\x04\x01\x02\0\x06\x12\x03&\x02\x1b\n\x0c\n\
    \x05\x04\x01\x02\0\x01\x12\x03&\x1c%\n\x0c\n\x05\x04\x01\x02\0\x03\x12\
    \x03&()\n\x0b\n\x04\x04\x01\x02\x01\x12\x03'\x02\x15\n\x0c\n\x05\x04\x01\
    \x02\x01\x05\x12\x03'\x02\x08\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x03'\t\
    \x10\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03'\x13\x14\n\n\n\x02\x04\x02\
    \x12\x04*\01\x01\n\n\n\x03\x04\x02\x01\x12\x03*\x08\x20\n\x0b\n\x04\x04\
    \x02\x02\0\x12\x03+\x02\x10\n\x0c\n\x05\x04\x02\x02\0\x05\x12\x03+\x02\
    \x08\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03+\t\x0b\n\x0c\n\x05\x04\x02\
    \x02\0\x03\x12\x03+\x0e\x0f\n\x0b\n\x04\x04\x02\x02\x01\x12\x03,\x02\x13\
    \n\x0c\n\x05\x04\x02\x02\x01\x05\x12\x03,\x02\x08\n\x0c\n\x05\x04\x02\
    \x02\x01\x01\x12\x03,\t\x0e\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03,\x11\
    \x12\n\x0b\n\x04\x04\x02\x02\x02\x12\x03-\x02\x1c\n\x0c\n\x05\x04\x02\
    \x02\x02\x04\x12\x03-\x02\n\n\x0c\n\x05\x04\x02\x02\x02\x06\x12\x03-\x0b\
    \x10\n\x0c\n\x05\x04\x02\x02\x02\x01\x12\x03-\x11\x17\n\x0c\n\x05\x04\
    \x02\x02\x02\x03\x12\x03-\x1a\x1b\n\x0b\n\x04\x04\x02\x02\x03\x12\x03.\
    \x02)\n\x0c\n\x05\x04\x02\x02\x03\x04\x12\x03.\x02\n\n\x0c\n\x05\x04\x02\
    \x02\x03\x05\x12\x03.\x0b\x0f\n\x0c\n\x05\x04\x02\x02\x03\x01\x12\x03.\
    \x10$\n\x0c\n\x05\x04\x02\x02\x03\x03\x12\x03.'(\n\x0b\n\x04\x04\x02\x02\
    \x04\x12\x03/\x02\x16\n\x0c\n\x05\x04\x02\x02\x04\x05\x12\x03/\x02\x08\n\
    \x0c\n\x05\x04\x02\x02\x04\x01\x12\x03/\t\x11\n\x0c\n\x05\x04\x02\x02\
    \x04\x03\x12\x03/\x14\x15\n\x0b\n\x04\x04\x02\x02\x05\x12\x030\x02.\n\
    \x0c\n\x05\x04\x02\x02\x05\x04\x12\x030\x02\n\n\x0c\n\x05\x04\x02\x02\
    \x05\x05\x12\x030\x0b\x11\n\x0c\n\x05\x04\x02\x02\x05\x01\x12\x030\x12)\
    \n\x0c\n\x05\x04\x02\x02\x05\x03\x12\x030,-\n\n\n\x02\x04\x03\x12\x043\0\
    6\x01\n\n\n\x03\x04\x03\x01\x12\x033\x08\x1a\n\x0b\n\x04\x04\x03\x02\0\
    \x12\x034\x02\x17\n\x0c\n\x05\x04\x03\x02\0\x06\x12\x034\x02\n\n\x0c\n\
    \x05\x04\x03\x02\0\x01\x12\x034\x0b\x12\n\x0c\n\x05\x04\x03\x02\0\x03\
    \x12\x034\x15\x16\n\x0b\n\x04\x04\x03\x02\x01\x12\x035\x02\x1c\n\x0c\n\
    \x05\x04\x03\x02\x01\x04\x12\x035\x02\n\n\x0c\n\x05\x04\x03\x02\x01\x06\
    \x12\x035\x0b\x10\n\x0c\n\x05\x04\x03\x02\x01\x01\x12\x035\x11\x17\n\x0c\
    \n\x05\x04\x03\x02\x01\x03\x12\x035\x1a\x1b\n\n\n\x02\x04\x04\x12\x048\0\
    9\x01\n\n\n\x03\x04\x04\x01\x12\x038\x08\"\n\n\n\x02\x04\x05\x12\x04;\0>\
    \x01\n\n\n\x03\x04\x05\x01\x12\x03;\x08\x17\n\x0b\n\x04\x04\x05\x02\0\
    \x12\x03<\x02%\n\x0c\n\x05\x04\x05\x02\0\x06\x12\x03<\x02\x18\n\x0c\n\
    \x05\x04\x05\x02\0\x01\x12\x03<\x19\x20\n\x0c\n\x05\x04\x05\x02\0\x03\
    \x12\x03<#$\n\x0b\n\x04\x04\x05\x02\x01\x12\x03=\x02\x1c\n\x0c\n\x05\x04\
    \x05\x02\x01\x04\x12\x03=\x02\n\n\x0c\n\x05\x04\x05\x02\x01\x06\x12\x03=\
    \x0b\x10\n\x0c\n\x05\x04\x05\x02\x01\x01\x12\x03=\x11\x17\n\x0c\n\x05\
    \x04\x05\x02\x01\x03\x12\x03=\x1a\x1b\n\n\n\x02\x04\x06\x12\x04@\0E\x01\
    \n\n\n\x03\x04\x06\x01\x12\x03@\x08\r\n\x0b\n\x04\x04\x06\x02\0\x12\x03A\
    \x02\x13\n\x0c\n\x05\x04\x06\x02\0\x06\x12\x03A\x02\n\n\x0c\n\x05\x04\
    \x06\x02\0\x01\x12\x03A\x0b\x0e\n\x0c\n\x05\x04\x06\x02\0\x03\x12\x03A\
    \x11\x12\n\x0b\n\x04\x04\x06\x02\x01\x12\x03B\x02\x1d\n\x0c\n\x05\x04\
    \x06\x02\x01\x05\x12\x03B\x02\x08\n\x0c\n\x05\x04\x06\x02\x01\x01\x12\
    \x03B\t\x18\n\x0c\n\x05\x04\x06\x02\x01\x03\x12\x03B\x1b\x1c\n\x0b\n\x04\
    \x04\x06\x02\x02\x12\x03C\x02\x14\n\x0c\n\x05\x04\x06\x02\x02\x06\x12\
    \x03C\x02\n\n\x0c\n\x05\x04\x06\x02\x02\x01\x12\x03C\x0b\x0f\n\x0c\n\x05\
    \x04\x06\x02\x02\x03\x12\x03C\x12\x13\n\x0b\n\x04\x04\x06\x02\x03\x12\
    \x03D\x02\x12\n\x0c\n\x05\x04\x06\x02\x03\x05\x12\x03D\x02\x08\n\x0c\n\
    \x05\x04\x06\x02\x03\x01\x12\x03D\t\r\n\x0c\n\x05\x04\x06\x02\x03\x03\
    \x12\x03D\x10\x11\n\n\n\x02\x04\x07\x12\x04G\0P\x01\n\n\n\x03\x04\x07\
    \x01\x12\x03G\x08\x17\n\x0b\n\x04\x04\x07\x02\0\x12\x03H\x02\x11\n\x0c\n\
    \x05\x04\x07\x02\0\x05\x12\x03H\x02\x07\n\x0c\n\x05\x04\x07\x02\0\x01\
    \x12\x03H\x08\x0c\n\x0c\n\x05\x04\x07\x02\0\x03\x12\x03H\x0f\x10\n\x0b\n\
    \x04\x04\x07\x02\x01\x12\x03I\x02\x1c\n\x0c\n\x05\x04\x07\x02\x01\x05\
    \x12\x03I\x02\x07\n\x0c\n\x05\x04\x07\x02\x01\x01\x12\x03I\x08\x17\n\x0c\
    \n\x05\x04\x07\x02\x01\x03\x12\x03I\x1a\x1b\n\x0b\n\x04\x04\x07\x02\x02\
    \x12\x03J\x02\x1c\n\x0c\n\x05\x04\x07\x02\x02\x05\x12\x03J\x02\x07\n\x0c\
    \n\x05\x04\x07\x02\x02\x01\x12\x03J\x08\x17\n\x0c\n\x05\x04\x07\x02\x02\
    \x03\x12\x03J\x1a\x1b\n\x0b\n\x04\x04\x07\x02\x03\x12\x03K\x02\x16\n\x0c\
    \n\x05\x04\x07\x02\x03\x05\x12\x03K\x02\x08\n\x0c\n\x05\x04\x07\x02\x03\
    \x01\x12\x03K\t\x11\n\x0c\n\x05\x04\x07\x02\x03\x03\x12\x03K\x14\x15\n\
    \x0b\n\x04\x04\x07\x02\x04\x12\x03L\x02\x13\n\x0c\n\x05\x04\x07\x02\x04\
    \x05\x12\x03L\x02\x06\n\x0c\n\x05\x04\x07\x02\x04\x01\x12\x03L\x07\x0e\n\
    \x0c\n\x05\x04\x07\x02\x04\x03\x12\x03L\x11\x12\n\x0b\n\x04\x04\x07\x02\
    \x05\x12\x03M\x02\x17\n\x0c\n\x05\x04\x07\x02\x05\x05\x12\x03M\x02\x08\n\
    \x0c\n\x05\x04\x07\x02\x05\x01\x12\x03M\t\x12\n\x0c\n\x05\x04\x07\x02\
    \x05\x03\x12\x03M\x15\x16\n\x0b\n\x04\x04\x07\x02\x06\x12\x03N\x02\"\n\
    \x0c\n\x05\x04\x07\x02\x06\x05\x12\x03N\x02\x07\n\x0c\n\x05\x04\x07\x02\
    \x06\x01\x12\x03N\x08\x1d\n\x0c\n\x05\x04\x07\x02\x06\x03\x12\x03N\x20!\
    \n\x0b\n\x04\x04\x07\x02\x07\x12\x03O\x02&\n\x0c\n\x05\x04\x07\x02\x07\
    \x04\x12\x03O\x02\n\n\x0c\n\x05\x04\x07\x02\x07\x06\x12\x03O\x0b\x19\n\
    \x0c\n\x05\x04\x07\x02\x07\x01\x12\x03O\x1a!\n\x0c\n\x05\x04\x07\x02\x07\
    \x03\x12\x03O$%\n\n\n\x02\x04\x08\x12\x04R\0U\x01\n\n\n\x03\x04\x08\x01\
    \x12\x03R\x08\x10\n\x0b\n\x04\x04\x08\x02\0\x12\x03S\x02\x1d\n\x0c\n\x05\
    \x04\x08\x02\0\x05\x12\x03S\x02\x08\n\x0c\n\x05\x04\x08\x02\0\x01\x12\
    \x03S\t\x18\n\x0c\n\x05\x04\x08\x02\0\x03\x12\x03S\x1b\x1c\n\x0b\n\x04\
    \x04\x08\x02\x01\x12\x03T\x02\x1d\n\x0c\n\x05\x04\x08\x02\x01\x05\x12\
    \x03T\x02\x08\n\x0c\n\x05\x04\x08\x02\x01\x01\x12\x03T\t\x18\n\x0c\n\x05\
    \x04\x08\x02\x01\x03\x12\x03T\x1b\x1c\n\n\n\x02\x04\t\x12\x04W\0_\x01\n\
    \n\n\x03\x04\t\x01\x12\x03W\x08\x1e\n\x0b\n\x04\x04\t\x02\0\x12\x03X\x02\
    \x14\n\x0c\n\x05\x04\t\x02\0\x05\x12\x03X\x02\x08\n\x0c\n\x05\x04\t\x02\
    \0\x01\x12\x03X\t\x0f\n\x0c\n\x05\x04\t\x02\0\x03\x12\x03X\x12\x13\n\x0b\
    \n\x04\x04\t\x02\x01\x12\x03Y\x02\x1d\n\x0c\n\x05\x04\t\x02\x01\x05\x12\
    \x03Y\x02\x08\n\x0c\n\x05\x04\t\x02\x01\x01\x12\x03Y\t\x18\n\x0c\n\x05\
    \x04\t\x02\x01\x03\x12\x03Y\x1b\x1c\n\x0b\n\x04\x04\t\x02\x02\x12\x03Z\
    \x02\x1c\n\x0c\n\x05\x04\t\x02\x02\x05\x12\x03Z\x02\x08\n\x0c\n\x05\x04\
    \t\x02\x02\x01\x12\x03Z\t\x17\n\x0c\n\x05\x04\t\x02\x02\x03\x12\x03Z\x1a\
    \x1b\n\x0b\n\x04\x04\t\x02\x03\x12\x03[\x02\x1c\n\x0c\n\x05\x04\t\x02\
    \x03\x05\x12\x03[\x02\x08\n\x0c\n\x05\x04\t\x02\x03\x01\x12\x03[\t\x17\n\
    \x0c\n\x05\x04\t\x02\x03\x03\x12\x03[\x1a\x1b\n\x0b\n\x04\x04\t\x02\x04\
    \x12\x03\\\x02:\n\x0c\n\x05\x04\t\x02\x04\x06\x12\x03\\\x02\x1b\n\x0c\n\
    \x05\x04\t\x02\x04\x01\x12\x03\\\x1c5\n\x0c\n\x05\x04\t\x02\x04\x03\x12\
    \x03\\89\n\x0b\n\x04\x04\t\x02\x05\x12\x03]\x02!\n\x0c\n\x05\x04\t\x02\
    \x05\x06\x12\x03]\x02\x14\n\x0c\n\x05\x04\t\x02\x05\x01\x12\x03]\x15\x1c\
    \n\x0c\n\x05\x04\t\x02\x05\x03\x12\x03]\x1f\x20\n\x0b\n\x04\x04\t\x02\
    \x06\x12\x03^\x02\x1a\n\x0c\n\x05\x04\t\x02\x06\x06\x12\x03^\x02\x0b\n\
    \x0c\n\x05\x04\t\x02\x06\x01\x12\x03^\x0c\x15\n\x0c\n\x05\x04\t\x02\x06\
    \x03\x12\x03^\x18\x19\n\n\n\x02\x04\n\x12\x04a\0m\x01\n\n\n\x03\x04\n\
    \x01\x12\x03a\x08\x10\n\x0c\n\x04\x04\n\x04\0\x12\x04c\x02f\x03\n\x0c\n\
    \x05\x04\n\x04\0\x01\x12\x03c\x07\x13\n\r\n\x06\x04\n\x04\0\x02\0\x12\
    \x03d\x04\x19\n\x0e\n\x07\x04\n\x04\0\x02\0\x01\x12\x03d\x04\x14\n\x0e\n\
    \x07\x04\n\x04\0\x02\0\x02\x12\x03d\x17\x18\n\r\n\x06\x04\n\x04\0\x02\
    \x01\x12\x03e\x04\x19\n\x0e\n\x07\x04\n\x04\0\x02\x01\x01\x12\x03e\x04\
    \x14\n\x0e\n\x07\x04\n\x04\0\x02\x01\x02\x12\x03e\x17\x18\n\x0b\n\x04\
    \x04\n\x02\0\x12\x03h\x02\"\n\x0c\n\x05\x04\n\x02\0\x06\x12\x03h\x02\x0e\
    \n\x0c\n\x05\x04\n\x02\0\x01\x12\x03h\x0f\x1d\n\x0c\n\x05\x04\n\x02\0\
    \x03\x12\x03h\x20!\n\x0c\n\x04\x04\n\x08\0\x12\x04i\x02l\x03\n\x0c\n\x05\
    \x04\n\x08\0\x01\x12\x03i\x08\x11\n\x0b\n\x04\x04\n\x02\x01\x12\x03j\x04\
    (\n\x0c\n\x05\x04\n\x02\x01\x06\x12\x03j\x04\x12\n\x0c\n\x05\x04\n\x02\
    \x01\x01\x12\x03j\x13#\n\x0c\n\x05\x04\n\x02\x01\x03\x12\x03j&'\n\x0b\n\
    \x04\x04\n\x02\x02\x12\x03k\x04(\n\x0c\n\x05\x04\n\x02\x02\x06\x12\x03k\
    \x04\x12\n\x0c\n\x05\x04\n\x02\x02\x01\x12\x03k\x13#\n\x0c\n\x05\x04\n\
    \x02\x02\x03\x12\x03k&'\n\n\n\x02\x04\x0b\x12\x04o\0r\x01\n\n\n\x03\x04\
    \x0b\x01\x12\x03o\x08\x16\n\x0b\n\x04\x04\x0b\x02\0\x12\x03p\x02\x18\n\
    \x0c\n\x05\x04\x0b\x02\0\x05\x12\x03p\x02\x08\n\x0c\n\x05\x04\x0b\x02\0\
    \x01\x12\x03p\t\x13\n\x0c\n\x05\x04\x0b\x02\0\x03\x12\x03p\x16\x17\n\x0b\
    \n\x04\x04\x0b\x02\x01\x12\x03q\x02\x1b\n\x0c\n\x05\x04\x0b\x02\x01\x06\
    \x12\x03q\x02\x0f\n\x0c\n\x05\x04\x0b\x02\x01\x01\x12\x03q\x10\x16\n\x0c\
    \n\x05\x04\x0b\x02\x01\x03\x12\x03q\x19\x1a\n\n\n\x02\x04\x0c\x12\x04t\0\
    w\x01\n\n\n\x03\x04\x0c\x01\x12\x03t\x08\x16\n\x0b\n\x04\x04\x0c\x02\0\
    \x12\x03u\x02/\n\x0c\n\x05\x04\x0c\x02\0\x04\x12\x03u\x02\n\n\x0c\n\x05\
    \x04\x0c\x02\0\x06\x12\x03u\x0b\x19\n\x0c\n\x05\x04\x0c\x02\0\x01\x12\
    \x03u\x1a*\n\x0c\n\x05\x04\x0c\x02\0\x03\x12\x03u-.\n\x0b\n\x04\x04\x0c\
    \x02\x01\x12\x03v\x02\x1c\n\x0c\n\x05\x04\x0c\x02\x01\x04\x12\x03v\x02\n\
    \n\x0c\n\x05\x04\x0c\x02\x01\x06\x12\x03v\x0b\x10\n\x0c\n\x05\x04\x0c\
    \x02\x01\x01\x12\x03v\x11\x17\n\x0c\n\x05\x04\x0c\x02\x01\x03\x12\x03v\
    \x1a\x1b\n\x0b\n\x02\x04\r\x12\x05y\0\x8e\x01\x01\n\n\n\x03\x04\r\x01\
    \x12\x03y\x08\x16\n\r\n\x04\x04\r\x04\0\x12\x05{\x02\x82\x01\x03\n\x0c\n\
    \x05\x04\r\x04\0\x01\x12\x03{\x07\x0b\n\r\n\x06\x04\r\x04\0\x02\0\x12\
    \x03|\x04\x16\n\x0e\n\x07\x04\r\x04\0\x02\0\x01\x12\x03|\x04\x11\n\x0e\n\
    \x07\x04\r\x04\0\x02\0\x02\x12\x03|\x14\x15\n\r\n\x06\x04\r\x04\0\x02\
    \x01\x12\x03}\x04\x18\n\x0e\n\x07\x04\r\x04\0\x02\x01\x01\x12\x03}\x04\
    \x13\n\x0e\n\x07\x04\r\x04\0\x02\x01\x02\x12\x03}\x16\x17\n\r\n\x06\x04\
    \r\x04\0\x02\x02\x12\x03~\x04\x1a\n\x0e\n\x07\x04\r\x04\0\x02\x02\x01\
    \x12\x03~\x04\x15\n\x0e\n\x07\x04\r\x04\0\x02\x02\x02\x12\x03~\x18\x19\n\
    \r\n\x06\x04\r\x04\0\x02\x03\x12\x03\x7f\x04\x15\n\x0e\n\x07\x04\r\x04\0\
    \x02\x03\x01\x12\x03\x7f\x04\x10\n\x0e\n\x07\x04\r\x04\0\x02\x03\x02\x12\
    \x03\x7f\x13\x14\n\x0e\n\x06\x04\r\x04\0\x02\x04\x12\x04\x80\x01\x04\x17\
    \n\x0f\n\x07\x04\r\x04\0\x02\x04\x01\x12\x04\x80\x01\x04\x12\n\x0f\n\x07\
    \x04\r\x04\0\x02\x04\x02\x12\x04\x80\x01\x15\x16\n\x0e\n\x06\x04\r\x04\0\
    \x02\x05\x12\x04\x81\x01\x04\x19\n\x0f\n\x07\x04\r\x04\0\x02\x05\x01\x12\
    \x04\x81\x01\x04\x14\n\x0f\n\x07\x04\r\x04\0\x02\x05\x02\x12\x04\x81\x01\
    \x17\x18\n\x0c\n\x04\x04\r\x02\0\x12\x04\x84\x01\x02\x10\n\r\n\x05\x04\r\
    \x02\0\x06\x12\x04\x84\x01\x02\x06\n\r\n\x05\x04\r\x02\0\x01\x12\x04\x84\
    \x01\x07\x0b\n\r\n\x05\x04\r\x02\0\x03\x12\x04\x84\x01\x0e\x0f\n\x0e\n\
    \x04\x04\r\x08\0\x12\x06\x86\x01\x02\x8d\x01\x03\n\r\n\x05\x04\r\x08\0\
    \x01\x12\x04\x86\x01\x08\x0e\n\x0c\n\x04\x04\r\x02\x01\x12\x04\x87\x01\
    \x04#\n\r\n\x05\x04\r\x02\x01\x06\x12\x04\x87\x01\x04\x10\n\r\n\x05\x04\
    \r\x02\x01\x01\x12\x04\x87\x01\x11\x1e\n\r\n\x05\x04\r\x02\x01\x03\x12\
    \x04\x87\x01!\"\n\x0c\n\x04\x04\r\x02\x02\x12\x04\x88\x01\x04'\n\r\n\x05\
    \x04\r\x02\x02\x06\x12\x04\x88\x01\x04\x12\n\r\n\x05\x04\r\x02\x02\x01\
    \x12\x04\x88\x01\x13\"\n\r\n\x05\x04\r\x02\x02\x03\x12\x04\x88\x01%&\n\
    \x0c\n\x04\x04\r\x02\x03\x12\x04\x89\x01\x04*\n\r\n\x05\x04\r\x02\x03\
    \x06\x12\x04\x89\x01\x04\x13\n\r\n\x05\x04\r\x02\x03\x01\x12\x04\x89\x01\
    \x14%\n\r\n\x05\x04\r\x02\x03\x03\x12\x04\x89\x01()\n\x0c\n\x04\x04\r\
    \x02\x04\x12\x04\x8a\x01\x04!\n\r\n\x05\x04\r\x02\x04\x06\x12\x04\x8a\
    \x01\x04\x0f\n\r\n\x05\x04\r\x02\x04\x01\x12\x04\x8a\x01\x10\x1c\n\r\n\
    \x05\x04\r\x02\x04\x03\x12\x04\x8a\x01\x1f\x20\n\x0c\n\x04\x04\r\x02\x05\
    \x12\x04\x8b\x01\x04%\n\r\n\x05\x04\r\x02\x05\x06\x12\x04\x8b\x01\x04\
    \x11\n\r\n\x05\x04\r\x02\x05\x01\x12\x04\x8b\x01\x12\x20\n\r\n\x05\x04\r\
    \x02\x05\x03\x12\x04\x8b\x01#$\n\x0c\n\x04\x04\r\x02\x06\x12\x04\x8c\x01\
    \x04(\n\r\n\x05\x04\r\x02\x06\x06\x12\x04\x8c\x01\x04\x12\n\r\n\x05\x04\
    \r\x02\x06\x01\x12\x04\x8c\x01\x13#\n\r\n\x05\x04\r\x02\x06\x03\x12\x04\
    \x8c\x01&'\n\x0c\n\x02\x04\x0e\x12\x06\x90\x01\0\x94\x01\x01\n\x0b\n\x03\
    \x04\x0e\x01\x12\x04\x90\x01\x08\x14\n\x0c\n\x04\x04\x0e\x02\0\x12\x04\
    \x91\x01\x02\x15\n\r\n\x05\x04\x0e\x02\0\x05\x12\x04\x91\x01\x02\x08\n\r\
    \n\x05\x04\x0e\x02\0\x01\x12\x04\x91\x01\t\x10\n\r\n\x05\x04\x0e\x02\0\
    \x03\x12\x04\x91\x01\x13\x14\n\x0c\n\x04\x04\x0e\x02\x01\x12\x04\x92\x01\
    \x02\x1b\n\r\n\x05\x04\x0e\x02\x01\x05\x12\x04\x92\x01\x02\x07\n\r\n\x05\
    \x04\x0e\x02\x01\x01\x12\x04\x92\x01\x08\x16\n\r\n\x05\x04\x0e\x02\x01\
    \x03\x12\x04\x92\x01\x19\x1a\n\x0c\n\x04\x04\x0e\x02\x02\x12\x04\x93\x01\
    \x02\x1a\n\r\n\x05\x04\x0e\x02\x02\x06\x12\x04\x93\x01\x02\x0e\n\r\n\x05\
    \x04\x0e\x02\x02\x01\x12\x04\x93\x01\x0f\x15\n\r\n\x05\x04\x0e\x02\x02\
    \x03\x12\x04\x93\x01\x18\x19\n\x0c\n\x02\x04\x0f\x12\x06\x96\x01\0\x9a\
    \x01\x01\n\x0b\n\x03\x04\x0f\x01\x12\x04\x96\x01\x08\x16\n\x0c\n\x04\x04\
    \x0f\x02\0\x12\x04\x97\x01\x02\x15\n\r\n\x05\x04\x0f\x02\0\x05\x12\x04\
    \x97\x01\x02\x08\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\x97\x01\t\x10\n\r\n\
    \x05\x04\x0f\x02\0\x03\x12\x04\x97\x01\x13\x14\n\x0c\n\x04\x04\x0f\x02\
    \x01\x12\x04\x98\x01\x02\x1b\n\r\n\x05\x04\x0f\x02\x01\x05\x12\x04\x98\
    \x01\x02\x07\n\r\n\x05\x04\x0f\x02\x01\x01\x12\x04\x98\x01\x08\x16\n\r\n\
    \x05\x04\x0f\x02\x01\x03\x12\x04\x98\x01\x19\x1a\n\x0c\n\x04\x04\x0f\x02\
    \x02\x12\x04\x99\x01\x02\x1d\n\r\n\x05\x04\x0f\x02\x02\x06\x12\x04\x99\
    \x01\x02\x0f\n\r\n\x05\x04\x0f\x02\x02\x01\x12\x04\x99\x01\x10\x18\n\r\n\
    \x05\x04\x0f\x02\x02\x03\x12\x04\x99\x01\x1b\x1c\n\x0c\n\x02\x04\x10\x12\
    \x06\x9c\x01\0\xa1\x01\x01\n\x0b\n\x03\x04\x10\x01\x12\x04\x9c\x01\x08\
    \x17\n\x0c\n\x04\x04\x10\x02\0\x12\x04\x9d\x01\x02\x1b\n\r\n\x05\x04\x10\
    \x02\0\x05\x12\x04\x9d\x01\x02\x07\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\
    \x9d\x01\x08\x16\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\x9d\x01\x19\x1a\n\
    \x0c\n\x04\x04\x10\x02\x01\x12\x04\x9e\x01\x02\x14\n\r\n\x05\x04\x10\x02\
    \x01\x05\x12\x04\x9e\x01\x02\x08\n\r\n\x05\x04\x10\x02\x01\x01\x12\x04\
    \x9e\x01\t\x0f\n\r\n\x05\x04\x10\x02\x01\x03\x12\x04\x9e\x01\x12\x13\n\
    \x0c\n\x04\x04\x10\x02\x02\x12\x04\x9f\x01\x02\x11\n\r\n\x05\x04\x10\x02\
    \x02\x05\x12\x04\x9f\x01\x02\x08\n\r\n\x05\x04\x10\x02\x02\x01\x12\x04\
    \x9f\x01\t\x0c\n\r\n\x05\x04\x10\x02\x02\x03\x12\x04\x9f\x01\x0f\x10\n\
    \x0c\n\x04\x04\x10\x02\x03\x12\x04\xa0\x01\x02\x1b\n\r\n\x05\x04\x10\x02\
    \x03\x06\x12\x04\xa0\x01\x02\x11\n\r\n\x05\x04\x10\x02\x03\x01\x12\x04\
    \xa0\x01\x12\x16\n\r\n\x05\x04\x10\x02\x03\x03\x12\x04\xa0\x01\x19\x1a\n\
    \x0c\n\x02\x04\x11\x12\x06\xa3\x01\0\xa6\x01\x01\n\x0b\n\x03\x04\x11\x01\
    \x12\x04\xa3\x01\x08\x17\n\x0c\n\x04\x04\x11\x02\0\x12\x04\xa4\x01\x02\
    \x11\n\r\n\x05\x04\x11\x02\0\x05\x12\x04\xa4\x01\x02\x08\n\r\n\x05\x04\
    \x11\x02\0\x01\x12\x04\xa4\x01\t\x0c\n\r\n\x05\x04\x11\x02\0\x03\x12\x04\
    \xa4\x01\x0f\x10\n\x0c\n\x04\x04\x11\x02\x01\x12\x04\xa5\x01\x02\x16\n\r\
    \n\x05\x04\x11\x02\x01\x05\x12\x04\xa5\x01\x02\x08\n\r\n\x05\x04\x11\x02\
    \x01\x01\x12\x04\xa5\x01\t\x11\n\r\n\x05\x04\x11\x02\x01\x03\x12\x04\xa5\
    \x01\x14\x15\n\x0c\n\x02\x04\x12\x12\x06\xa8\x01\0\xac\x01\x01\n\x0b\n\
    \x03\x04\x12\x01\x12\x04\xa8\x01\x08\x13\n\x0c\n\x04\x04\x12\x02\0\x12\
    \x04\xa9\x01\x02\x15\n\r\n\x05\x04\x12\x02\0\x05\x12\x04\xa9\x01\x02\x08\
    \n\r\n\x05\x04\x12\x02\0\x01\x12\x04\xa9\x01\t\x10\n\r\n\x05\x04\x12\x02\
    \0\x03\x12\x04\xa9\x01\x13\x14\n\x0c\n\x04\x04\x12\x02\x01\x12\x04\xaa\
    \x01\x02\x1b\n\r\n\x05\x04\x12\x02\x01\x05\x12\x04\xaa\x01\x02\x07\n\r\n\
    \x05\x04\x12\x02\x01\x01\x12\x04\xaa\x01\x08\x16\n\r\n\x05\x04\x12\x02\
    \x01\x03\x12\x04\xaa\x01\x19\x1a\n\x0c\n\x04\x04\x12\x02\x02\x12\x04\xab\
    \x01\x02\x1e\n\r\n\x05\x04\x12\x02\x02\x06\x12\x04\xab\x01\x02\x14\n\r\n\
    \x05\x04\x12\x02\x02\x01\x12\x04\xab\x01\x15\x19\n\r\n\x05\x04\x12\x02\
    \x02\x03\x12\x04\xab\x01\x1c\x1d\n\x0c\n\x02\x04\x13\x12\x06\xae\x01\0\
    \xb2\x01\x01\n\x0b\n\x03\x04\x13\x01\x12\x04\xae\x01\x08\x15\n\x0c\n\x04\
    \x04\x13\x02\0\x12\x04\xaf\x01\x02\x15\n\r\n\x05\x04\x13\x02\0\x05\x12\
    \x04\xaf\x01\x02\x08\n\r\n\x05\x04\x13\x02\0\x01\x12\x04\xaf\x01\t\x10\n\
    \r\n\x05\x04\x13\x02\0\x03\x12\x04\xaf\x01\x13\x14\n\x0c\n\x04\x04\x13\
    \x02\x01\x12\x04\xb0\x01\x02\x1b\n\r\n\x05\x04\x13\x02\x01\x05\x12\x04\
    \xb0\x01\x02\x07\n\r\n\x05\x04\x13\x02\x01\x01\x12\x04\xb0\x01\x08\x16\n\
    \r\n\x05\x04\x13\x02\x01\x03\x12\x04\xb0\x01\x19\x1a\n\x0c\n\x04\x04\x13\
    \x02\x02\x12\x04\xb1\x01\x02\x18\n\r\n\x05\x04\x13\x02\x02\x06\x12\x04\
    \xb1\x01\x02\x0e\n\r\n\x05\x04\x13\x02\x02\x01\x12\x04\xb1\x01\x0f\x13\n\
    \r\n\x05\x04\x13\x02\x02\x03\x12\x04\xb1\x01\x16\x17\n\x0c\n\x02\x04\x14\
    \x12\x06\xb4\x01\0\xb9\x01\x01\n\x0b\n\x03\x04\x14\x01\x12\x04\xb4\x01\
    \x08\x16\n\x0c\n\x04\x04\x14\x02\0\x12\x04\xb5\x01\x02\x11\n\r\n\x05\x04\
    \x14\x02\0\x05\x12\x04\xb5\x01\x02\x08\n\r\n\x05\x04\x14\x02\0\x01\x12\
    \x04\xb5\x01\t\x0c\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\xb5\x01\x0f\x10\n\
    \x0c\n\x04\x04\x14\x02\x01\x12\x04\xb6\x01\x02\x16\n\r\n\x05\x04\x14\x02\
    \x01\x05\x12\x04\xb6\x01\x02\x08\n\r\n\x05\x04\x14\x02\x01\x01\x12\x04\
    \xb6\x01\t\x11\n\r\n\x05\x04\x14\x02\x01\x03\x12\x04\xb6\x01\x14\x15\n\
    \x0c\n\x04\x04\x14\x02\x02\x12\x04\xb7\x01\x02\x13\n\r\n\x05\x04\x14\x02\
    \x02\x05\x12\x04\xb7\x01\x02\x08\n\r\n\x05\x04\x14\x02\x02\x01\x12\x04\
    \xb7\x01\t\x0e\n\r\n\x05\x04\x14\x02\x02\x03\x12\x04\xb7\x01\x11\x12\n\
    \x0c\n\x04\x04\x14\x02\x03\x12\x04\xb8\x01\x02\x18\n\r\n\x05\x04\x14\x02\
    \x03\x05\x12\x04\xb8\x01\x02\x08\n\r\n\x05\x04\x14\x02\x03\x01\x12\x04\
    \xb8\x01\t\x13\n\r\n\x05\x04\x14\x02\x03\x03\x12\x04\xb8\x01\x16\x17\n\
    \x0c\n\x02\x04\x15\x12\x06\xbb\x01\0\xc0\x01\x01\n\x0b\n\x03\x04\x15\x01\
    \x12\x04\xbb\x01\x08\x16\n\x0c\n\x04\x04\x15\x02\0\x12\x04\xbc\x01\x02\
    \x1b\n\r\n\x05\x04\x15\x02\0\x05\x12\x04\xbc\x01\x02\x07\n\r\n\x05\x04\
    \x15\x02\0\x01\x12\x04\xbc\x01\x08\x16\n\r\n\x05\x04\x15\x02\0\x03\x12\
    \x04\xbc\x01\x19\x1a\n\x0c\n\x04\x04\x15\x02\x01\x12\x04\xbd\x01\x02\x14\
    \n\r\n\x05\x04\x15\x02\x01\x05\x12\x04\xbd\x01\x02\x08\n\r\n\x05\x04\x15\
    \x02\x01\x01\x12\x04\xbd\x01\t\x0f\n\r\n\x05\x04\x15\x02\x01\x03\x12\x04\
    \xbd\x01\x12\x13\n\x0c\n\x04\x04\x15\x02\x02\x12\x04\xbe\x01\x02\x11\n\r\
    \n\x05\x04\x15\x02\x02\x05\x12\x04\xbe\x01\x02\x08\n\r\n\x05\x04\x15\x02\
    \x02\x01\x12\x04\xbe\x01\t\x0c\n\r\n\x05\x04\x15\x02\x02\x03\x12\x04\xbe\
    \x01\x0f\x10\n\x0c\n\x04\x04\x15\x02\x03\x12\x04\xbf\x01\x02\x1a\n\r\n\
    \x05\x04\x15\x02\x03\x06\x12\x04\xbf\x01\x02\x10\n\r\n\x05\x04\x15\x02\
    \x03\x01\x12\x04\xbf\x01\x11\x15\n\r\n\x05\x04\x15\x02\x03\x03\x12\x04\
    \xbf\x01\x18\x19\n\x0c\n\x02\x04\x16\x12\x06\xc2\x01\0\xd2\x01\x01\n\x0b\
    \n\x03\x04\x16\x01\x12\x04\xc2\x01\x08\x1a\n\x0e\n\x04\x04\x16\x04\0\x12\
    \x06\xc3\x01\x02\xc8\x01\x03\n\r\n\x05\x04\x16\x04\0\x01\x12\x04\xc3\x01\
    \x07\x0b\n\x0e\n\x06\x04\x16\x04\0\x02\0\x12\x04\xc4\x01\x04\x20\n\x0f\n\
    \x07\x04\x16\x04\0\x02\0\x01\x12\x04\xc4\x01\x04\x1b\n\x0f\n\x07\x04\x16\
    \x04\0\x02\0\x02\x12\x04\xc4\x01\x1e\x1f\n\x0e\n\x06\x04\x16\x04\0\x02\
    \x01\x12\x04\xc5\x01\x04\x17\n\x0f\n\x07\x04\x16\x04\0\x02\x01\x01\x12\
    \x04\xc5\x01\x04\x12\n\x0f\n\x07\x04\x16\x04\0\x02\x01\x02\x12\x04\xc5\
    \x01\x15\x16\n\x0e\n\x06\x04\x16\x04\0\x02\x02\x12\x04\xc6\x01\x04\x1e\n\
    \x0f\n\x07\x04\x16\x04\0\x02\x02\x01\x12\x04\xc6\x01\x04\x19\n\x0f\n\x07\
    \x04\x16\x04\0\x02\x02\x02\x12\x04\xc6\x01\x1c\x1d\n\x0e\n\x06\x04\x16\
    \x04\0\x02\x03\x12\x04\xc7\x01\x04\x1a\n\x0f\n\x07\x04\x16\x04\0\x02\x03\
    \x01\x12\x04\xc7\x01\x04\x15\n\x0f\n\x07\x04\x16\x04\0\x02\x03\x02\x12\
    \x04\xc7\x01\x18\x19\n\x0c\n\x04\x04\x16\x02\0\x12\x04\xca\x01\x02\x10\n\
    \r\n\x05\x04\x16\x02\0\x06\x12\x04\xca\x01\x02\x06\n\r\n\x05\x04\x16\x02\
    \0\x01\x12\x04\xca\x01\x07\x0b\n\r\n\x05\x04\x16\x02\0\x03\x12\x04\xca\
    \x01\x0e\x0f\n\x0e\n\x04\x04\x16\x08\0\x12\x06\xcc\x01\x02\xd1\x01\x03\n\
    \r\n\x05\x04\x16\x08\0\x01\x12\x04\xcc\x01\x08\x0f\n\x0c\n\x04\x04\x16\
    \x02\x01\x12\x04\xcd\x01\x046\n\r\n\x05\x04\x16\x02\x01\x06\x12\x04\xcd\
    \x01\x04\x19\n\r\n\x05\x04\x16\x02\x01\x01\x12\x04\xcd\x01\x1a1\n\r\n\
    \x05\x04\x16\x02\x01\x03\x12\x04\xcd\x0145\n\x0c\n\x04\x04\x16\x02\x02\
    \x12\x04\xce\x01\x04%\n\r\n\x05\x04\x16\x02\x02\x06\x12\x04\xce\x01\x04\
    \x11\n\r\n\x05\x04\x16\x02\x02\x01\x12\x04\xce\x01\x12\x20\n\r\n\x05\x04\
    \x16\x02\x02\x03\x12\x04\xce\x01#$\n\x0c\n\x04\x04\x16\x02\x03\x12\x04\
    \xcf\x01\x042\n\r\n\x05\x04\x16\x02\x03\x06\x12\x04\xcf\x01\x04\x17\n\r\
    \n\x05\x04\x16\x02\x03\x01\x12\x04\xcf\x01\x18-\n\r\n\x05\x04\x16\x02\
    \x03\x03\x12\x04\xcf\x0101\n\x0c\n\x04\x04\x16\x02\x04\x12\x04\xd0\x01\
    \x04*\n\r\n\x05\x04\x16\x02\x04\x06\x12\x04\xd0\x01\x04\x13\n\r\n\x05\
    \x04\x16\x02\x04\x01\x12\x04\xd0\x01\x14%\n\r\n\x05\x04\x16\x02\x04\x03\
    \x12\x04\xd0\x01()\n\x0c\n\x02\x04\x17\x12\x06\xd4\x01\0\xd8\x01\x01\n\
    \x0b\n\x03\x04\x17\x01\x12\x04\xd4\x01\x08\x1d\n\x0c\n\x04\x04\x17\x02\0\
    \x12\x04\xd5\x01\x02\x20\n\r\n\x05\x04\x17\x02\0\x06\x12\x04\xd5\x01\x02\
    \x12\n\r\n\x05\x04\x17\x02\0\x01\x12\x04\xd5\x01\x13\x1b\n\r\n\x05\x04\
    \x17\x02\0\x03\x12\x04\xd5\x01\x1e\x1f\n\x0c\n\x04\x04\x17\x02\x01\x12\
    \x04\xd6\x01\x02'\n\r\n\x05\x04\x17\x02\x01\x04\x12\x04\xd6\x01\x02\n\n\
    \r\n\x05\x04\x17\x02\x01\x06\x12\x04\xd6\x01\x0b\x13\n\r\n\x05\x04\x17\
    \x02\x01\x01\x12\x04\xd6\x01\x14\"\n\r\n\x05\x04\x17\x02\x01\x03\x12\x04\
    \xd6\x01%&\n\x0c\n\x04\x04\x17\x02\x02\x12\x04\xd7\x01\x02\x20\n\r\n\x05\
    \x04\x17\x02\x02\x04\x12\x04\xd7\x01\x02\n\n\r\n\x05\x04\x17\x02\x02\x05\
    \x12\x04\xd7\x01\x0b\x11\n\r\n\x05\x04\x17\x02\x02\x01\x12\x04\xd7\x01\
    \x12\x1b\n\r\n\x05\x04\x17\x02\x02\x03\x12\x04\xd7\x01\x1e\x1f\n\x0c\n\
    \x02\x04\x18\x12\x06\xda\x01\0\xdd\x01\x01\n\x0b\n\x03\x04\x18\x01\x12\
    \x04\xda\x01\x08\x1a\n\x0c\n\x04\x04\x18\x02\0\x12\x04\xdb\x01\x02\x15\n\
    \r\n\x05\x04\x18\x02\0\x05\x12\x04\xdb\x01\x02\x07\n\r\n\x05\x04\x18\x02\
    \0\x01\x12\x04\xdb\x01\x08\x10\n\r\n\x05\x04\x18\x02\0\x03\x12\x04\xdb\
    \x01\x13\x14\n\x0c\n\x04\x04\x18\x02\x01\x12\x04\xdc\x01\x02\x17\n\r\n\
    \x05\x04\x18\x02\x01\x06\x12\x04\xdc\x01\x02\x0e\n\r\n\x05\x04\x18\x02\
    \x01\x01\x12\x04\xdc\x01\x0f\x12\n\r\n\x05\x04\x18\x02\x01\x03\x12\x04\
    \xdc\x01\x15\x16\n\x0c\n\x02\x04\x19\x12\x06\xdf\x01\0\xe3\x01\x01\n\x0b\
    \n\x03\x04\x19\x01\x12\x04\xdf\x01\x08\x15\n\x0c\n\x04\x04\x19\x02\0\x12\
    \x04\xe0\x01\x02\x1e\n\r\n\x05\x04\x19\x02\0\x06\x12\x04\xe0\x01\x02\x14\
    \n\r\n\x05\x04\x19\x02\0\x01\x12\x04\xe0\x01\x15\x19\n\r\n\x05\x04\x19\
    \x02\0\x03\x12\x04\xe0\x01\x1c\x1d\n\x0c\n\x04\x04\x19\x02\x01\x12\x04\
    \xe1\x01\x02'\n\r\n\x05\x04\x19\x02\x01\x04\x12\x04\xe1\x01\x02\n\n\r\n\
    \x05\x04\x19\x02\x01\x06\x12\x04\xe1\x01\x0b\x13\n\r\n\x05\x04\x19\x02\
    \x01\x01\x12\x04\xe1\x01\x14\"\n\r\n\x05\x04\x19\x02\x01\x03\x12\x04\xe1\
    \x01%&\n\x0c\n\x04\x04\x19\x02\x02\x12\x04\xe2\x01\x02\x20\n\r\n\x05\x04\
    \x19\x02\x02\x04\x12\x04\xe2\x01\x02\n\n\r\n\x05\x04\x19\x02\x02\x05\x12\
    \x04\xe2\x01\x0b\x11\n\r\n\x05\x04\x19\x02\x02\x01\x12\x04\xe2\x01\x12\
    \x1b\n\r\n\x05\x04\x19\x02\x02\x03\x12\x04\xe2\x01\x1e\x1f\n\x0c\n\x02\
    \x04\x1a\x12\x06\xe5\x01\0\xe7\x01\x01\n\x0b\n\x03\x04\x1a\x01\x12\x04\
    \xe5\x01\x08\x1b\n\x0c\n\x04\x04\x1a\x02\0\x12\x04\xe6\x01\x02*\n\r\n\
    \x05\x04\x1a\x02\0\x04\x12\x04\xe6\x01\x02\n\n\r\n\x05\x04\x1a\x02\0\x06\
    \x12\x04\xe6\x01\x0b\x1d\n\r\n\x05\x04\x1a\x02\0\x01\x12\x04\xe6\x01\x1e\
    %\n\r\n\x05\x04\x1a\x02\0\x03\x12\x04\xe6\x01()\n\x0c\n\x02\x04\x1b\x12\
    \x06\xe9\x01\0\xec\x01\x01\n\x0b\n\x03\x04\x1b\x01\x12\x04\xe9\x01\x08\
    \x1a\n\x0c\n\x04\x04\x1b\x02\0\x12\x04\xea\x01\x02\x15\n\r\n\x05\x04\x1b\
    \x02\0\x05\x12\x04\xea\x01\x02\x07\n\r\n\x05\x04\x1b\x02\0\x01\x12\x04\
    \xea\x01\x08\x10\n\r\n\x05\x04\x1b\x02\0\x03\x12\x04\xea\x01\x13\x14\n\
    \x0c\n\x04\x04\x1b\x02\x01\x12\x04\xeb\x01\x02\x15\n\r\n\x05\x04\x1b\x02\
    \x01\x06\x12\x04\xeb\x01\x02\x0c\n\r\n\x05\x04\x1b\x02\x01\x01\x12\x04\
    \xeb\x01\r\x10\n\r\n\x05\x04\x1b\x02\x01\x03\x12\x04\xeb\x01\x13\x14\n\
    \x0c\n\x02\x04\x1c\x12\x06\xee\x01\0\xf4\x01\x01\n\x0b\n\x03\x04\x1c\x01\
    \x12\x04\xee\x01\x08\x12\n\x0c\n\x04\x04\x1c\x02\0\x12\x04\xef\x01\x02\
    \x15\n\r\n\x05\x04\x1c\x02\0\x05\x12\x04\xef\x01\x02\x08\n\r\n\x05\x04\
    \x1c\x02\0\x01\x12\x04\xef\x01\t\x10\n\r\n\x05\x04\x1c\x02\0\x03\x12\x04\
    \xef\x01\x13\x14\n\x0c\n\x04\x04\x1c\x02\x01\x12\x04\xf0\x01\x02\x12\n\r\
    \n\x05\x04\x1c\x02\x01\x05\x12\x04\xf0\x01\x02\x08\n\r\n\x05\x04\x1c\x02\
    \x01\x01\x12\x04\xf0\x01\t\r\n\r\n\x05\x04\x1c\x02\x01\x03\x12\x04\xf0\
    \x01\x10\x11\n\x0c\n\x04\x04\x1c\x02\x02\x12\x04\xf1\x01\x02$\n\r\n\x05\
    \x04\x1c\x02\x02\x04\x12\x04\xf1\x01\x02\n\n\r\n\x05\x04\x1c\x02\x02\x06\
    \x12\x04\xf1\x01\x0b\x17\n\r\n\x05\x04\x1c\x02\x02\x01\x12\x04\xf1\x01\
    \x18\x1f\n\r\n\x05\x04\x1c\x02\x02\x03\x12\x04\xf1\x01\"#\n\x0c\n\x04\
    \x04\x1c\x02\x03\x12\x04\xf2\x01\x02.\n\r\n\x05\x04\x1c\x02\x03\x04\x12\
    \x04\xf2\x01\x02\n\n\r\n\x05\x04\x1c\x02\x03\x06\x12\x04\xf2\x01\x0b\x17\
    \n\r\n\x05\x04\x1c\x02\x03\x01\x12\x04\xf2\x01\x18)\n\r\n\x05\x04\x1c\
    \x02\x03\x03\x12\x04\xf2\x01,-\n\x0c\n\x04\x04\x1c\x02\x04\x12\x04\xf3\
    \x01\x02\"\n\r\n\x05\x04\x1c\x02\x04\x04\x12\x04\xf3\x01\x02\n\n\r\n\x05\
    \x04\x1c\x02\x04\x06\x12\x04\xf3\x01\x0b\x15\n\r\n\x05\x04\x1c\x02\x04\
    \x01\x12\x04\xf3\x01\x16\x1d\n\r\n\x05\x04\x1c\x02\x04\x03\x12\x04\xf3\
    \x01\x20!\n\x0c\n\x02\x04\x1d\x12\x06\xf5\x01\0\x81\x02\x01\n\x0b\n\x03\
    \x04\x1d\x01\x12\x04\xf5\x01\x08\x14\n\x0e\n\x04\x04\x1d\x04\0\x12\x06\
    \xf6\x01\x02\xfa\x01\x03\n\r\n\x05\x04\x1d\x04\0\x01\x12\x04\xf6\x01\x07\
    \x11\n\x0e\n\x06\x04\x1d\x04\0\x02\0\x12\x04\xf7\x01\x04\x10\n\x0f\n\x07\
    \x04\x1d\x04\0\x02\0\x01\x12\x04\xf7\x01\x04\x0b\n\x0f\n\x07\x04\x1d\x04\
    \0\x02\0\x02\x12\x04\xf7\x01\x0e\x0f\n\x0e\n\x06\x04\x1d\x04\0\x02\x01\
    \x12\x04\xf8\x01\x04\x0f\n\x0f\n\x07\x04\x1d\x04\0\x02\x01\x01\x12\x04\
    \xf8\x01\x04\n\n\x0f\n\x07\x04\x1d\x04\0\x02\x01\x02\x12\x04\xf8\x01\r\
    \x0e\n\x0e\n\x06\x04\x1d\x04\0\x02\x02\x12\x04\xf9\x01\x04\x0f\n\x0f\n\
    \x07\x04\x1d\x04\0\x02\x02\x01\x12\x04\xf9\x01\x04\n\n\x0f\n\x07\x04\x1d\
    \x04\0\x02\x02\x02\x12\x04\xf9\x01\r\x0e\n\x0c\n\x04\x04\x1d\x02\0\x12\
    \x04\xfb\x01\x02\x12\n\r\n\x05\x04\x1d\x02\0\x05\x12\x04\xfb\x01\x02\x08\
    \n\r\n\x05\x04\x1d\x02\0\x01\x12\x04\xfb\x01\t\r\n\r\n\x05\x04\x1d\x02\0\
    \x03\x12\x04\xfb\x01\x10\x11\n\x0c\n\x04\x04\x1d\x02\x01\x12\x04\xfc\x01\
    \x02)\n\r\n\x05\x04\x1d\x02\x01\x06\x12\x04\xfc\x01\x02\x19\n\r\n\x05\
    \x04\x1d\x02\x01\x01\x12\x04\xfc\x01\x1a$\n\r\n\x05\x04\x1d\x02\x01\x03\
    \x12\x04\xfc\x01'(\n\x0c\n\x04\x04\x1d\x02\x02\x12\x04\xfd\x01\x02\x14\n\
    \r\n\x05\x04\x1d\x02\x02\x05\x12\x04\xfd\x01\x02\x06\n\r\n\x05\x04\x1d\
    \x02\x02\x01\x12\x04\xfd\x01\x07\x0f\n\r\n\x05\x04\x1d\x02\x02\x03\x12\
    \x04\xfd\x01\x12\x13\n\x0c\n\x04\x04\x1d\x02\x03\x12\x04\xfe\x01\x02@\n\
    \r\n\x05\x04\x1d\x02\x03\x04\x12\x04\xfe\x01\x02\n\n\r\n\x05\x04\x1d\x02\
    \x03\x06\x12\x04\xfe\x01\x0b'\n\r\n\x05\x04\x1d\x02\x03\x01\x12\x04\xfe\
    \x01(;\n\r\n\x05\x04\x1d\x02\x03\x03\x12\x04\xfe\x01>?\n\x0c\n\x04\x04\
    \x1d\x02\x04\x12\x04\xff\x01\x02\x1f\n\r\n\x05\x04\x1d\x02\x04\x04\x12\
    \x04\xff\x01\x02\n\n\r\n\x05\x04\x1d\x02\x04\x06\x12\x04\xff\x01\x0b\x13\
    \n\r\n\x05\x04\x1d\x02\x04\x01\x12\x04\xff\x01\x14\x1a\n\r\n\x05\x04\x1d\
    \x02\x04\x03\x12\x04\xff\x01\x1d\x1e\n\x0c\n\x04\x04\x1d\x02\x05\x12\x04\
    \x80\x02\x02\x1f\n\r\n\x05\x04\x1d\x02\x05\x04\x12\x04\x80\x02\x02\n\n\r\
    \n\x05\x04\x1d\x02\x05\x06\x12\x04\x80\x02\x0b\x13\n\r\n\x05\x04\x1d\x02\
    \x05\x01\x12\x04\x80\x02\x14\x1a\n\r\n\x05\x04\x1d\x02\x05\x03\x12\x04\
    \x80\x02\x1d\x1e\n\x0c\n\x02\x04\x1e\x12\x06\x83\x02\0\x89\x02\x01\n\x0b\
    \n\x03\x04\x1e\x01\x12\x04\x83\x02\x08\x12\n\x0c\n\x04\x04\x1e\x02\0\x12\
    \x04\x84\x02\x02\x12\n\r\n\x05\x04\x1e\x02\0\x05\x12\x04\x84\x02\x02\x08\
    \n\r\n\x05\x04\x1e\x02\0\x01\x12\x04\x84\x02\t\r\n\r\n\x05\x04\x1e\x02\0\
    \x03\x12\x04\x84\x02\x10\x11\n\x0c\n\x04\x04\x1e\x02\x01\x12\x04\x85\x02\
    \x02\x15\n\r\n\x05\x04\x1e\x02\x01\x05\x12\x04\x85\x02\x02\x06\n\r\n\x05\
    \x04\x1e\x02\x01\x01\x12\x04\x85\x02\x07\x10\n\r\n\x05\x04\x1e\x02\x01\
    \x03\x12\x04\x85\x02\x13\x14\n\x0c\n\x04\x04\x1e\x02\x02\x12\x04\x86\x02\
    \x02%\n\r\n\x05\x04\x1e\x02\x02\x04\x12\x04\x86\x02\x02\n\n\r\n\x05\x04\
    \x1e\x02\x02\x06\x12\x04\x86\x02\x0b\x16\n\r\n\x05\x04\x1e\x02\x02\x01\
    \x12\x04\x86\x02\x17\x20\n\r\n\x05\x04\x1e\x02\x02\x03\x12\x04\x86\x02#$\
    \n\x0c\n\x04\x04\x1e\x02\x03\x12\x04\x87\x02\x02>\n\r\n\x05\x04\x1e\x02\
    \x03\x04\x12\x04\x87\x02\x02\n\n\r\n\x05\x04\x1e\x02\x03\x06\x12\x04\x87\
    \x02\x0b%\n\r\n\x05\x04\x1e\x02\x03\x01\x12\x04\x87\x02&9\n\r\n\x05\x04\
    \x1e\x02\x03\x03\x12\x04\x87\x02<=\n\x0c\n\x04\x04\x1e\x02\x04\x12\x04\
    \x88\x02\x02&\n\r\n\x05\x04\x1e\x02\x04\x04\x12\x04\x88\x02\x02\n\n\r\n\
    \x05\x04\x1e\x02\x04\x06\x12\x04\x88\x02\x0b\x1a\n\r\n\x05\x04\x1e\x02\
    \x04\x01\x12\x04\x88\x02\x1b!\n\r\n\x05\x04\x1e\x02\x04\x03\x12\x04\x88\
    \x02$%\n\x0c\n\x02\x04\x1f\x12\x06\x8b\x02\0\x8e\x02\x01\n\x0b\n\x03\x04\
    \x1f\x01\x12\x04\x8b\x02\x08\"\n\x0c\n\x04\x04\x1f\x02\0\x12\x04\x8c\x02\
    \x02'\n\r\n\x05\x04\x1f\x02\0\x04\x12\x04\x8c\x02\x02\n\n\r\n\x05\x04\
    \x1f\x02\0\x06\x12\x04\x8c\x02\x0b\x16\n\r\n\x05\x04\x1f\x02\0\x01\x12\
    \x04\x8c\x02\x17\"\n\r\n\x05\x04\x1f\x02\0\x03\x12\x04\x8c\x02%&\n\x0c\n\
    \x04\x04\x1f\x02\x01\x12\x04\x8d\x02\x02\x16\n\r\n\x05\x04\x1f\x02\x01\
    \x05\x12\x04\x8d\x02\x02\x06\n\r\n\x05\x04\x1f\x02\x01\x01\x12\x04\x8d\
    \x02\x07\x11\n\r\n\x05\x04\x1f\x02\x01\x03\x12\x04\x8d\x02\x14\x15\n\x0c\
    \n\x02\x04\x20\x12\x06\x90\x02\0\x93\x02\x01\n\x0b\n\x03\x04\x20\x01\x12\
    \x04\x90\x02\x08\x17\n\x0c\n\x04\x04\x20\x02\0\x12\x04\x91\x02\x02\x12\n\
    \r\n\x05\x04\x20\x02\0\x05\x12\x04\x91\x02\x02\x08\n\r\n\x05\x04\x20\x02\
    \0\x01\x12\x04\x91\x02\t\r\n\r\n\x05\x04\x20\x02\0\x03\x12\x04\x91\x02\
    \x10\x11\n\x0c\n\x04\x04\x20\x02\x01\x12\x04\x92\x02\x02\x14\n\r\n\x05\
    \x04\x20\x02\x01\x06\x12\x04\x92\x02\x02\n\n\r\n\x05\x04\x20\x02\x01\x01\
    \x12\x04\x92\x02\x0b\x0f\n\r\n\x05\x04\x20\x02\x01\x03\x12\x04\x92\x02\
    \x12\x13\n\x0c\n\x02\x04!\x12\x06\x95\x02\0\x97\x02\x01\n\x0b\n\x03\x04!\
    \x01\x12\x04\x95\x02\x08$\n\x0c\n\x04\x04!\x02\0\x12\x04\x96\x02\x02'\n\
    \r\n\x05\x04!\x02\0\x04\x12\x04\x96\x02\x02\n\n\r\n\x05\x04!\x02\0\x06\
    \x12\x04\x96\x02\x0b\x16\n\r\n\x05\x04!\x02\0\x01\x12\x04\x96\x02\x17\"\
    \n\r\n\x05\x04!\x02\0\x03\x12\x04\x96\x02%&\n\x0c\n\x02\x05\0\x12\x06\
    \x99\x02\0\xa5\x02\x01\n\x0b\n\x03\x05\0\x01\x12\x04\x99\x02\x05\x0e\n\
    \x0c\n\x04\x05\0\x02\0\x12\x04\x9a\x02\x02\x0b\n\r\n\x05\x05\0\x02\0\x01\
    \x12\x04\x9a\x02\x02\x06\n\r\n\x05\x05\0\x02\0\x02\x12\x04\x9a\x02\t\n\n\
    \x0c\n\x04\x05\0\x02\x01\x12\x04\x9b\x02\x02\t\n\r\n\x05\x05\0\x02\x01\
    \x01\x12\x04\x9b\x02\x02\x04\n\r\n\x05\x05\0\x02\x01\x02\x12\x04\x9b\x02\
    \x07\x08\n\x0c\n\x04\x05\0\x02\x02\x12\x04\x9c\x02\x02\n\n\r\n\x05\x05\0\
    \x02\x02\x01\x12\x04\x9c\x02\x02\x05\n\r\n\x05\x05\0\x02\x02\x02\x12\x04\
    \x9c\x02\x08\t\n\x0c\n\x04\x05\0\x02\x03\x12\x04\x9d\x02\x02\x0b\n\r\n\
    \x05\x05\0\x02\x03\x01\x12\x04\x9d\x02\x02\x06\n\r\n\x05\x05\0\x02\x03\
    \x02\x12\x04\x9d\x02\t\n\n\x0c\n\x04\x05\0\x02\x04\x12\x04\x9e\x02\x02\
    \x0e\n\r\n\x05\x05\0\x02\x04\x01\x12\x04\x9e\x02\x02\t\n\r\n\x05\x05\0\
    \x02\x04\x02\x12\x04\x9e\x02\x0c\r\n\x0c\n\x04\x05\0\x02\x05\x12\x04\x9f\
    \x02\x02\r\n\r\n\x05\x05\0\x02\x05\x01\x12\x04\x9f\x02\x02\x08\n\r\n\x05\
    \x05\0\x02\x05\x02\x12\x04\x9f\x02\x0b\x0c\n)\n\x04\x05\0\x02\x06\x12\
    \x04\xa0\x02\x02\r\"\x1b\x20{\x20items:\x20Box<MoveType>\x20},\n\n\r\n\
    \x05\x05\0\x02\x06\x01\x12\x04\xa0\x02\x02\x08\n\r\n\x05\x05\0\x02\x06\
    \x02\x12\x04\xa0\x02\x0b\x0c\n\x1f\n\x04\x05\0\x02\x07\x12\x04\xa1\x02\
    \x02\r\"\x11(MoveStructTag),\n\n\r\n\x05\x05\0\x02\x07\x01\x12\x04\xa1\
    \x02\x02\x08\n\r\n\x05\x05\0\x02\x07\x02\x12\x04\xa1\x02\x0b\x0c\n\x1f\n\
    \x04\x05\0\x02\x08\x12\x04\xa2\x02\x02\x17\"\x11\x20{\x20index:\x20u16\
    \x20},\n\n\r\n\x05\x05\0\x02\x08\x01\x12\x04\xa2\x02\x02\x12\n\r\n\x05\
    \x05\0\x02\x08\x02\x12\x04\xa2\x02\x15\x16\n5\n\x04\x05\0\x02\t\x12\x04\
    \xa3\x02\x02\x10\"'\x20{\x20mutable:\x20bool,\x20to:\x20Box<MoveType>\
    \x20},\n\n\r\n\x05\x05\0\x02\t\x01\x12\x04\xa3\x02\x02\x0b\n\r\n\x05\x05\
    \0\x02\t\x02\x12\x04\xa3\x02\x0e\x0f\n\x18\n\x04\x05\0\x02\n\x12\x04\xa4\
    \x02\x02\x12\"\n(String),\n\n\r\n\x05\x05\0\x02\n\x01\x12\x04\xa4\x02\
    \x02\x0c\n\r\n\x05\x05\0\x02\n\x02\x12\x04\xa4\x02\x0f\x11\n\x0c\n\x02\
    \x04\"\x12\x06\xa7\x02\0\xb6\x02\x01\n\x0b\n\x03\x04\"\x01\x12\x04\xa7\
    \x02\x08\x10\n\x0e\n\x04\x04\"\x03\0\x12\x06\xa9\x02\x02\xac\x02\x03\n\r\
    \n\x05\x04\"\x03\0\x01\x12\x04\xa9\x02\n\x17\n\x0e\n\x06\x04\"\x03\0\x02\
    \0\x12\x04\xaa\x02\x04\x15\n\x0f\n\x07\x04\"\x03\0\x02\0\x05\x12\x04\xaa\
    \x02\x04\x08\n\x0f\n\x07\x04\"\x03\0\x02\0\x01\x12\x04\xaa\x02\t\x10\n\
    \x0f\n\x07\x04\"\x03\0\x02\0\x03\x12\x04\xaa\x02\x13\x14\n\x0e\n\x06\x04\
    \"\x03\0\x02\x01\x12\x04\xab\x02\x04\x14\n\x0f\n\x07\x04\"\x03\0\x02\x01\
    \x06\x12\x04\xab\x02\x04\x0c\n\x0f\n\x07\x04\"\x03\0\x02\x01\x01\x12\x04\
    \xab\x02\r\x0f\n\x0f\n\x07\x04\"\x03\0\x02\x01\x03\x12\x04\xab\x02\x12\
    \x13\n\x0c\n\x04\x04\"\x02\0\x12\x04\xae\x02\x02\x15\n\r\n\x05\x04\"\x02\
    \0\x06\x12\x04\xae\x02\x02\x0b\n\r\n\x05\x04\"\x02\0\x01\x12\x04\xae\x02\
    \x0c\x10\n\r\n\x05\x04\"\x02\0\x03\x12\x04\xae\x02\x13\x14\n\x0e\n\x04\
    \x04\"\x08\0\x12\x06\xaf\x02\x02\xb5\x02\x03\n\r\n\x05\x04\"\x08\0\x01\
    \x12\x04\xaf\x02\x08\x0f\n\x0c\n\x04\x04\"\x02\x01\x12\x04\xb0\x02\x04\
    \x18\n\r\n\x05\x04\"\x02\x01\x06\x12\x04\xb0\x02\x04\x0c\n\r\n\x05\x04\"\
    \x02\x01\x01\x12\x04\xb0\x02\r\x13\n\r\n\x05\x04\"\x02\x01\x03\x12\x04\
    \xb0\x02\x16\x17\n\x0c\n\x04\x04\"\x02\x02\x12\x04\xb1\x02\x04\x1d\n\r\n\
    \x05\x04\"\x02\x02\x06\x12\x04\xb1\x02\x04\x11\n\r\n\x05\x04\"\x02\x02\
    \x01\x12\x04\xb1\x02\x12\x18\n\r\n\x05\x04\"\x02\x02\x03\x12\x04\xb1\x02\
    \x1b\x1c\n\x0c\n\x04\x04\"\x02\x03\x12\x04\xb2\x02\x04(\n\r\n\x05\x04\"\
    \x02\x03\x05\x12\x04\xb2\x02\x04\n\n\r\n\x05\x04\"\x02\x03\x01\x12\x04\
    \xb2\x02\x0b#\n\r\n\x05\x04\"\x02\x03\x03\x12\x04\xb2\x02&'\n\x0c\n\x04\
    \x04\"\x02\x04\x12\x04\xb3\x02\x04\x20\n\r\n\x05\x04\"\x02\x04\x06\x12\
    \x04\xb3\x02\x04\x11\n\r\n\x05\x04\"\x02\x04\x01\x12\x04\xb3\x02\x12\x1b\
    \n\r\n\x05\x04\"\x02\x04\x03\x12\x04\xb3\x02\x1e\x1f\n\x0c\n\x04\x04\"\
    \x02\x05\x12\x04\xb4\x02\x04\x1a\n\r\n\x05\x04\"\x02\x05\x05\x12\x04\xb4\
    \x02\x04\n\n\r\n\x05\x04\"\x02\x05\x01\x12\x04\xb4\x02\x0b\x15\n\r\n\x05\
    \x04\"\x02\x05\x03\x12\x04\xb4\x02\x18\x19\n\x0c\n\x02\x05\x01\x12\x06\
    \xb8\x02\0\xbd\x02\x01\n\x0b\n\x03\x05\x01\x01\x12\x04\xb8\x02\x05\x10\n\
    \x0c\n\x04\x05\x01\x02\0\x12\x04\xb9\x02\x02\x0b\n\r\n\x05\x05\x01\x02\0\
    \x01\x12\x04\xb9\x02\x02\x06\n\r\n\x05\x05\x01\x02\0\x02\x12\x04\xb9\x02\
    \t\n\n\x0c\n\x04\x05\x01\x02\x01\x12\x04\xba\x02\x02\x0b\n\r\n\x05\x05\
    \x01\x02\x01\x01\x12\x04\xba\x02\x02\x06\n\r\n\x05\x05\x01\x02\x01\x02\
    \x12\x04\xba\x02\t\n\n\x0c\n\x04\x05\x01\x02\x02\x12\x04\xbb\x02\x02\x0c\
    \n\r\n\x05\x05\x01\x02\x02\x01\x12\x04\xbb\x02\x02\x07\n\r\n\x05\x05\x01\
    \x02\x02\x02\x12\x04\xbb\x02\n\x0b\n\x0c\n\x04\x05\x01\x02\x03\x12\x04\
    \xbc\x02\x02\n\n\r\n\x05\x05\x01\x02\x03\x01\x12\x04\xbc\x02\x02\x05\n\r\
    \n\x05\x05\x01\x02\x03\x02\x12\x04\xbc\x02\x08\t\n\x0c\n\x02\x04#\x12\
    \x06\xbf\x02\0\xc1\x02\x01\n\x0b\n\x03\x04#\x01\x12\x04\xbf\x02\x08\x17\
    \n\x0c\n\x04\x04#\x02\0\x12\x04\xc0\x02\x02\x19\n\r\n\x05\x04#\x02\0\x06\
    \x12\x04\xc0\x02\x02\n\n\r\n\x05\x04#\x02\0\x01\x12\x04\xc0\x02\x0b\x14\
    \n\r\n\x05\x04#\x02\0\x03\x12\x04\xc0\x02\x17\x18\n\x0c\n\x02\x04$\x12\
    \x06\xc3\x02\0\xc6\x02\x01\n\x0b\n\x03\x04$\x01\x12\x04\xc3\x02\x08\x18\
    \n\x0c\n\x04\x04$\x02\0\x12\x04\xc4\x02\x02\x1a\n\r\n\x05\x04$\x02\0\x06\
    \x12\x04\xc4\x02\x02\x0e\n\r\n\x05\x04$\x02\0\x01\x12\x04\xc4\x02\x0f\
    \x15\n\r\n\x05\x04$\x02\0\x03\x12\x04\xc4\x02\x18\x19\n\x0c\n\x04\x04$\
    \x02\x01\x12\x04\xc5\x02\x02\x12\n\r\n\x05\x04$\x02\x01\x05\x12\x04\xc5\
    \x02\x02\x08\n\r\n\x05\x04$\x02\x01\x01\x12\x04\xc5\x02\t\r\n\r\n\x05\
    \x04$\x02\x01\x03\x12\x04\xc5\x02\x10\x11\n\x0c\n\x02\x04%\x12\x06\xc8\
    \x02\0\xcb\x02\x01\n\x0b\n\x03\x04%\x01\x12\x04\xc8\x02\x08\x14\n\x0c\n\
    \x04\x04%\x02\0\x12\x04\xc9\x02\x02\x19\n\r\n\x05\x04%\x02\0\x06\x12\x04\
    \xc9\x02\x02\x0f\n\r\n\x05\x04%\x02\0\x01\x12\x04\xc9\x02\x10\x14\n\r\n\
    \x05\x04%\x02\0\x03\x12\x04\xc9\x02\x17\x18\n\x0c\n\x04\x04%\x02\x01\x12\
    \x04\xca\x02\x02\x12\n\r\n\x05\x04%\x02\x01\x05\x12\x04\xca\x02\x02\x08\
    \n\r\n\x05\x04%\x02\x01\x01\x12\x04\xca\x02\t\r\n\r\n\x05\x04%\x02\x01\
    \x03\x12\x04\xca\x02\x10\x11\n\x0c\n\x02\x04&\x12\x06\xcd\x02\0\xd0\x02\
    \x01\n\x0b\n\x03\x04&\x01\x12\x04\xcd\x02\x08\x14\n\x0c\n\x04\x04&\x02\0\
    \x12\x04\xce\x02\x02\x15\n\r\n\x05\x04&\x02\0\x05\x12\x04\xce\x02\x02\
    \x08\n\r\n\x05\x04&\x02\0\x01\x12\x04\xce\x02\t\x10\n\r\n\x05\x04&\x02\0\
    \x03\x12\x04\xce\x02\x13\x14\n\x0c\n\x04\x04&\x02\x01\x12\x04\xcf\x02\
    \x02\x12\n\r\n\x05\x04&\x02\x01\x05\x12\x04\xcf\x02\x02\x08\n\r\n\x05\
    \x04&\x02\x01\x01\x12\x04\xcf\x02\t\r\n\r\n\x05\x04&\x02\x01\x03\x12\x04\
    \xcf\x02\x10\x11\n\x0c\n\x02\x04'\x12\x06\xd2\x02\0\xd7\x02\x01\n\x0b\n\
    \x03\x04'\x01\x12\x04\xd2\x02\x08\x15\n\x0c\n\x04\x04'\x02\0\x12\x04\xd3\
    \x02\x02\x15\n\r\n\x05\x04'\x02\0\x05\x12\x04\xd3\x02\x02\x08\n\r\n\x05\
    \x04'\x02\0\x01\x12\x04\xd3\x02\t\x10\n\r\n\x05\x04'\x02\0\x03\x12\x04\
    \xd3\x02\x13\x14\n\x0c\n\x04\x04'\x02\x01\x12\x04\xd4\x02\x02\x14\n\r\n\
    \x05\x04'\x02\x01\x05\x12\x04\xd4\x02\x02\x08\n\r\n\x05\x04'\x02\x01\x01\
    \x12\x04\xd4\x02\t\x0f\n\r\n\x05\x04'\x02\x01\x03\x12\x04\xd4\x02\x12\
    \x13\n\x0c\n\x04\x04'\x02\x02\x12\x04\xd5\x02\x02\x12\n\r\n\x05\x04'\x02\
    \x02\x05\x12\x04\xd5\x02\x02\x08\n\r\n\x05\x04'\x02\x02\x01\x12\x04\xd5\
    \x02\t\r\n\r\n\x05\x04'\x02\x02\x03\x12\x04\xd5\x02\x10\x11\n\x0c\n\x04\
    \x04'\x02\x03\x12\x04\xd6\x02\x02,\n\r\n\x05\x04'\x02\x03\x04\x12\x04\
    \xd6\x02\x02\n\n\r\n\x05\x04'\x02\x03\x06\x12\x04\xd6\x02\x0b\x13\n\r\n\
    \x05\x04'\x02\x03\x01\x12\x04\xd6\x02\x14'\n\r\n\x05\x04'\x02\x03\x03\
    \x12\x04\xd6\x02*+\n\x0c\n\x02\x04(\x12\x06\xd9\x02\0\xe7\x02\x01\n\x0b\
    \n\x03\x04(\x01\x12\x04\xd9\x02\x08\x11\n\x0e\n\x04\x04(\x04\0\x12\x06\
    \xdb\x02\x02\xdf\x02\x03\n\r\n\x05\x04(\x04\0\x01\x12\x04\xdb\x02\x07\
    \x0b\n\x0e\n\x06\x04(\x04\0\x02\0\x12\x04\xdc\x02\x04\x11\n\x0f\n\x07\
    \x04(\x04\0\x02\0\x01\x12\x04\xdc\x02\x04\x0c\n\x0f\n\x07\x04(\x04\0\x02\
    \0\x02\x12\x04\xdc\x02\x0f\x10\n\x0e\n\x06\x04(\x04\0\x02\x01\x12\x04\
    \xdd\x02\x04\x17\n\x0f\n\x07\x04(\x04\0\x02\x01\x01\x12\x04\xdd\x02\x04\
    \x12\n\x0f\n\x07\x04(\x04\0\x02\x01\x02\x12\x04\xdd\x02\x15\x16\n\x0e\n\
    \x06\x04(\x04\0\x02\x02\x12\x04\xde\x02\x04\x14\n\x0f\n\x07\x04(\x04\0\
    \x02\x02\x01\x12\x04\xde\x02\x04\x0f\n\x0f\n\x07\x04(\x04\0\x02\x02\x02\
    \x12\x04\xde\x02\x12\x13\n\x0c\n\x04\x04(\x02\0\x12\x04\xe1\x02\x02\x10\
    \n\r\n\x05\x04(\x02\0\x06\x12\x04\xe1\x02\x02\x06\n\r\n\x05\x04(\x02\0\
    \x01\x12\x04\xe1\x02\x07\x0b\n\r\n\x05\x04(\x02\0\x03\x12\x04\xe1\x02\
    \x0e\x0f\n\x0e\n\x04\x04(\x08\0\x12\x06\xe2\x02\x02\xe6\x02\x03\n\r\n\
    \x05\x04(\x08\0\x01\x12\x04\xe2\x02\x08\x11\n\x0c\n\x04\x04(\x02\x01\x12\
    \x04\xe3\x02\x04\"\n\r\n\x05\x04(\x02\x01\x06\x12\x04\xe3\x02\x04\x14\n\
    \r\n\x05\x04(\x02\x01\x01\x12\x04\xe3\x02\x15\x1d\n\r\n\x05\x04(\x02\x01\
    \x03\x12\x04\xe3\x02\x20!\n\x0c\n\x04\x04(\x02\x02\x12\x04\xe4\x02\x04-\
    \n\r\n\x05\x04(\x02\x02\x06\x12\x04\xe4\x02\x04\x19\n\r\n\x05\x04(\x02\
    \x02\x01\x12\x04\xe4\x02\x1a(\n\r\n\x05\x04(\x02\x02\x03\x12\x04\xe4\x02\
    +,\n\x0c\n\x04\x04(\x02\x03\x12\x04\xe5\x02\x04(\n\r\n\x05\x04(\x02\x03\
    \x06\x12\x04\xe5\x02\x04\x17\n\r\n\x05\x04(\x02\x03\x01\x12\x04\xe5\x02\
    \x18#\n\r\n\x05\x04(\x02\x03\x03\x12\x04\xe5\x02&'\n\x0c\n\x02\x04)\x12\
    \x06\xe9\x02\0\xec\x02\x01\n\x0b\n\x03\x04)\x01\x12\x04\xe9\x02\x08\x18\
    \n\x0c\n\x04\x04)\x02\0\x12\x04\xea\x02\x02\x17\n\r\n\x05\x04)\x02\0\x05\
    \x12\x04\xea\x02\x02\x07\n\r\n\x05\x04)\x02\0\x01\x12\x04\xea\x02\x08\
    \x12\n\r\n\x05\x04)\x02\0\x03\x12\x04\xea\x02\x15\x16\n\x0c\n\x04\x04)\
    \x02\x01\x12\x04\xeb\x02\x02\x16\n\r\n\x05\x04)\x02\x01\x05\x12\x04\xeb\
    \x02\x02\x07\n\r\n\x05\x04)\x02\x01\x01\x12\x04\xeb\x02\x08\x11\n\r\n\
    \x05\x04)\x02\x01\x03\x12\x04\xeb\x02\x14\x15\n\x0c\n\x02\x04*\x12\x06\
    \xee\x02\0\xf3\x02\x01\n\x0b\n\x03\x04*\x01\x12\x04\xee\x02\x08\x1d\n\
    \x0c\n\x04\x04*\x02\0\x12\x04\xef\x02\x02!\n\r\n\x05\x04*\x02\0\x04\x12\
    \x04\xef\x02\x02\n\n\r\n\x05\x04*\x02\0\x05\x12\x04\xef\x02\x0b\x10\n\r\
    \n\x05\x04*\x02\0\x01\x12\x04\xef\x02\x11\x1c\n\r\n\x05\x04*\x02\0\x03\
    \x12\x04\xef\x02\x1f\x20\n\x0c\n\x04\x04*\x02\x01\x12\x04\xf0\x02\x02\
    \x20\n\r\n\x05\x04*\x02\x01\x04\x12\x04\xf0\x02\x02\n\n\r\n\x05\x04*\x02\
    \x01\x05\x12\x04\xf0\x02\x0b\x10\n\r\n\x05\x04*\x02\x01\x01\x12\x04\xf0\
    \x02\x11\x1b\n\r\n\x05\x04*\x02\x01\x03\x12\x04\xf0\x02\x1e\x1f\n\x0c\n\
    \x04\x04*\x02\x02\x12\x04\xf1\x02\x02\x17\n\r\n\x05\x04*\x02\x02\x05\x12\
    \x04\xf1\x02\x02\x08\n\r\n\x05\x04*\x02\x02\x01\x12\x04\xf1\x02\t\x12\n\
    \r\n\x05\x04*\x02\x02\x03\x12\x04\xf1\x02\x15\x16\n\x0c\n\x04\x04*\x02\
    \x03\x12\x04\xf2\x02\x02\x13\n\r\n\x05\x04*\x02\x03\x05\x12\x04\xf2\x02\
    \x02\x07\n\r\n\x05\x04*\x02\x03\x01\x12\x04\xf2\x02\x08\x0e\n\r\n\x05\
    \x04*\x02\x03\x03\x12\x04\xf2\x02\x11\x12\n\x0c\n\x02\x04+\x12\x06\xf5\
    \x02\0\xf9\x02\x01\n\x0b\n\x03\x04+\x01\x12\x04\xf5\x02\x08\x1b\n\x0c\n\
    \x04\x04+\x02\0\x12\x04\xf6\x02\x02\x1e\n\r\n\x05\x04+\x02\0\x06\x12\x04\
    \xf6\x02\x02\x12\n\r\n\x05\x04+\x02\0\x01\x12\x04\xf6\x02\x13\x19\n\r\n\
    \x05\x04+\x02\0\x03\x12\x04\xf6\x02\x1c\x1d\n\x0c\n\x04\x04+\x02\x01\x12\
    \x04\xf7\x02\x021\n\r\n\x05\x04+\x02\x01\x04\x12\x04\xf7\x02\x02\n\n\r\n\
    \x05\x04+\x02\x01\x05\x12\x04\xf7\x02\x0b\x11\n\r\n\x05\x04+\x02\x01\x01\
    \x12\x04\xf7\x02\x12,\n\r\n\x05\x04+\x02\x01\x03\x12\x04\xf7\x02/0\n\x0c\
    \n\x04\x04+\x02\x02\x12\x04\xf8\x02\x022\n\r\n\x05\x04+\x02\x02\x04\x12\
    \x04\xf8\x02\x02\n\n\r\n\x05\x04+\x02\x02\x06\x12\x04\xf8\x02\x0b\x1b\n\
    \r\n\x05\x04+\x02\x02\x01\x12\x04\xf8\x02\x1c-\n\r\n\x05\x04+\x02\x02\
    \x03\x12\x04\xf8\x0201\n\x0c\n\x02\x04,\x12\x06\xfb\x02\0\x86\x03\x01\n\
    \x0b\n\x03\x04,\x01\x12\x04\xfb\x02\x08\x18\n\x0e\n\x04\x04,\x04\0\x12\
    \x06\xfc\x02\x02\xff\x02\x03\n\r\n\x05\x04,\x04\0\x01\x12\x04\xfc\x02\
    \x07\x0b\n\x0e\n\x06\x04,\x04\0\x02\0\x12\x04\xfd\x02\x04\x11\n\x0f\n\
    \x07\x04,\x04\0\x02\0\x01\x12\x04\xfd\x02\x04\x0c\n\x0f\n\x07\x04,\x04\0\
    \x02\0\x02\x12\x04\xfd\x02\x0f\x10\n\x0e\n\x06\x04,\x04\0\x02\x01\x12\
    \x04\xfe\x02\x04\x17\n\x0f\n\x07\x04,\x04\0\x02\x01\x01\x12\x04\xfe\x02\
    \x04\x12\n\x0f\n\x07\x04,\x04\0\x02\x01\x02\x12\x04\xfe\x02\x15\x16\n\
    \x0c\n\x04\x04,\x02\0\x12\x04\x81\x03\x02\x10\n\r\n\x05\x04,\x02\0\x06\
    \x12\x04\x81\x03\x02\x06\n\r\n\x05\x04,\x02\0\x01\x12\x04\x81\x03\x07\
    \x0b\n\r\n\x05\x04,\x02\0\x03\x12\x04\x81\x03\x0e\x0f\n\x0e\n\x04\x04,\
    \x08\0\x12\x06\x82\x03\x02\x85\x03\x03\n\r\n\x05\x04,\x08\0\x01\x12\x04\
    \x82\x03\x08\x11\n\x0c\n\x04\x04,\x02\x01\x12\x04\x83\x03\x04\"\n\r\n\
    \x05\x04,\x02\x01\x06\x12\x04\x83\x03\x04\x14\n\r\n\x05\x04,\x02\x01\x01\
    \x12\x04\x83\x03\x15\x1d\n\r\n\x05\x04,\x02\x01\x03\x12\x04\x83\x03\x20!\
    \n\x0c\n\x04\x04,\x02\x02\x12\x04\x84\x03\x04-\n\r\n\x05\x04,\x02\x02\
    \x06\x12\x04\x84\x03\x04\x19\n\r\n\x05\x04,\x02\x02\x01\x12\x04\x84\x03\
    \x1a(\n\r\n\x05\x04,\x02\x02\x03\x12\x04\x84\x03+,b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(::protobuf::well_known_types::timestamp::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(46);
            messages.push(Transaction::generated_message_descriptor_data());
            messages.push(TransactionTrimmed::generated_message_descriptor_data());
            messages.push(BlockMetadataTransaction::generated_message_descriptor_data());
            messages.push(GenesisTransaction::generated_message_descriptor_data());
            messages.push(StateCheckpointTransaction::generated_message_descriptor_data());
            messages.push(UserTransaction::generated_message_descriptor_data());
            messages.push(Event::generated_message_descriptor_data());
            messages.push(TransactionInfo::generated_message_descriptor_data());
            messages.push(EventKey::generated_message_descriptor_data());
            messages.push(UserTransactionRequest::generated_message_descriptor_data());
            messages.push(WriteSet::generated_message_descriptor_data());
            messages.push(ScriptWriteSet::generated_message_descriptor_data());
            messages.push(DirectWriteSet::generated_message_descriptor_data());
            messages.push(WriteSetChange::generated_message_descriptor_data());
            messages.push(DeleteModule::generated_message_descriptor_data());
            messages.push(DeleteResource::generated_message_descriptor_data());
            messages.push(DeleteTableItem::generated_message_descriptor_data());
            messages.push(DeleteTableData::generated_message_descriptor_data());
            messages.push(WriteModule::generated_message_descriptor_data());
            messages.push(WriteResource::generated_message_descriptor_data());
            messages.push(WriteTableData::generated_message_descriptor_data());
            messages.push(WriteTableItem::generated_message_descriptor_data());
            messages.push(TransactionPayload::generated_message_descriptor_data());
            messages.push(ScriptFunctionPayload::generated_message_descriptor_data());
            messages.push(MoveScriptBytecode::generated_message_descriptor_data());
            messages.push(ScriptPayload::generated_message_descriptor_data());
            messages.push(ModuleBundlePayload::generated_message_descriptor_data());
            messages.push(MoveModuleBytecode::generated_message_descriptor_data());
            messages.push(MoveModule::generated_message_descriptor_data());
            messages.push(MoveFunction::generated_message_descriptor_data());
            messages.push(MoveStruct::generated_message_descriptor_data());
            messages.push(MoveStructGenericTypeParam::generated_message_descriptor_data());
            messages.push(MoveStructField::generated_message_descriptor_data());
            messages.push(MoveFunctionGenericTypeParam::generated_message_descriptor_data());
            messages.push(MoveType::generated_message_descriptor_data());
            messages.push(WriteSetPayload::generated_message_descriptor_data());
            messages.push(ScriptFunctionId::generated_message_descriptor_data());
            messages.push(MoveResource::generated_message_descriptor_data());
            messages.push(MoveModuleId::generated_message_descriptor_data());
            messages.push(MoveStructTag::generated_message_descriptor_data());
            messages.push(Signature::generated_message_descriptor_data());
            messages.push(Ed25519Signature::generated_message_descriptor_data());
            messages.push(MultiEd25519Signature::generated_message_descriptor_data());
            messages.push(MultiAgentSignature::generated_message_descriptor_data());
            messages.push(AccountSignature::generated_message_descriptor_data());
            messages.push(move_type::ReferenceType::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(9);
            enums.push(MoveTypes::generated_enum_descriptor_data());
            enums.push(MoveAbility::generated_enum_descriptor_data());
            enums.push(transaction::TransactionType::generated_enum_descriptor_data());
            enums.push(write_set::WriteSetType::generated_enum_descriptor_data());
            enums.push(write_set_change::Type::generated_enum_descriptor_data());
            enums.push(transaction_payload::Type::generated_enum_descriptor_data());
            enums.push(move_function::Visibility::generated_enum_descriptor_data());
            enums.push(signature::Type::generated_enum_descriptor_data());
            enums.push(account_signature::Type::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
