// Copyright (c) Aptos
// SPDX-License-Identifier: Apache-2.0

// This file was generated. Do not modify!
//
// To update this code, run: `cargo run --release -p framework`.

//! Conversion library between a structured representation of a Move script call (`ScriptCall`) and the
//! standard BCS-compatible representation used in Aptos transactions (`Script`).
//!
//! This code was generated by compiling known Script interfaces ("ABIs") with the tool `transaction-builder-generator`.

#![allow(clippy::unnecessary_wraps)]
#![allow(unused_imports)]
use aptos_types::{
    account_address::AccountAddress,
    transaction::{Script, ScriptFunction, TransactionArgument, TransactionPayload, VecBytes},
};
use move_core_types::{
    ident_str,
    language_storage::{ModuleId, TypeTag},
};
use std::collections::BTreeMap as Map;

type Bytes = Vec<u8>;

/// Structured representation of a call into a known Move script function.
/// ```ignore
/// impl ScriptFunctionCall {
///     pub fn encode(self) -> TransactionPayload { .. }
///     pub fn decode(&TransactionPayload) -> Option<ScriptFunctionCall> { .. }
/// }
/// ```
#[derive(Clone, Debug, PartialEq, PartialOrd)]
#[cfg_attr(feature = "fuzzing", derive(proptest_derive::Arbitrary))]
#[cfg_attr(feature = "fuzzing", proptest(no_params))]
pub enum ScriptFunctionCall {
    CancelOfferScript {
        receiver: AccountAddress,
        creator: AccountAddress,
        token_creation_num: u64,
    },

    /// Claim the delegated mint capability and destroy the delegated token.
    ClaimMintCapability {},

    ClaimScript {
        sender: AccountAddress,
        creator: AccountAddress,
        token_creation_num: u64,
    },

    /// Basic account creation method.
    CreateAccount { auth_key: AccountAddress },

    CreateFiniteCollectionScript {
        description: Bytes,
        name: Bytes,
        uri: Bytes,
        maximum: u64,
    },

    CreateSimpleToken {
        collection_name: Bytes,
        description: Bytes,
        name: Bytes,
        supply: u64,
        uri: Bytes,
    },

    CreateTokenScript {
        collection_name: Bytes,
        description: Bytes,
        name: Bytes,
        supply: u64,
        uri: Bytes,
    },

    CreateUnlimitedCollectionScript {
        description: Bytes,
        name: Bytes,
        uri: Bytes,
    },

    /// Create delegated token for the address so the account could claim MintCapability later.
    DelegateMintCapability { to: AccountAddress },

    /// Mint coins with capability.
    Mint {
        mint_addr: AccountAddress,
        amount: u64,
    },

    OfferScript {
        receiver: AccountAddress,
        creator: AccountAddress,
        token_creation_num: u64,
        amount: u64,
    },

    /// Rotate the authentication key for the account under cap.account_address
    RotateAuthenticationKey { new_authentication_key: Bytes },

    SetGasConstants {
        global_memory_per_byte_cost: u64,
        global_memory_per_byte_write_cost: u64,
        min_transaction_gas_units: u64,
        large_transaction_cutoff: u64,
        intrinsic_gas_per_byte: u64,
        maximum_number_of_gas_units: u64,
        min_price_per_gas_unit: u64,
        max_price_per_gas_unit: u64,
        max_transaction_size_in_bytes: u64,
        gas_unit_scaling_factor: u64,
        default_account_size: u64,
    },

    /// Updates the major version to a larger version.
    SetVersion { major: u64 },

    /// Transfers `amount` of tokens from `from` to `to`.
    Transfer { to: AccountAddress, amount: u64 },
}

impl ScriptFunctionCall {
    /// Build an Aptos `TransactionPayload` from a structured object `ScriptFunctionCall`.
    pub fn encode(self) -> TransactionPayload {
        use ScriptFunctionCall::*;
        match self {
            CancelOfferScript {
                receiver,
                creator,
                token_creation_num,
            } => encode_cancel_offer_script_script_function(receiver, creator, token_creation_num),
            ClaimMintCapability {} => encode_claim_mint_capability_script_function(),
            ClaimScript {
                sender,
                creator,
                token_creation_num,
            } => encode_claim_script_script_function(sender, creator, token_creation_num),
            CreateAccount { auth_key } => encode_create_account_script_function(auth_key),
            CreateFiniteCollectionScript {
                description,
                name,
                uri,
                maximum,
            } => encode_create_finite_collection_script_script_function(
                description,
                name,
                uri,
                maximum,
            ),
            CreateSimpleToken {
                collection_name,
                description,
                name,
                supply,
                uri,
            } => encode_create_simple_token_script_function(
                collection_name,
                description,
                name,
                supply,
                uri,
            ),
            CreateTokenScript {
                collection_name,
                description,
                name,
                supply,
                uri,
            } => encode_create_token_script_script_function(
                collection_name,
                description,
                name,
                supply,
                uri,
            ),
            CreateUnlimitedCollectionScript {
                description,
                name,
                uri,
            } => encode_create_unlimited_collection_script_script_function(description, name, uri),
            DelegateMintCapability { to } => encode_delegate_mint_capability_script_function(to),
            Mint { mint_addr, amount } => encode_mint_script_function(mint_addr, amount),
            OfferScript {
                receiver,
                creator,
                token_creation_num,
                amount,
            } => encode_offer_script_script_function(receiver, creator, token_creation_num, amount),
            RotateAuthenticationKey {
                new_authentication_key,
            } => encode_rotate_authentication_key_script_function(new_authentication_key),
            SetGasConstants {
                global_memory_per_byte_cost,
                global_memory_per_byte_write_cost,
                min_transaction_gas_units,
                large_transaction_cutoff,
                intrinsic_gas_per_byte,
                maximum_number_of_gas_units,
                min_price_per_gas_unit,
                max_price_per_gas_unit,
                max_transaction_size_in_bytes,
                gas_unit_scaling_factor,
                default_account_size,
            } => encode_set_gas_constants_script_function(
                global_memory_per_byte_cost,
                global_memory_per_byte_write_cost,
                min_transaction_gas_units,
                large_transaction_cutoff,
                intrinsic_gas_per_byte,
                maximum_number_of_gas_units,
                min_price_per_gas_unit,
                max_price_per_gas_unit,
                max_transaction_size_in_bytes,
                gas_unit_scaling_factor,
                default_account_size,
            ),
            SetVersion { major } => encode_set_version_script_function(major),
            Transfer { to, amount } => encode_transfer_script_function(to, amount),
        }
    }

    /// Try to recognize an Aptos `TransactionPayload` and convert it into a structured object `ScriptFunctionCall`.
    pub fn decode(payload: &TransactionPayload) -> Option<ScriptFunctionCall> {
        if let TransactionPayload::ScriptFunction(script) = payload {
            match SCRIPT_FUNCTION_DECODER_MAP.get(&format!(
                "{}{}",
                script.module().name(),
                script.function()
            )) {
                Some(decoder) => decoder(payload),
                None => None,
            }
        } else {
            None
        }
    }
}

pub fn encode_cancel_offer_script_script_function(
    receiver: AccountAddress,
    creator: AccountAddress,
    token_creation_num: u64,
) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("TokenTransfers").to_owned(),
        ),
        ident_str!("cancel_offer_script").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&receiver).unwrap(),
            bcs::to_bytes(&creator).unwrap(),
            bcs::to_bytes(&token_creation_num).unwrap(),
        ],
    ))
}

/// Claim the delegated mint capability and destroy the delegated token.
pub fn encode_claim_mint_capability_script_function() -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("TestCoin").to_owned(),
        ),
        ident_str!("claim_mint_capability").to_owned(),
        vec![],
        vec![],
    ))
}

pub fn encode_claim_script_script_function(
    sender: AccountAddress,
    creator: AccountAddress,
    token_creation_num: u64,
) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("TokenTransfers").to_owned(),
        ),
        ident_str!("claim_script").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&sender).unwrap(),
            bcs::to_bytes(&creator).unwrap(),
            bcs::to_bytes(&token_creation_num).unwrap(),
        ],
    ))
}

/// Basic account creation method.
pub fn encode_create_account_script_function(auth_key: AccountAddress) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("AptosAccount").to_owned(),
        ),
        ident_str!("create_account").to_owned(),
        vec![],
        vec![bcs::to_bytes(&auth_key).unwrap()],
    ))
}

pub fn encode_create_finite_collection_script_script_function(
    description: Vec<u8>,
    name: Vec<u8>,
    uri: Vec<u8>,
    maximum: u64,
) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("Token").to_owned(),
        ),
        ident_str!("create_finite_collection_script").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&description).unwrap(),
            bcs::to_bytes(&name).unwrap(),
            bcs::to_bytes(&uri).unwrap(),
            bcs::to_bytes(&maximum).unwrap(),
        ],
    ))
}

pub fn encode_create_simple_token_script_function(
    collection_name: Vec<u8>,
    description: Vec<u8>,
    name: Vec<u8>,
    supply: u64,
    uri: Vec<u8>,
) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("SimpleToken").to_owned(),
        ),
        ident_str!("create_simple_token").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&collection_name).unwrap(),
            bcs::to_bytes(&description).unwrap(),
            bcs::to_bytes(&name).unwrap(),
            bcs::to_bytes(&supply).unwrap(),
            bcs::to_bytes(&uri).unwrap(),
        ],
    ))
}

pub fn encode_create_token_script_script_function(
    collection_name: Vec<u8>,
    description: Vec<u8>,
    name: Vec<u8>,
    supply: u64,
    uri: Vec<u8>,
) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("Token").to_owned(),
        ),
        ident_str!("create_token_script").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&collection_name).unwrap(),
            bcs::to_bytes(&description).unwrap(),
            bcs::to_bytes(&name).unwrap(),
            bcs::to_bytes(&supply).unwrap(),
            bcs::to_bytes(&uri).unwrap(),
        ],
    ))
}

pub fn encode_create_unlimited_collection_script_script_function(
    description: Vec<u8>,
    name: Vec<u8>,
    uri: Vec<u8>,
) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("Token").to_owned(),
        ),
        ident_str!("create_unlimited_collection_script").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&description).unwrap(),
            bcs::to_bytes(&name).unwrap(),
            bcs::to_bytes(&uri).unwrap(),
        ],
    ))
}

/// Create delegated token for the address so the account could claim MintCapability later.
pub fn encode_delegate_mint_capability_script_function(to: AccountAddress) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("TestCoin").to_owned(),
        ),
        ident_str!("delegate_mint_capability").to_owned(),
        vec![],
        vec![bcs::to_bytes(&to).unwrap()],
    ))
}

/// Mint coins with capability.
pub fn encode_mint_script_function(mint_addr: AccountAddress, amount: u64) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("TestCoin").to_owned(),
        ),
        ident_str!("mint").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&mint_addr).unwrap(),
            bcs::to_bytes(&amount).unwrap(),
        ],
    ))
}

pub fn encode_offer_script_script_function(
    receiver: AccountAddress,
    creator: AccountAddress,
    token_creation_num: u64,
    amount: u64,
) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("TokenTransfers").to_owned(),
        ),
        ident_str!("offer_script").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&receiver).unwrap(),
            bcs::to_bytes(&creator).unwrap(),
            bcs::to_bytes(&token_creation_num).unwrap(),
            bcs::to_bytes(&amount).unwrap(),
        ],
    ))
}

/// Rotate the authentication key for the account under cap.account_address
pub fn encode_rotate_authentication_key_script_function(
    new_authentication_key: Vec<u8>,
) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("AptosAccount").to_owned(),
        ),
        ident_str!("rotate_authentication_key").to_owned(),
        vec![],
        vec![bcs::to_bytes(&new_authentication_key).unwrap()],
    ))
}

pub fn encode_set_gas_constants_script_function(
    global_memory_per_byte_cost: u64,
    global_memory_per_byte_write_cost: u64,
    min_transaction_gas_units: u64,
    large_transaction_cutoff: u64,
    intrinsic_gas_per_byte: u64,
    maximum_number_of_gas_units: u64,
    min_price_per_gas_unit: u64,
    max_price_per_gas_unit: u64,
    max_transaction_size_in_bytes: u64,
    gas_unit_scaling_factor: u64,
    default_account_size: u64,
) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("AptosVMConfig").to_owned(),
        ),
        ident_str!("set_gas_constants").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&global_memory_per_byte_cost).unwrap(),
            bcs::to_bytes(&global_memory_per_byte_write_cost).unwrap(),
            bcs::to_bytes(&min_transaction_gas_units).unwrap(),
            bcs::to_bytes(&large_transaction_cutoff).unwrap(),
            bcs::to_bytes(&intrinsic_gas_per_byte).unwrap(),
            bcs::to_bytes(&maximum_number_of_gas_units).unwrap(),
            bcs::to_bytes(&min_price_per_gas_unit).unwrap(),
            bcs::to_bytes(&max_price_per_gas_unit).unwrap(),
            bcs::to_bytes(&max_transaction_size_in_bytes).unwrap(),
            bcs::to_bytes(&gas_unit_scaling_factor).unwrap(),
            bcs::to_bytes(&default_account_size).unwrap(),
        ],
    ))
}

/// Updates the major version to a larger version.
pub fn encode_set_version_script_function(major: u64) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("AptosVersion").to_owned(),
        ),
        ident_str!("set_version").to_owned(),
        vec![],
        vec![bcs::to_bytes(&major).unwrap()],
    ))
}

/// Transfers `amount` of tokens from `from` to `to`.
pub fn encode_transfer_script_function(to: AccountAddress, amount: u64) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("TestCoin").to_owned(),
        ),
        ident_str!("transfer").to_owned(),
        vec![],
        vec![bcs::to_bytes(&to).unwrap(), bcs::to_bytes(&amount).unwrap()],
    ))
}

fn decode_cancel_offer_script_script_function(
    payload: &TransactionPayload,
) -> Option<ScriptFunctionCall> {
    if let TransactionPayload::ScriptFunction(script) = payload {
        Some(ScriptFunctionCall::CancelOfferScript {
            receiver: bcs::from_bytes(script.args().get(0)?).ok()?,
            creator: bcs::from_bytes(script.args().get(1)?).ok()?,
            token_creation_num: bcs::from_bytes(script.args().get(2)?).ok()?,
        })
    } else {
        None
    }
}

fn decode_claim_mint_capability_script_function(
    payload: &TransactionPayload,
) -> Option<ScriptFunctionCall> {
    if let TransactionPayload::ScriptFunction(_script) = payload {
        Some(ScriptFunctionCall::ClaimMintCapability {})
    } else {
        None
    }
}

fn decode_claim_script_script_function(payload: &TransactionPayload) -> Option<ScriptFunctionCall> {
    if let TransactionPayload::ScriptFunction(script) = payload {
        Some(ScriptFunctionCall::ClaimScript {
            sender: bcs::from_bytes(script.args().get(0)?).ok()?,
            creator: bcs::from_bytes(script.args().get(1)?).ok()?,
            token_creation_num: bcs::from_bytes(script.args().get(2)?).ok()?,
        })
    } else {
        None
    }
}

fn decode_create_account_script_function(
    payload: &TransactionPayload,
) -> Option<ScriptFunctionCall> {
    if let TransactionPayload::ScriptFunction(script) = payload {
        Some(ScriptFunctionCall::CreateAccount {
            auth_key: bcs::from_bytes(script.args().get(0)?).ok()?,
        })
    } else {
        None
    }
}

fn decode_create_finite_collection_script_script_function(
    payload: &TransactionPayload,
) -> Option<ScriptFunctionCall> {
    if let TransactionPayload::ScriptFunction(script) = payload {
        Some(ScriptFunctionCall::CreateFiniteCollectionScript {
            description: bcs::from_bytes(script.args().get(0)?).ok()?,
            name: bcs::from_bytes(script.args().get(1)?).ok()?,
            uri: bcs::from_bytes(script.args().get(2)?).ok()?,
            maximum: bcs::from_bytes(script.args().get(3)?).ok()?,
        })
    } else {
        None
    }
}

fn decode_create_simple_token_script_function(
    payload: &TransactionPayload,
) -> Option<ScriptFunctionCall> {
    if let TransactionPayload::ScriptFunction(script) = payload {
        Some(ScriptFunctionCall::CreateSimpleToken {
            collection_name: bcs::from_bytes(script.args().get(0)?).ok()?,
            description: bcs::from_bytes(script.args().get(1)?).ok()?,
            name: bcs::from_bytes(script.args().get(2)?).ok()?,
            supply: bcs::from_bytes(script.args().get(3)?).ok()?,
            uri: bcs::from_bytes(script.args().get(4)?).ok()?,
        })
    } else {
        None
    }
}

fn decode_create_token_script_script_function(
    payload: &TransactionPayload,
) -> Option<ScriptFunctionCall> {
    if let TransactionPayload::ScriptFunction(script) = payload {
        Some(ScriptFunctionCall::CreateTokenScript {
            collection_name: bcs::from_bytes(script.args().get(0)?).ok()?,
            description: bcs::from_bytes(script.args().get(1)?).ok()?,
            name: bcs::from_bytes(script.args().get(2)?).ok()?,
            supply: bcs::from_bytes(script.args().get(3)?).ok()?,
            uri: bcs::from_bytes(script.args().get(4)?).ok()?,
        })
    } else {
        None
    }
}

fn decode_create_unlimited_collection_script_script_function(
    payload: &TransactionPayload,
) -> Option<ScriptFunctionCall> {
    if let TransactionPayload::ScriptFunction(script) = payload {
        Some(ScriptFunctionCall::CreateUnlimitedCollectionScript {
            description: bcs::from_bytes(script.args().get(0)?).ok()?,
            name: bcs::from_bytes(script.args().get(1)?).ok()?,
            uri: bcs::from_bytes(script.args().get(2)?).ok()?,
        })
    } else {
        None
    }
}

fn decode_delegate_mint_capability_script_function(
    payload: &TransactionPayload,
) -> Option<ScriptFunctionCall> {
    if let TransactionPayload::ScriptFunction(script) = payload {
        Some(ScriptFunctionCall::DelegateMintCapability {
            to: bcs::from_bytes(script.args().get(0)?).ok()?,
        })
    } else {
        None
    }
}

fn decode_mint_script_function(payload: &TransactionPayload) -> Option<ScriptFunctionCall> {
    if let TransactionPayload::ScriptFunction(script) = payload {
        Some(ScriptFunctionCall::Mint {
            mint_addr: bcs::from_bytes(script.args().get(0)?).ok()?,
            amount: bcs::from_bytes(script.args().get(1)?).ok()?,
        })
    } else {
        None
    }
}

fn decode_offer_script_script_function(payload: &TransactionPayload) -> Option<ScriptFunctionCall> {
    if let TransactionPayload::ScriptFunction(script) = payload {
        Some(ScriptFunctionCall::OfferScript {
            receiver: bcs::from_bytes(script.args().get(0)?).ok()?,
            creator: bcs::from_bytes(script.args().get(1)?).ok()?,
            token_creation_num: bcs::from_bytes(script.args().get(2)?).ok()?,
            amount: bcs::from_bytes(script.args().get(3)?).ok()?,
        })
    } else {
        None
    }
}

fn decode_rotate_authentication_key_script_function(
    payload: &TransactionPayload,
) -> Option<ScriptFunctionCall> {
    if let TransactionPayload::ScriptFunction(script) = payload {
        Some(ScriptFunctionCall::RotateAuthenticationKey {
            new_authentication_key: bcs::from_bytes(script.args().get(0)?).ok()?,
        })
    } else {
        None
    }
}

fn decode_set_gas_constants_script_function(
    payload: &TransactionPayload,
) -> Option<ScriptFunctionCall> {
    if let TransactionPayload::ScriptFunction(script) = payload {
        Some(ScriptFunctionCall::SetGasConstants {
            global_memory_per_byte_cost: bcs::from_bytes(script.args().get(0)?).ok()?,
            global_memory_per_byte_write_cost: bcs::from_bytes(script.args().get(1)?).ok()?,
            min_transaction_gas_units: bcs::from_bytes(script.args().get(2)?).ok()?,
            large_transaction_cutoff: bcs::from_bytes(script.args().get(3)?).ok()?,
            intrinsic_gas_per_byte: bcs::from_bytes(script.args().get(4)?).ok()?,
            maximum_number_of_gas_units: bcs::from_bytes(script.args().get(5)?).ok()?,
            min_price_per_gas_unit: bcs::from_bytes(script.args().get(6)?).ok()?,
            max_price_per_gas_unit: bcs::from_bytes(script.args().get(7)?).ok()?,
            max_transaction_size_in_bytes: bcs::from_bytes(script.args().get(8)?).ok()?,
            gas_unit_scaling_factor: bcs::from_bytes(script.args().get(9)?).ok()?,
            default_account_size: bcs::from_bytes(script.args().get(10)?).ok()?,
        })
    } else {
        None
    }
}

fn decode_set_version_script_function(payload: &TransactionPayload) -> Option<ScriptFunctionCall> {
    if let TransactionPayload::ScriptFunction(script) = payload {
        Some(ScriptFunctionCall::SetVersion {
            major: bcs::from_bytes(script.args().get(0)?).ok()?,
        })
    } else {
        None
    }
}

fn decode_transfer_script_function(payload: &TransactionPayload) -> Option<ScriptFunctionCall> {
    if let TransactionPayload::ScriptFunction(script) = payload {
        Some(ScriptFunctionCall::Transfer {
            to: bcs::from_bytes(script.args().get(0)?).ok()?,
            amount: bcs::from_bytes(script.args().get(1)?).ok()?,
        })
    } else {
        None
    }
}

type ScriptFunctionDecoderMap = std::collections::HashMap<
    String,
    Box<
        dyn Fn(&TransactionPayload) -> Option<ScriptFunctionCall>
            + std::marker::Sync
            + std::marker::Send,
    >,
>;

static SCRIPT_FUNCTION_DECODER_MAP: once_cell::sync::Lazy<ScriptFunctionDecoderMap> =
    once_cell::sync::Lazy::new(|| {
        let mut map: ScriptFunctionDecoderMap = std::collections::HashMap::new();
        map.insert(
            "TokenTransferscancel_offer_script".to_string(),
            Box::new(decode_cancel_offer_script_script_function),
        );
        map.insert(
            "TestCoinclaim_mint_capability".to_string(),
            Box::new(decode_claim_mint_capability_script_function),
        );
        map.insert(
            "TokenTransfersclaim_script".to_string(),
            Box::new(decode_claim_script_script_function),
        );
        map.insert(
            "AptosAccountcreate_account".to_string(),
            Box::new(decode_create_account_script_function),
        );
        map.insert(
            "Tokencreate_finite_collection_script".to_string(),
            Box::new(decode_create_finite_collection_script_script_function),
        );
        map.insert(
            "SimpleTokencreate_simple_token".to_string(),
            Box::new(decode_create_simple_token_script_function),
        );
        map.insert(
            "Tokencreate_token_script".to_string(),
            Box::new(decode_create_token_script_script_function),
        );
        map.insert(
            "Tokencreate_unlimited_collection_script".to_string(),
            Box::new(decode_create_unlimited_collection_script_script_function),
        );
        map.insert(
            "TestCoindelegate_mint_capability".to_string(),
            Box::new(decode_delegate_mint_capability_script_function),
        );
        map.insert(
            "TestCoinmint".to_string(),
            Box::new(decode_mint_script_function),
        );
        map.insert(
            "TokenTransfersoffer_script".to_string(),
            Box::new(decode_offer_script_script_function),
        );
        map.insert(
            "AptosAccountrotate_authentication_key".to_string(),
            Box::new(decode_rotate_authentication_key_script_function),
        );
        map.insert(
            "AptosVMConfigset_gas_constants".to_string(),
            Box::new(decode_set_gas_constants_script_function),
        );
        map.insert(
            "AptosVersionset_version".to_string(),
            Box::new(decode_set_version_script_function),
        );
        map.insert(
            "TestCointransfer".to_string(),
            Box::new(decode_transfer_script_function),
        );
        map
    });
