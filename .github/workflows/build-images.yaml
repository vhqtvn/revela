## IMPORTANT NOTE TO EDITORS OF THIS FILE ## 

## Note that when you create a PR the jobs in this file are triggered off the `pull_request_target` event instead of `pull_request` event.
## This is because the `pull_request` event makes secrets only available to PRs from branches, not from forks, and some of these jobs require secrets.
## So with `pull_request_target` we're making secrets available to fork-based PRs too.
## Using `pull_request_target" has a side effect, which is that the workflow execution will be driven by the state of the <workflow>.yaml on the `main` (=target) branch, even if you edited the <workflow>.yaml in your PR.
## So when you for example add a new job here, you won't see that job appear in the PR itself. It will only become effective once you merge the PR to main.
## Therefore, if you want to add a new job here and want to test it's functionality prior to a merge to main, you have to to _temporarily_ change the trigger event from `pull_request_target` to `pull_request`.

## Additionally, because `pull_request_target` gets secrets injected for forked PRs we use `https://github.com/sushichop/action-repository-permission`
## to ensure these jobs are only executed when a repo member with "write" permission has triggered the workflow (directly through a push or indirectly by applying a label or enabling auto_merge).

name: "Build+Push Images"
on: # build on main branch OR when a PR is labeled with `CICD:build-images`
  # Allow us to run this specific workflow without a PR
  workflow_dispatch:
  pull_request_target:
    types: [labeled, opened, synchronize, reopened, auto_merge_enabled]
  push:
    branches:
      # - main - TODO - this disables main branch image building since we assume it's already being built from the auto branch before merging (due to how bors works), possibly reactivate this if we move away from bors
      - auto
      - canary
      - devnet
      - testnet

# cancel redundant builds
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  GCP_DOCKER_ARTIFACT_REPO: ${{ secrets.GCP_DOCKER_ARTIFACT_REPO }}
  AWS_ECR_ACCOUNT_NUM: ${{ secrets.ENV_ECR_AWS_ACCOUNT_NUM }}
  # In case of pull_request events by default github actions merges main into the PR branch and then runs the tests etc
  # on the prospective merge result instead of only on the tip of the PR.
  # We want to avoid this in case of docker image builds on PRs since want more predictable images then correspond to the code state a developer pushed from local.
  # Therefore we build the images with the head of the PR branch instead of the prospective merge result.
  # Safety-wise the merge queue (bors/kodiak or whatever we use) will retest the PR branch merged with the base branch anyways.
  # In case of push events, this hack is a noop as we default to `github.sha`.
  # For more info also see https://github.com/actions/checkout#checkout-pull-request-head-commit-instead-of-merge-commit
  GIT_SHA: ${{ github.event.pull_request.head.sha || github.sha }}

permissions:
  contents: read
  id-token: write #required for GCP Workload Identity federation which we use to login into Google Artifact Registry
  issues: write
  pull-requests: write

jobs:

  permission-check:
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch' || contains(github.event.pull_request.labels.*.name, 'CICD:build-images') || github.event.pull_request.auto_merge != null
    runs-on: ubuntu-latest
    steps: 
    - name: Check repository permission for user which triggered job
      id: permission
      uses: sushichop/action-repository-permission@13d208f5ae7a6a3fc0e5a7c2502c214983f0241c
      with:
        required-permission: write
        comment-not-permitted: Sorry, you don't have permission to trigger this workflow.

  rust-images:
    # trigger only for push events (on protected branches as defined above) OR on PR events with the "CICD:build-images" label.
    needs: permission-check
    strategy:
      matrix:
        IMAGE_TARGET: [release, test]

    runs-on: high-perf-docker
    steps:
      - uses: actions/checkout@v3
        with:
          ref: ${{ env.GIT_SHA }}

      - uses: ./.github/actions/gar-auth
        with:
          GCP_WORKLOAD_IDENTITY_PROVIDER: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          GCP_SERVICE_ACCOUNT_EMAIL: ${{ secrets.GCP_SERVICE_ACCOUNT_EMAIL }}

      - name: Login to ECR
        uses: docker/login-action@v2
        with:
          registry: ${{ secrets.ENV_ECR_AWS_ACCOUNT_NUM }}.dkr.ecr.us-west-2.amazonaws.com
          username: ${{ secrets.AWS_ACCESS_KEY_ID }}
          password: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      - uses: ./.github/actions/docker-buildx-setup

      - name: Build and Push Rust images
        run: docker/docker-bake-rust-all.sh
        env:
          IMAGE_TARGET: ${{ matrix.IMAGE_TARGET }}
          GIT_BRANCH: ${{ github.head_ref }}

  sdk-integration-test:
    needs: rust-images
    uses: ./.github/workflows/sdk-integration-test.yaml
    secrets: inherit
    with:
      GIT_SHA: ${{ github.event.pull_request.head.sha || github.sha }}

  forge-e2e-test:
    needs: rust-images
    uses: ./.github/workflows/run-forge.yaml
    secrets: inherit
    with:
      GIT_SHA: ${{ github.event.pull_request.head.sha || github.sha }}
      merge_or_canary: ${{ github.event.pull_request.auto_merge != null && 'merge' || 'canary' }}

  community-platform:
    needs: permission-check
    if: github.event_name == 'push' || contains(github.event.pull_request.labels.*.name, 'CICD:build-images')
    runs-on: high-perf-docker
    steps:
      - uses: actions/checkout@v3
        with:
          ref: ${{ env.GIT_SHA }}

      - uses: ./.github/actions/gar-auth
        with:
          GCP_WORKLOAD_IDENTITY_PROVIDER: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          GCP_SERVICE_ACCOUNT_EMAIL: ${{ secrets.GCP_SERVICE_ACCOUNT_EMAIL }}

      - name: Login to ECR
        uses: docker/login-action@v2
        with:
          registry: ${{ secrets.ENV_ECR_AWS_ACCOUNT_NUM }}.dkr.ecr.us-west-2.amazonaws.com
          username: ${{ secrets.AWS_ACCESS_KEY_ID }}
          password: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      - uses: ./.github/actions/docker-buildx-setup

      - name: Build and Push Community Platform image
        env:
          GIT_BRANCH: ${{ github.head_ref }}
        run: |
          cd ecosystem/platform/server
          docker buildx bake --progress=plain --push -f ./docker-bake.hcl

  indexer-server:
    needs: permission-check
    runs-on: high-perf-docker
    steps:
      - uses: actions/checkout@v3
        with:
          ref: ${{ env.GIT_SHA }}

      - uses: ./.github/actions/gar-auth
        with:
          GCP_WORKLOAD_IDENTITY_PROVIDER: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          GCP_SERVICE_ACCOUNT_EMAIL: ${{ secrets.GCP_SERVICE_ACCOUNT_EMAIL }}

      - name: Login to ECR
        uses: docker/login-action@v2
        with:
          registry: ${{ secrets.ENV_ECR_AWS_ACCOUNT_NUM }}.dkr.ecr.us-west-2.amazonaws.com
          username: ${{ secrets.AWS_ACCESS_KEY_ID }}
          password: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      - uses: ./.github/actions/docker-buildx-setup

      - name: Build and Push Indexer Server image
        env:
          GIT_BRANCH: ${{ github.head_ref }}
        run: |
          cd ecosystem/indexer-server
          docker buildx bake --progress=plain --push -f ./docker-bake.hcl
